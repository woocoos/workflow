// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/woocoos/workflow/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/woocoos/workflow/ent/decisiondef"
	"github.com/woocoos/workflow/ent/decisionreqdef"
	"github.com/woocoos/workflow/ent/deployment"
	"github.com/woocoos/workflow/ent/identitylink"
	"github.com/woocoos/workflow/ent/procdef"
	"github.com/woocoos/workflow/ent/procinst"
	"github.com/woocoos/workflow/ent/task"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// DecisionDef is the client for interacting with the DecisionDef builders.
	DecisionDef *DecisionDefClient
	// DecisionReqDef is the client for interacting with the DecisionReqDef builders.
	DecisionReqDef *DecisionReqDefClient
	// Deployment is the client for interacting with the Deployment builders.
	Deployment *DeploymentClient
	// IdentityLink is the client for interacting with the IdentityLink builders.
	IdentityLink *IdentityLinkClient
	// ProcDef is the client for interacting with the ProcDef builders.
	ProcDef *ProcDefClient
	// ProcInst is the client for interacting with the ProcInst builders.
	ProcInst *ProcInstClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// additional fields for node api
	tables tables
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.DecisionDef = NewDecisionDefClient(c.config)
	c.DecisionReqDef = NewDecisionReqDefClient(c.config)
	c.Deployment = NewDeploymentClient(c.config)
	c.IdentityLink = NewIdentityLinkClient(c.config)
	c.ProcDef = NewProcDefClient(c.config)
	c.ProcInst = NewProcInstClient(c.config)
	c.Task = NewTaskClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		DecisionDef:    NewDecisionDefClient(cfg),
		DecisionReqDef: NewDecisionReqDefClient(cfg),
		Deployment:     NewDeploymentClient(cfg),
		IdentityLink:   NewIdentityLinkClient(cfg),
		ProcDef:        NewProcDefClient(cfg),
		ProcInst:       NewProcInstClient(cfg),
		Task:           NewTaskClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:            ctx,
		config:         cfg,
		DecisionDef:    NewDecisionDefClient(cfg),
		DecisionReqDef: NewDecisionReqDefClient(cfg),
		Deployment:     NewDeploymentClient(cfg),
		IdentityLink:   NewIdentityLinkClient(cfg),
		ProcDef:        NewProcDefClient(cfg),
		ProcInst:       NewProcInstClient(cfg),
		Task:           NewTaskClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		DecisionDef.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.DecisionDef, c.DecisionReqDef, c.Deployment, c.IdentityLink, c.ProcDef,
		c.ProcInst, c.Task,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.DecisionDef, c.DecisionReqDef, c.Deployment, c.IdentityLink, c.ProcDef,
		c.ProcInst, c.Task,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DecisionDefMutation:
		return c.DecisionDef.mutate(ctx, m)
	case *DecisionReqDefMutation:
		return c.DecisionReqDef.mutate(ctx, m)
	case *DeploymentMutation:
		return c.Deployment.mutate(ctx, m)
	case *IdentityLinkMutation:
		return c.IdentityLink.mutate(ctx, m)
	case *ProcDefMutation:
		return c.ProcDef.mutate(ctx, m)
	case *ProcInstMutation:
		return c.ProcInst.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DecisionDefClient is a client for the DecisionDef schema.
type DecisionDefClient struct {
	config
}

// NewDecisionDefClient returns a client for the DecisionDef from the given config.
func NewDecisionDefClient(c config) *DecisionDefClient {
	return &DecisionDefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `decisiondef.Hooks(f(g(h())))`.
func (c *DecisionDefClient) Use(hooks ...Hook) {
	c.hooks.DecisionDef = append(c.hooks.DecisionDef, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `decisiondef.Intercept(f(g(h())))`.
func (c *DecisionDefClient) Intercept(interceptors ...Interceptor) {
	c.inters.DecisionDef = append(c.inters.DecisionDef, interceptors...)
}

// Create returns a builder for creating a DecisionDef entity.
func (c *DecisionDefClient) Create() *DecisionDefCreate {
	mutation := newDecisionDefMutation(c.config, OpCreate)
	return &DecisionDefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DecisionDef entities.
func (c *DecisionDefClient) CreateBulk(builders ...*DecisionDefCreate) *DecisionDefCreateBulk {
	return &DecisionDefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DecisionDef.
func (c *DecisionDefClient) Update() *DecisionDefUpdate {
	mutation := newDecisionDefMutation(c.config, OpUpdate)
	return &DecisionDefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DecisionDefClient) UpdateOne(dd *DecisionDef) *DecisionDefUpdateOne {
	mutation := newDecisionDefMutation(c.config, OpUpdateOne, withDecisionDef(dd))
	return &DecisionDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DecisionDefClient) UpdateOneID(id int) *DecisionDefUpdateOne {
	mutation := newDecisionDefMutation(c.config, OpUpdateOne, withDecisionDefID(id))
	return &DecisionDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DecisionDef.
func (c *DecisionDefClient) Delete() *DecisionDefDelete {
	mutation := newDecisionDefMutation(c.config, OpDelete)
	return &DecisionDefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DecisionDefClient) DeleteOne(dd *DecisionDef) *DecisionDefDeleteOne {
	return c.DeleteOneID(dd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DecisionDefClient) DeleteOneID(id int) *DecisionDefDeleteOne {
	builder := c.Delete().Where(decisiondef.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DecisionDefDeleteOne{builder}
}

// Query returns a query builder for DecisionDef.
func (c *DecisionDefClient) Query() *DecisionDefQuery {
	return &DecisionDefQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDecisionDef},
		inters: c.Interceptors(),
	}
}

// Get returns a DecisionDef entity by its id.
func (c *DecisionDefClient) Get(ctx context.Context, id int) (*DecisionDef, error) {
	return c.Query().Where(decisiondef.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DecisionDefClient) GetX(ctx context.Context, id int) *DecisionDef {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReqDef queries the req_def edge of a DecisionDef.
func (c *DecisionDefClient) QueryReqDef(dd *DecisionDef) *DecisionReqDefQuery {
	query := (&DecisionReqDefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(decisiondef.Table, decisiondef.FieldID, id),
			sqlgraph.To(decisionreqdef.Table, decisionreqdef.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, decisiondef.ReqDefTable, decisiondef.ReqDefColumn),
		)
		fromV = sqlgraph.Neighbors(dd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DecisionDefClient) Hooks() []Hook {
	hooks := c.hooks.DecisionDef
	return append(hooks[:len(hooks):len(hooks)], decisiondef.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DecisionDefClient) Interceptors() []Interceptor {
	return c.inters.DecisionDef
}

func (c *DecisionDefClient) mutate(ctx context.Context, m *DecisionDefMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DecisionDefCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DecisionDefUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DecisionDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DecisionDefDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DecisionDef mutation op: %q", m.Op())
	}
}

// DecisionReqDefClient is a client for the DecisionReqDef schema.
type DecisionReqDefClient struct {
	config
}

// NewDecisionReqDefClient returns a client for the DecisionReqDef from the given config.
func NewDecisionReqDefClient(c config) *DecisionReqDefClient {
	return &DecisionReqDefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `decisionreqdef.Hooks(f(g(h())))`.
func (c *DecisionReqDefClient) Use(hooks ...Hook) {
	c.hooks.DecisionReqDef = append(c.hooks.DecisionReqDef, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `decisionreqdef.Intercept(f(g(h())))`.
func (c *DecisionReqDefClient) Intercept(interceptors ...Interceptor) {
	c.inters.DecisionReqDef = append(c.inters.DecisionReqDef, interceptors...)
}

// Create returns a builder for creating a DecisionReqDef entity.
func (c *DecisionReqDefClient) Create() *DecisionReqDefCreate {
	mutation := newDecisionReqDefMutation(c.config, OpCreate)
	return &DecisionReqDefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DecisionReqDef entities.
func (c *DecisionReqDefClient) CreateBulk(builders ...*DecisionReqDefCreate) *DecisionReqDefCreateBulk {
	return &DecisionReqDefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DecisionReqDef.
func (c *DecisionReqDefClient) Update() *DecisionReqDefUpdate {
	mutation := newDecisionReqDefMutation(c.config, OpUpdate)
	return &DecisionReqDefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DecisionReqDefClient) UpdateOne(drd *DecisionReqDef) *DecisionReqDefUpdateOne {
	mutation := newDecisionReqDefMutation(c.config, OpUpdateOne, withDecisionReqDef(drd))
	return &DecisionReqDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DecisionReqDefClient) UpdateOneID(id int) *DecisionReqDefUpdateOne {
	mutation := newDecisionReqDefMutation(c.config, OpUpdateOne, withDecisionReqDefID(id))
	return &DecisionReqDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DecisionReqDef.
func (c *DecisionReqDefClient) Delete() *DecisionReqDefDelete {
	mutation := newDecisionReqDefMutation(c.config, OpDelete)
	return &DecisionReqDefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DecisionReqDefClient) DeleteOne(drd *DecisionReqDef) *DecisionReqDefDeleteOne {
	return c.DeleteOneID(drd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DecisionReqDefClient) DeleteOneID(id int) *DecisionReqDefDeleteOne {
	builder := c.Delete().Where(decisionreqdef.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DecisionReqDefDeleteOne{builder}
}

// Query returns a query builder for DecisionReqDef.
func (c *DecisionReqDefClient) Query() *DecisionReqDefQuery {
	return &DecisionReqDefQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDecisionReqDef},
		inters: c.Interceptors(),
	}
}

// Get returns a DecisionReqDef entity by its id.
func (c *DecisionReqDefClient) Get(ctx context.Context, id int) (*DecisionReqDef, error) {
	return c.Query().Where(decisionreqdef.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DecisionReqDefClient) GetX(ctx context.Context, id int) *DecisionReqDef {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeployment queries the deployment edge of a DecisionReqDef.
func (c *DecisionReqDefClient) QueryDeployment(drd *DecisionReqDef) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := drd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(decisionreqdef.Table, decisionreqdef.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, decisionreqdef.DeploymentTable, decisionreqdef.DeploymentColumn),
		)
		fromV = sqlgraph.Neighbors(drd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDecisionDefs queries the decision_defs edge of a DecisionReqDef.
func (c *DecisionReqDefClient) QueryDecisionDefs(drd *DecisionReqDef) *DecisionDefQuery {
	query := (&DecisionDefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := drd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(decisionreqdef.Table, decisionreqdef.FieldID, id),
			sqlgraph.To(decisiondef.Table, decisiondef.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, decisionreqdef.DecisionDefsTable, decisionreqdef.DecisionDefsColumn),
		)
		fromV = sqlgraph.Neighbors(drd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DecisionReqDefClient) Hooks() []Hook {
	hooks := c.hooks.DecisionReqDef
	return append(hooks[:len(hooks):len(hooks)], decisionreqdef.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DecisionReqDefClient) Interceptors() []Interceptor {
	return c.inters.DecisionReqDef
}

func (c *DecisionReqDefClient) mutate(ctx context.Context, m *DecisionReqDefMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DecisionReqDefCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DecisionReqDefUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DecisionReqDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DecisionReqDefDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DecisionReqDef mutation op: %q", m.Op())
	}
}

// DeploymentClient is a client for the Deployment schema.
type DeploymentClient struct {
	config
}

// NewDeploymentClient returns a client for the Deployment from the given config.
func NewDeploymentClient(c config) *DeploymentClient {
	return &DeploymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `deployment.Hooks(f(g(h())))`.
func (c *DeploymentClient) Use(hooks ...Hook) {
	c.hooks.Deployment = append(c.hooks.Deployment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `deployment.Intercept(f(g(h())))`.
func (c *DeploymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Deployment = append(c.inters.Deployment, interceptors...)
}

// Create returns a builder for creating a Deployment entity.
func (c *DeploymentClient) Create() *DeploymentCreate {
	mutation := newDeploymentMutation(c.config, OpCreate)
	return &DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Deployment entities.
func (c *DeploymentClient) CreateBulk(builders ...*DeploymentCreate) *DeploymentCreateBulk {
	return &DeploymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Deployment.
func (c *DeploymentClient) Update() *DeploymentUpdate {
	mutation := newDeploymentMutation(c.config, OpUpdate)
	return &DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeploymentClient) UpdateOne(d *Deployment) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeployment(d))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeploymentClient) UpdateOneID(id int) *DeploymentUpdateOne {
	mutation := newDeploymentMutation(c.config, OpUpdateOne, withDeploymentID(id))
	return &DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Deployment.
func (c *DeploymentClient) Delete() *DeploymentDelete {
	mutation := newDeploymentMutation(c.config, OpDelete)
	return &DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeploymentClient) DeleteOne(d *Deployment) *DeploymentDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeploymentClient) DeleteOneID(id int) *DeploymentDeleteOne {
	builder := c.Delete().Where(deployment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeploymentDeleteOne{builder}
}

// Query returns a query builder for Deployment.
func (c *DeploymentClient) Query() *DeploymentQuery {
	return &DeploymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDeployment},
		inters: c.Interceptors(),
	}
}

// Get returns a Deployment entity by its id.
func (c *DeploymentClient) Get(ctx context.Context, id int) (*Deployment, error) {
	return c.Query().Where(deployment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeploymentClient) GetX(ctx context.Context, id int) *Deployment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProcDefs queries the proc_defs edge of a Deployment.
func (c *DeploymentClient) QueryProcDefs(d *Deployment) *ProcDefQuery {
	query := (&ProcDefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(procdef.Table, procdef.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deployment.ProcDefsTable, deployment.ProcDefsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDecisionReqs queries the decision_reqs edge of a Deployment.
func (c *DeploymentClient) QueryDecisionReqs(d *Deployment) *DecisionReqDefQuery {
	query := (&DecisionReqDefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(deployment.Table, deployment.FieldID, id),
			sqlgraph.To(decisionreqdef.Table, decisionreqdef.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deployment.DecisionReqsTable, deployment.DecisionReqsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeploymentClient) Hooks() []Hook {
	hooks := c.hooks.Deployment
	return append(hooks[:len(hooks):len(hooks)], deployment.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DeploymentClient) Interceptors() []Interceptor {
	return c.inters.Deployment
}

func (c *DeploymentClient) mutate(ctx context.Context, m *DeploymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DeploymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DeploymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DeploymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DeploymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Deployment mutation op: %q", m.Op())
	}
}

// IdentityLinkClient is a client for the IdentityLink schema.
type IdentityLinkClient struct {
	config
}

// NewIdentityLinkClient returns a client for the IdentityLink from the given config.
func NewIdentityLinkClient(c config) *IdentityLinkClient {
	return &IdentityLinkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `identitylink.Hooks(f(g(h())))`.
func (c *IdentityLinkClient) Use(hooks ...Hook) {
	c.hooks.IdentityLink = append(c.hooks.IdentityLink, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `identitylink.Intercept(f(g(h())))`.
func (c *IdentityLinkClient) Intercept(interceptors ...Interceptor) {
	c.inters.IdentityLink = append(c.inters.IdentityLink, interceptors...)
}

// Create returns a builder for creating a IdentityLink entity.
func (c *IdentityLinkClient) Create() *IdentityLinkCreate {
	mutation := newIdentityLinkMutation(c.config, OpCreate)
	return &IdentityLinkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IdentityLink entities.
func (c *IdentityLinkClient) CreateBulk(builders ...*IdentityLinkCreate) *IdentityLinkCreateBulk {
	return &IdentityLinkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IdentityLink.
func (c *IdentityLinkClient) Update() *IdentityLinkUpdate {
	mutation := newIdentityLinkMutation(c.config, OpUpdate)
	return &IdentityLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IdentityLinkClient) UpdateOne(il *IdentityLink) *IdentityLinkUpdateOne {
	mutation := newIdentityLinkMutation(c.config, OpUpdateOne, withIdentityLink(il))
	return &IdentityLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IdentityLinkClient) UpdateOneID(id int) *IdentityLinkUpdateOne {
	mutation := newIdentityLinkMutation(c.config, OpUpdateOne, withIdentityLinkID(id))
	return &IdentityLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IdentityLink.
func (c *IdentityLinkClient) Delete() *IdentityLinkDelete {
	mutation := newIdentityLinkMutation(c.config, OpDelete)
	return &IdentityLinkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IdentityLinkClient) DeleteOne(il *IdentityLink) *IdentityLinkDeleteOne {
	return c.DeleteOneID(il.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IdentityLinkClient) DeleteOneID(id int) *IdentityLinkDeleteOne {
	builder := c.Delete().Where(identitylink.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IdentityLinkDeleteOne{builder}
}

// Query returns a query builder for IdentityLink.
func (c *IdentityLinkClient) Query() *IdentityLinkQuery {
	return &IdentityLinkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIdentityLink},
		inters: c.Interceptors(),
	}
}

// Get returns a IdentityLink entity by its id.
func (c *IdentityLinkClient) Get(ctx context.Context, id int) (*IdentityLink, error) {
	return c.Query().Where(identitylink.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IdentityLinkClient) GetX(ctx context.Context, id int) *IdentityLink {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTask queries the task edge of a IdentityLink.
func (c *IdentityLinkClient) QueryTask(il *IdentityLink) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := il.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(identitylink.Table, identitylink.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, identitylink.TaskTable, identitylink.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(il.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IdentityLinkClient) Hooks() []Hook {
	return c.hooks.IdentityLink
}

// Interceptors returns the client interceptors.
func (c *IdentityLinkClient) Interceptors() []Interceptor {
	return c.inters.IdentityLink
}

func (c *IdentityLinkClient) mutate(ctx context.Context, m *IdentityLinkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IdentityLinkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IdentityLinkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IdentityLinkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IdentityLinkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IdentityLink mutation op: %q", m.Op())
	}
}

// ProcDefClient is a client for the ProcDef schema.
type ProcDefClient struct {
	config
}

// NewProcDefClient returns a client for the ProcDef from the given config.
func NewProcDefClient(c config) *ProcDefClient {
	return &ProcDefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `procdef.Hooks(f(g(h())))`.
func (c *ProcDefClient) Use(hooks ...Hook) {
	c.hooks.ProcDef = append(c.hooks.ProcDef, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `procdef.Intercept(f(g(h())))`.
func (c *ProcDefClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProcDef = append(c.inters.ProcDef, interceptors...)
}

// Create returns a builder for creating a ProcDef entity.
func (c *ProcDefClient) Create() *ProcDefCreate {
	mutation := newProcDefMutation(c.config, OpCreate)
	return &ProcDefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProcDef entities.
func (c *ProcDefClient) CreateBulk(builders ...*ProcDefCreate) *ProcDefCreateBulk {
	return &ProcDefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProcDef.
func (c *ProcDefClient) Update() *ProcDefUpdate {
	mutation := newProcDefMutation(c.config, OpUpdate)
	return &ProcDefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcDefClient) UpdateOne(pd *ProcDef) *ProcDefUpdateOne {
	mutation := newProcDefMutation(c.config, OpUpdateOne, withProcDef(pd))
	return &ProcDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcDefClient) UpdateOneID(id int) *ProcDefUpdateOne {
	mutation := newProcDefMutation(c.config, OpUpdateOne, withProcDefID(id))
	return &ProcDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProcDef.
func (c *ProcDefClient) Delete() *ProcDefDelete {
	mutation := newProcDefMutation(c.config, OpDelete)
	return &ProcDefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcDefClient) DeleteOne(pd *ProcDef) *ProcDefDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProcDefClient) DeleteOneID(id int) *ProcDefDeleteOne {
	builder := c.Delete().Where(procdef.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcDefDeleteOne{builder}
}

// Query returns a query builder for ProcDef.
func (c *ProcDefClient) Query() *ProcDefQuery {
	return &ProcDefQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProcDef},
		inters: c.Interceptors(),
	}
}

// Get returns a ProcDef entity by its id.
func (c *ProcDefClient) Get(ctx context.Context, id int) (*ProcDef, error) {
	return c.Query().Where(procdef.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcDefClient) GetX(ctx context.Context, id int) *ProcDef {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDeployment queries the deployment edge of a ProcDef.
func (c *ProcDefClient) QueryDeployment(pd *ProcDef) *DeploymentQuery {
	query := (&DeploymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procdef.Table, procdef.FieldID, id),
			sqlgraph.To(deployment.Table, deployment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, procdef.DeploymentTable, procdef.DeploymentColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProcInstances queries the proc_instances edge of a ProcDef.
func (c *ProcDefClient) QueryProcInstances(pd *ProcDef) *ProcInstQuery {
	query := (&ProcInstClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procdef.Table, procdef.FieldID, id),
			sqlgraph.To(procinst.Table, procinst.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, procdef.ProcInstancesTable, procdef.ProcInstancesColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProcDefClient) Hooks() []Hook {
	hooks := c.hooks.ProcDef
	return append(hooks[:len(hooks):len(hooks)], procdef.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProcDefClient) Interceptors() []Interceptor {
	return c.inters.ProcDef
}

func (c *ProcDefClient) mutate(ctx context.Context, m *ProcDefMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProcDefCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProcDefUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProcDefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProcDefDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProcDef mutation op: %q", m.Op())
	}
}

// ProcInstClient is a client for the ProcInst schema.
type ProcInstClient struct {
	config
}

// NewProcInstClient returns a client for the ProcInst from the given config.
func NewProcInstClient(c config) *ProcInstClient {
	return &ProcInstClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `procinst.Hooks(f(g(h())))`.
func (c *ProcInstClient) Use(hooks ...Hook) {
	c.hooks.ProcInst = append(c.hooks.ProcInst, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `procinst.Intercept(f(g(h())))`.
func (c *ProcInstClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProcInst = append(c.inters.ProcInst, interceptors...)
}

// Create returns a builder for creating a ProcInst entity.
func (c *ProcInstClient) Create() *ProcInstCreate {
	mutation := newProcInstMutation(c.config, OpCreate)
	return &ProcInstCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProcInst entities.
func (c *ProcInstClient) CreateBulk(builders ...*ProcInstCreate) *ProcInstCreateBulk {
	return &ProcInstCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProcInst.
func (c *ProcInstClient) Update() *ProcInstUpdate {
	mutation := newProcInstMutation(c.config, OpUpdate)
	return &ProcInstUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcInstClient) UpdateOne(pi *ProcInst) *ProcInstUpdateOne {
	mutation := newProcInstMutation(c.config, OpUpdateOne, withProcInst(pi))
	return &ProcInstUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcInstClient) UpdateOneID(id int) *ProcInstUpdateOne {
	mutation := newProcInstMutation(c.config, OpUpdateOne, withProcInstID(id))
	return &ProcInstUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProcInst.
func (c *ProcInstClient) Delete() *ProcInstDelete {
	mutation := newProcInstMutation(c.config, OpDelete)
	return &ProcInstDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcInstClient) DeleteOne(pi *ProcInst) *ProcInstDeleteOne {
	return c.DeleteOneID(pi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProcInstClient) DeleteOneID(id int) *ProcInstDeleteOne {
	builder := c.Delete().Where(procinst.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcInstDeleteOne{builder}
}

// Query returns a query builder for ProcInst.
func (c *ProcInstClient) Query() *ProcInstQuery {
	return &ProcInstQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProcInst},
		inters: c.Interceptors(),
	}
}

// Get returns a ProcInst entity by its id.
func (c *ProcInstClient) Get(ctx context.Context, id int) (*ProcInst, error) {
	return c.Query().Where(procinst.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcInstClient) GetX(ctx context.Context, id int) *ProcInst {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProcDef queries the proc_def edge of a ProcInst.
func (c *ProcInstClient) QueryProcDef(pi *ProcInst) *ProcDefQuery {
	query := (&ProcDefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procinst.Table, procinst.FieldID, id),
			sqlgraph.To(procdef.Table, procdef.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, procinst.ProcDefTable, procinst.ProcDefColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a ProcInst.
func (c *ProcInstClient) QueryTasks(pi *ProcInst) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(procinst.Table, procinst.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, procinst.TasksTable, procinst.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(pi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProcInstClient) Hooks() []Hook {
	hooks := c.hooks.ProcInst
	return append(hooks[:len(hooks):len(hooks)], procinst.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *ProcInstClient) Interceptors() []Interceptor {
	return c.inters.ProcInst
}

func (c *ProcInstClient) mutate(ctx context.Context, m *ProcInstMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProcInstCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProcInstUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProcInstUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProcInstDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProcInst mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id int) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProcInst queries the proc_inst edge of a Task.
func (c *TaskClient) QueryProcInst(t *Task) *ProcInstQuery {
	query := (&ProcInstClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(procinst.Table, procinst.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.ProcInstTable, task.ProcInstColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTaskIdentities queries the task_identities edge of a Task.
func (c *TaskClient) QueryTaskIdentities(t *Task) *IdentityLinkQuery {
	query := (&IdentityLinkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(identitylink.Table, identitylink.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.TaskIdentitiesTable, task.TaskIdentitiesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		DecisionDef, DecisionReqDef, Deployment, IdentityLink, ProcDef, ProcInst,
		Task []ent.Hook
	}
	inters struct {
		DecisionDef, DecisionReqDef, Deployment, IdentityLink, ProcDef, ProcInst,
		Task []ent.Interceptor
	}
)
