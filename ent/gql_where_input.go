// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/woocoos/entco/schemax/typex"
	"github.com/woocoos/workflow/ent/decisiondef"
	"github.com/woocoos/workflow/ent/decisionreqdef"
	"github.com/woocoos/workflow/ent/deployment"
	"github.com/woocoos/workflow/ent/identitylink"
	"github.com/woocoos/workflow/ent/orgrole"
	"github.com/woocoos/workflow/ent/orguser"
	"github.com/woocoos/workflow/ent/predicate"
	"github.com/woocoos/workflow/ent/procdef"
	"github.com/woocoos/workflow/ent/procinst"
	"github.com/woocoos/workflow/ent/task"
)

// DecisionDefWhereInput represents a where input for filtering DecisionDef queries.
type DecisionDefWhereInput struct {
	Predicates []predicate.DecisionDef  `json:"-"`
	Not        *DecisionDefWhereInput   `json:"not,omitempty"`
	Or         []*DecisionDefWhereInput `json:"or,omitempty"`
	And        []*DecisionDefWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "deployment_id" field predicates.
	DeploymentID      *int  `json:"deploymentID,omitempty"`
	DeploymentIDNEQ   *int  `json:"deploymentIDNEQ,omitempty"`
	DeploymentIDIn    []int `json:"deploymentIDIn,omitempty"`
	DeploymentIDNotIn []int `json:"deploymentIDNotIn,omitempty"`
	DeploymentIDGT    *int  `json:"deploymentIDGT,omitempty"`
	DeploymentIDGTE   *int  `json:"deploymentIDGTE,omitempty"`
	DeploymentIDLT    *int  `json:"deploymentIDLT,omitempty"`
	DeploymentIDLTE   *int  `json:"deploymentIDLTE,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`
	AppIDGT    *int  `json:"appIDGT,omitempty"`
	AppIDGTE   *int  `json:"appIDGTE,omitempty"`
	AppIDLT    *int  `json:"appIDLT,omitempty"`
	AppIDLTE   *int  `json:"appIDLTE,omitempty"`

	// "req_def_id" field predicates.
	ReqDefID      *int  `json:"reqDefID,omitempty"`
	ReqDefIDNEQ   *int  `json:"reqDefIDNEQ,omitempty"`
	ReqDefIDIn    []int `json:"reqDefIDIn,omitempty"`
	ReqDefIDNotIn []int `json:"reqDefIDNotIn,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "req_def_key" field predicates.
	ReqDefKey             *string  `json:"reqDefKey,omitempty"`
	ReqDefKeyNEQ          *string  `json:"reqDefKeyNEQ,omitempty"`
	ReqDefKeyIn           []string `json:"reqDefKeyIn,omitempty"`
	ReqDefKeyNotIn        []string `json:"reqDefKeyNotIn,omitempty"`
	ReqDefKeyGT           *string  `json:"reqDefKeyGT,omitempty"`
	ReqDefKeyGTE          *string  `json:"reqDefKeyGTE,omitempty"`
	ReqDefKeyLT           *string  `json:"reqDefKeyLT,omitempty"`
	ReqDefKeyLTE          *string  `json:"reqDefKeyLTE,omitempty"`
	ReqDefKeyContains     *string  `json:"reqDefKeyContains,omitempty"`
	ReqDefKeyHasPrefix    *string  `json:"reqDefKeyHasPrefix,omitempty"`
	ReqDefKeyHasSuffix    *string  `json:"reqDefKeyHasSuffix,omitempty"`
	ReqDefKeyEqualFold    *string  `json:"reqDefKeyEqualFold,omitempty"`
	ReqDefKeyContainsFold *string  `json:"reqDefKeyContainsFold,omitempty"`

	// "version" field predicates.
	Version      *int32  `json:"version,omitempty"`
	VersionNEQ   *int32  `json:"versionNEQ,omitempty"`
	VersionIn    []int32 `json:"versionIn,omitempty"`
	VersionNotIn []int32 `json:"versionNotIn,omitempty"`
	VersionGT    *int32  `json:"versionGT,omitempty"`
	VersionGTE   *int32  `json:"versionGTE,omitempty"`
	VersionLT    *int32  `json:"versionLT,omitempty"`
	VersionLTE   *int32  `json:"versionLTE,omitempty"`

	// "revision" field predicates.
	Revision       *int32  `json:"revision,omitempty"`
	RevisionNEQ    *int32  `json:"revisionNEQ,omitempty"`
	RevisionIn     []int32 `json:"revisionIn,omitempty"`
	RevisionNotIn  []int32 `json:"revisionNotIn,omitempty"`
	RevisionGT     *int32  `json:"revisionGT,omitempty"`
	RevisionGTE    *int32  `json:"revisionGTE,omitempty"`
	RevisionLT     *int32  `json:"revisionLT,omitempty"`
	RevisionLTE    *int32  `json:"revisionLTE,omitempty"`
	RevisionIsNil  bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil bool    `json:"revisionNotNil,omitempty"`

	// "version_tag" field predicates.
	VersionTag             *string  `json:"versionTag,omitempty"`
	VersionTagNEQ          *string  `json:"versionTagNEQ,omitempty"`
	VersionTagIn           []string `json:"versionTagIn,omitempty"`
	VersionTagNotIn        []string `json:"versionTagNotIn,omitempty"`
	VersionTagGT           *string  `json:"versionTagGT,omitempty"`
	VersionTagGTE          *string  `json:"versionTagGTE,omitempty"`
	VersionTagLT           *string  `json:"versionTagLT,omitempty"`
	VersionTagLTE          *string  `json:"versionTagLTE,omitempty"`
	VersionTagContains     *string  `json:"versionTagContains,omitempty"`
	VersionTagHasPrefix    *string  `json:"versionTagHasPrefix,omitempty"`
	VersionTagHasSuffix    *string  `json:"versionTagHasSuffix,omitempty"`
	VersionTagIsNil        bool     `json:"versionTagIsNil,omitempty"`
	VersionTagNotNil       bool     `json:"versionTagNotNil,omitempty"`
	VersionTagEqualFold    *string  `json:"versionTagEqualFold,omitempty"`
	VersionTagContainsFold *string  `json:"versionTagContainsFold,omitempty"`

	// "req_def" edge predicates.
	HasReqDef     *bool                       `json:"hasReqDef,omitempty"`
	HasReqDefWith []*DecisionReqDefWhereInput `json:"hasReqDefWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DecisionDefWhereInput) AddPredicates(predicates ...predicate.DecisionDef) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DecisionDefWhereInput filter on the DecisionDefQuery builder.
func (i *DecisionDefWhereInput) Filter(q *DecisionDefQuery) (*DecisionDefQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDecisionDefWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDecisionDefWhereInput is returned in case the DecisionDefWhereInput is empty.
var ErrEmptyDecisionDefWhereInput = errors.New("ent: empty predicate DecisionDefWhereInput")

// P returns a predicate for filtering decisiondefs.
// An error is returned if the input is empty or invalid.
func (i *DecisionDefWhereInput) P() (predicate.DecisionDef, error) {
	var predicates []predicate.DecisionDef
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, decisiondef.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DecisionDef, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, decisiondef.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DecisionDef, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, decisiondef.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, decisiondef.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, decisiondef.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, decisiondef.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, decisiondef.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, decisiondef.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, decisiondef.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, decisiondef.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, decisiondef.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, decisiondef.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, decisiondef.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, decisiondef.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, decisiondef.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, decisiondef.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, decisiondef.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, decisiondef.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, decisiondef.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, decisiondef.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, decisiondef.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, decisiondef.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, decisiondef.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, decisiondef.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, decisiondef.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, decisiondef.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, decisiondef.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, decisiondef.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, decisiondef.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, decisiondef.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, decisiondef.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, decisiondef.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, decisiondef.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, decisiondef.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, decisiondef.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, decisiondef.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, decisiondef.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, decisiondef.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, decisiondef.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, decisiondef.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, decisiondef.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, decisiondef.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, decisiondef.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, decisiondef.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, decisiondef.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, decisiondef.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, decisiondef.UpdatedAtNotNil())
	}
	if i.TenantID != nil {
		predicates = append(predicates, decisiondef.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, decisiondef.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, decisiondef.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, decisiondef.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, decisiondef.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, decisiondef.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, decisiondef.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, decisiondef.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.DeploymentID != nil {
		predicates = append(predicates, decisiondef.DeploymentIDEQ(*i.DeploymentID))
	}
	if i.DeploymentIDNEQ != nil {
		predicates = append(predicates, decisiondef.DeploymentIDNEQ(*i.DeploymentIDNEQ))
	}
	if len(i.DeploymentIDIn) > 0 {
		predicates = append(predicates, decisiondef.DeploymentIDIn(i.DeploymentIDIn...))
	}
	if len(i.DeploymentIDNotIn) > 0 {
		predicates = append(predicates, decisiondef.DeploymentIDNotIn(i.DeploymentIDNotIn...))
	}
	if i.DeploymentIDGT != nil {
		predicates = append(predicates, decisiondef.DeploymentIDGT(*i.DeploymentIDGT))
	}
	if i.DeploymentIDGTE != nil {
		predicates = append(predicates, decisiondef.DeploymentIDGTE(*i.DeploymentIDGTE))
	}
	if i.DeploymentIDLT != nil {
		predicates = append(predicates, decisiondef.DeploymentIDLT(*i.DeploymentIDLT))
	}
	if i.DeploymentIDLTE != nil {
		predicates = append(predicates, decisiondef.DeploymentIDLTE(*i.DeploymentIDLTE))
	}
	if i.AppID != nil {
		predicates = append(predicates, decisiondef.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, decisiondef.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, decisiondef.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, decisiondef.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.AppIDGT != nil {
		predicates = append(predicates, decisiondef.AppIDGT(*i.AppIDGT))
	}
	if i.AppIDGTE != nil {
		predicates = append(predicates, decisiondef.AppIDGTE(*i.AppIDGTE))
	}
	if i.AppIDLT != nil {
		predicates = append(predicates, decisiondef.AppIDLT(*i.AppIDLT))
	}
	if i.AppIDLTE != nil {
		predicates = append(predicates, decisiondef.AppIDLTE(*i.AppIDLTE))
	}
	if i.ReqDefID != nil {
		predicates = append(predicates, decisiondef.ReqDefIDEQ(*i.ReqDefID))
	}
	if i.ReqDefIDNEQ != nil {
		predicates = append(predicates, decisiondef.ReqDefIDNEQ(*i.ReqDefIDNEQ))
	}
	if len(i.ReqDefIDIn) > 0 {
		predicates = append(predicates, decisiondef.ReqDefIDIn(i.ReqDefIDIn...))
	}
	if len(i.ReqDefIDNotIn) > 0 {
		predicates = append(predicates, decisiondef.ReqDefIDNotIn(i.ReqDefIDNotIn...))
	}
	if i.Category != nil {
		predicates = append(predicates, decisiondef.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, decisiondef.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, decisiondef.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, decisiondef.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, decisiondef.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, decisiondef.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, decisiondef.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, decisiondef.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, decisiondef.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, decisiondef.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, decisiondef.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, decisiondef.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, decisiondef.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, decisiondef.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, decisiondef.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, decisiondef.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, decisiondef.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, decisiondef.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, decisiondef.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, decisiondef.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, decisiondef.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, decisiondef.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, decisiondef.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, decisiondef.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, decisiondef.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, decisiondef.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, decisiondef.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, decisiondef.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, decisiondef.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, decisiondef.NameContainsFold(*i.NameContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, decisiondef.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, decisiondef.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, decisiondef.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, decisiondef.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, decisiondef.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, decisiondef.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, decisiondef.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, decisiondef.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, decisiondef.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, decisiondef.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, decisiondef.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, decisiondef.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, decisiondef.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.ReqDefKey != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyEQ(*i.ReqDefKey))
	}
	if i.ReqDefKeyNEQ != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyNEQ(*i.ReqDefKeyNEQ))
	}
	if len(i.ReqDefKeyIn) > 0 {
		predicates = append(predicates, decisiondef.ReqDefKeyIn(i.ReqDefKeyIn...))
	}
	if len(i.ReqDefKeyNotIn) > 0 {
		predicates = append(predicates, decisiondef.ReqDefKeyNotIn(i.ReqDefKeyNotIn...))
	}
	if i.ReqDefKeyGT != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyGT(*i.ReqDefKeyGT))
	}
	if i.ReqDefKeyGTE != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyGTE(*i.ReqDefKeyGTE))
	}
	if i.ReqDefKeyLT != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyLT(*i.ReqDefKeyLT))
	}
	if i.ReqDefKeyLTE != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyLTE(*i.ReqDefKeyLTE))
	}
	if i.ReqDefKeyContains != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyContains(*i.ReqDefKeyContains))
	}
	if i.ReqDefKeyHasPrefix != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyHasPrefix(*i.ReqDefKeyHasPrefix))
	}
	if i.ReqDefKeyHasSuffix != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyHasSuffix(*i.ReqDefKeyHasSuffix))
	}
	if i.ReqDefKeyEqualFold != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyEqualFold(*i.ReqDefKeyEqualFold))
	}
	if i.ReqDefKeyContainsFold != nil {
		predicates = append(predicates, decisiondef.ReqDefKeyContainsFold(*i.ReqDefKeyContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, decisiondef.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, decisiondef.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, decisiondef.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, decisiondef.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, decisiondef.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, decisiondef.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, decisiondef.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, decisiondef.VersionLTE(*i.VersionLTE))
	}
	if i.Revision != nil {
		predicates = append(predicates, decisiondef.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, decisiondef.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, decisiondef.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, decisiondef.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, decisiondef.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, decisiondef.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, decisiondef.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, decisiondef.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, decisiondef.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, decisiondef.RevisionNotNil())
	}
	if i.VersionTag != nil {
		predicates = append(predicates, decisiondef.VersionTagEQ(*i.VersionTag))
	}
	if i.VersionTagNEQ != nil {
		predicates = append(predicates, decisiondef.VersionTagNEQ(*i.VersionTagNEQ))
	}
	if len(i.VersionTagIn) > 0 {
		predicates = append(predicates, decisiondef.VersionTagIn(i.VersionTagIn...))
	}
	if len(i.VersionTagNotIn) > 0 {
		predicates = append(predicates, decisiondef.VersionTagNotIn(i.VersionTagNotIn...))
	}
	if i.VersionTagGT != nil {
		predicates = append(predicates, decisiondef.VersionTagGT(*i.VersionTagGT))
	}
	if i.VersionTagGTE != nil {
		predicates = append(predicates, decisiondef.VersionTagGTE(*i.VersionTagGTE))
	}
	if i.VersionTagLT != nil {
		predicates = append(predicates, decisiondef.VersionTagLT(*i.VersionTagLT))
	}
	if i.VersionTagLTE != nil {
		predicates = append(predicates, decisiondef.VersionTagLTE(*i.VersionTagLTE))
	}
	if i.VersionTagContains != nil {
		predicates = append(predicates, decisiondef.VersionTagContains(*i.VersionTagContains))
	}
	if i.VersionTagHasPrefix != nil {
		predicates = append(predicates, decisiondef.VersionTagHasPrefix(*i.VersionTagHasPrefix))
	}
	if i.VersionTagHasSuffix != nil {
		predicates = append(predicates, decisiondef.VersionTagHasSuffix(*i.VersionTagHasSuffix))
	}
	if i.VersionTagIsNil {
		predicates = append(predicates, decisiondef.VersionTagIsNil())
	}
	if i.VersionTagNotNil {
		predicates = append(predicates, decisiondef.VersionTagNotNil())
	}
	if i.VersionTagEqualFold != nil {
		predicates = append(predicates, decisiondef.VersionTagEqualFold(*i.VersionTagEqualFold))
	}
	if i.VersionTagContainsFold != nil {
		predicates = append(predicates, decisiondef.VersionTagContainsFold(*i.VersionTagContainsFold))
	}

	if i.HasReqDef != nil {
		p := decisiondef.HasReqDef()
		if !*i.HasReqDef {
			p = decisiondef.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReqDefWith) > 0 {
		with := make([]predicate.DecisionReqDef, 0, len(i.HasReqDefWith))
		for _, w := range i.HasReqDefWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReqDefWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, decisiondef.HasReqDefWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDecisionDefWhereInput
	case 1:
		return predicates[0], nil
	default:
		return decisiondef.And(predicates...), nil
	}
}

// DecisionReqDefWhereInput represents a where input for filtering DecisionReqDef queries.
type DecisionReqDefWhereInput struct {
	Predicates []predicate.DecisionReqDef  `json:"-"`
	Not        *DecisionReqDefWhereInput   `json:"not,omitempty"`
	Or         []*DecisionReqDefWhereInput `json:"or,omitempty"`
	And        []*DecisionReqDefWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "deployment_id" field predicates.
	DeploymentID      *int  `json:"deploymentID,omitempty"`
	DeploymentIDNEQ   *int  `json:"deploymentIDNEQ,omitempty"`
	DeploymentIDIn    []int `json:"deploymentIDIn,omitempty"`
	DeploymentIDNotIn []int `json:"deploymentIDNotIn,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`
	AppIDGT    *int  `json:"appIDGT,omitempty"`
	AppIDGTE   *int  `json:"appIDGTE,omitempty"`
	AppIDLT    *int  `json:"appIDLT,omitempty"`
	AppIDLTE   *int  `json:"appIDLTE,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "version" field predicates.
	Version      *int32  `json:"version,omitempty"`
	VersionNEQ   *int32  `json:"versionNEQ,omitempty"`
	VersionIn    []int32 `json:"versionIn,omitempty"`
	VersionNotIn []int32 `json:"versionNotIn,omitempty"`
	VersionGT    *int32  `json:"versionGT,omitempty"`
	VersionGTE   *int32  `json:"versionGTE,omitempty"`
	VersionLT    *int32  `json:"versionLT,omitempty"`
	VersionLTE   *int32  `json:"versionLTE,omitempty"`

	// "revision" field predicates.
	Revision       *int32  `json:"revision,omitempty"`
	RevisionNEQ    *int32  `json:"revisionNEQ,omitempty"`
	RevisionIn     []int32 `json:"revisionIn,omitempty"`
	RevisionNotIn  []int32 `json:"revisionNotIn,omitempty"`
	RevisionGT     *int32  `json:"revisionGT,omitempty"`
	RevisionGTE    *int32  `json:"revisionGTE,omitempty"`
	RevisionLT     *int32  `json:"revisionLT,omitempty"`
	RevisionLTE    *int32  `json:"revisionLTE,omitempty"`
	RevisionIsNil  bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil bool    `json:"revisionNotNil,omitempty"`

	// "deployment" edge predicates.
	HasDeployment     *bool                   `json:"hasDeployment,omitempty"`
	HasDeploymentWith []*DeploymentWhereInput `json:"hasDeploymentWith,omitempty"`

	// "decision_defs" edge predicates.
	HasDecisionDefs     *bool                    `json:"hasDecisionDefs,omitempty"`
	HasDecisionDefsWith []*DecisionDefWhereInput `json:"hasDecisionDefsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DecisionReqDefWhereInput) AddPredicates(predicates ...predicate.DecisionReqDef) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DecisionReqDefWhereInput filter on the DecisionReqDefQuery builder.
func (i *DecisionReqDefWhereInput) Filter(q *DecisionReqDefQuery) (*DecisionReqDefQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDecisionReqDefWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDecisionReqDefWhereInput is returned in case the DecisionReqDefWhereInput is empty.
var ErrEmptyDecisionReqDefWhereInput = errors.New("ent: empty predicate DecisionReqDefWhereInput")

// P returns a predicate for filtering decisionreqdefs.
// An error is returned if the input is empty or invalid.
func (i *DecisionReqDefWhereInput) P() (predicate.DecisionReqDef, error) {
	var predicates []predicate.DecisionReqDef
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, decisionreqdef.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DecisionReqDef, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, decisionreqdef.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DecisionReqDef, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, decisionreqdef.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, decisionreqdef.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, decisionreqdef.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, decisionreqdef.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, decisionreqdef.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, decisionreqdef.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, decisionreqdef.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, decisionreqdef.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, decisionreqdef.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, decisionreqdef.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, decisionreqdef.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, decisionreqdef.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, decisionreqdef.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, decisionreqdef.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, decisionreqdef.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, decisionreqdef.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, decisionreqdef.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, decisionreqdef.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, decisionreqdef.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, decisionreqdef.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, decisionreqdef.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, decisionreqdef.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, decisionreqdef.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, decisionreqdef.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, decisionreqdef.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, decisionreqdef.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, decisionreqdef.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, decisionreqdef.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, decisionreqdef.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, decisionreqdef.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, decisionreqdef.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, decisionreqdef.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, decisionreqdef.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, decisionreqdef.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, decisionreqdef.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, decisionreqdef.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, decisionreqdef.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, decisionreqdef.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, decisionreqdef.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, decisionreqdef.UpdatedAtNotNil())
	}
	if i.TenantID != nil {
		predicates = append(predicates, decisionreqdef.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, decisionreqdef.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, decisionreqdef.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, decisionreqdef.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, decisionreqdef.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, decisionreqdef.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, decisionreqdef.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.DeploymentID != nil {
		predicates = append(predicates, decisionreqdef.DeploymentIDEQ(*i.DeploymentID))
	}
	if i.DeploymentIDNEQ != nil {
		predicates = append(predicates, decisionreqdef.DeploymentIDNEQ(*i.DeploymentIDNEQ))
	}
	if len(i.DeploymentIDIn) > 0 {
		predicates = append(predicates, decisionreqdef.DeploymentIDIn(i.DeploymentIDIn...))
	}
	if len(i.DeploymentIDNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.DeploymentIDNotIn(i.DeploymentIDNotIn...))
	}
	if i.AppID != nil {
		predicates = append(predicates, decisionreqdef.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, decisionreqdef.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, decisionreqdef.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.AppIDGT != nil {
		predicates = append(predicates, decisionreqdef.AppIDGT(*i.AppIDGT))
	}
	if i.AppIDGTE != nil {
		predicates = append(predicates, decisionreqdef.AppIDGTE(*i.AppIDGTE))
	}
	if i.AppIDLT != nil {
		predicates = append(predicates, decisionreqdef.AppIDLT(*i.AppIDLT))
	}
	if i.AppIDLTE != nil {
		predicates = append(predicates, decisionreqdef.AppIDLTE(*i.AppIDLTE))
	}
	if i.Category != nil {
		predicates = append(predicates, decisionreqdef.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, decisionreqdef.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, decisionreqdef.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, decisionreqdef.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, decisionreqdef.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, decisionreqdef.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, decisionreqdef.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, decisionreqdef.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, decisionreqdef.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, decisionreqdef.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, decisionreqdef.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, decisionreqdef.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, decisionreqdef.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, decisionreqdef.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, decisionreqdef.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, decisionreqdef.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, decisionreqdef.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, decisionreqdef.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, decisionreqdef.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, decisionreqdef.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, decisionreqdef.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, decisionreqdef.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, decisionreqdef.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, decisionreqdef.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, decisionreqdef.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, decisionreqdef.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, decisionreqdef.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, decisionreqdef.NameContainsFold(*i.NameContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, decisionreqdef.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, decisionreqdef.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, decisionreqdef.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, decisionreqdef.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, decisionreqdef.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, decisionreqdef.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, decisionreqdef.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, decisionreqdef.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, decisionreqdef.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, decisionreqdef.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, decisionreqdef.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, decisionreqdef.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, decisionreqdef.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, decisionreqdef.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, decisionreqdef.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, decisionreqdef.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, decisionreqdef.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, decisionreqdef.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, decisionreqdef.VersionLTE(*i.VersionLTE))
	}
	if i.Revision != nil {
		predicates = append(predicates, decisionreqdef.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, decisionreqdef.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, decisionreqdef.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, decisionreqdef.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, decisionreqdef.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, decisionreqdef.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, decisionreqdef.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, decisionreqdef.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, decisionreqdef.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, decisionreqdef.RevisionNotNil())
	}

	if i.HasDeployment != nil {
		p := decisionreqdef.HasDeployment()
		if !*i.HasDeployment {
			p = decisionreqdef.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeploymentWith) > 0 {
		with := make([]predicate.Deployment, 0, len(i.HasDeploymentWith))
		for _, w := range i.HasDeploymentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeploymentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, decisionreqdef.HasDeploymentWith(with...))
	}
	if i.HasDecisionDefs != nil {
		p := decisionreqdef.HasDecisionDefs()
		if !*i.HasDecisionDefs {
			p = decisionreqdef.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDecisionDefsWith) > 0 {
		with := make([]predicate.DecisionDef, 0, len(i.HasDecisionDefsWith))
		for _, w := range i.HasDecisionDefsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDecisionDefsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, decisionreqdef.HasDecisionDefsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDecisionReqDefWhereInput
	case 1:
		return predicates[0], nil
	default:
		return decisionreqdef.And(predicates...), nil
	}
}

// DeploymentWhereInput represents a where input for filtering Deployment queries.
type DeploymentWhereInput struct {
	Predicates []predicate.Deployment  `json:"-"`
	Not        *DeploymentWhereInput   `json:"not,omitempty"`
	Or         []*DeploymentWhereInput `json:"or,omitempty"`
	And        []*DeploymentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`
	AppIDGT    *int  `json:"appIDGT,omitempty"`
	AppIDGTE   *int  `json:"appIDGTE,omitempty"`
	AppIDLT    *int  `json:"appIDLT,omitempty"`
	AppIDLTE   *int  `json:"appIDLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "source" field predicates.
	Source             *string  `json:"source,omitempty"`
	SourceNEQ          *string  `json:"sourceNEQ,omitempty"`
	SourceIn           []string `json:"sourceIn,omitempty"`
	SourceNotIn        []string `json:"sourceNotIn,omitempty"`
	SourceGT           *string  `json:"sourceGT,omitempty"`
	SourceGTE          *string  `json:"sourceGTE,omitempty"`
	SourceLT           *string  `json:"sourceLT,omitempty"`
	SourceLTE          *string  `json:"sourceLTE,omitempty"`
	SourceContains     *string  `json:"sourceContains,omitempty"`
	SourceHasPrefix    *string  `json:"sourceHasPrefix,omitempty"`
	SourceHasSuffix    *string  `json:"sourceHasSuffix,omitempty"`
	SourceIsNil        bool     `json:"sourceIsNil,omitempty"`
	SourceNotNil       bool     `json:"sourceNotNil,omitempty"`
	SourceEqualFold    *string  `json:"sourceEqualFold,omitempty"`
	SourceContainsFold *string  `json:"sourceContainsFold,omitempty"`

	// "deploy_time" field predicates.
	DeployTime      *time.Time  `json:"deployTime,omitempty"`
	DeployTimeNEQ   *time.Time  `json:"deployTimeNEQ,omitempty"`
	DeployTimeIn    []time.Time `json:"deployTimeIn,omitempty"`
	DeployTimeNotIn []time.Time `json:"deployTimeNotIn,omitempty"`
	DeployTimeGT    *time.Time  `json:"deployTimeGT,omitempty"`
	DeployTimeGTE   *time.Time  `json:"deployTimeGTE,omitempty"`
	DeployTimeLT    *time.Time  `json:"deployTimeLT,omitempty"`
	DeployTimeLTE   *time.Time  `json:"deployTimeLTE,omitempty"`

	// "proc_defs" edge predicates.
	HasProcDefs     *bool                `json:"hasProcDefs,omitempty"`
	HasProcDefsWith []*ProcDefWhereInput `json:"hasProcDefsWith,omitempty"`

	// "decision_reqs" edge predicates.
	HasDecisionReqs     *bool                       `json:"hasDecisionReqs,omitempty"`
	HasDecisionReqsWith []*DecisionReqDefWhereInput `json:"hasDecisionReqsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeploymentWhereInput) AddPredicates(predicates ...predicate.Deployment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeploymentWhereInput filter on the DeploymentQuery builder.
func (i *DeploymentWhereInput) Filter(q *DeploymentQuery) (*DeploymentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeploymentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeploymentWhereInput is returned in case the DeploymentWhereInput is empty.
var ErrEmptyDeploymentWhereInput = errors.New("ent: empty predicate DeploymentWhereInput")

// P returns a predicate for filtering deployments.
// An error is returned if the input is empty or invalid.
func (i *DeploymentWhereInput) P() (predicate.Deployment, error) {
	var predicates []predicate.Deployment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deployment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Deployment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deployment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Deployment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deployment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deployment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deployment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deployment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deployment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deployment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deployment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deployment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deployment.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, deployment.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, deployment.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, deployment.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, deployment.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, deployment.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, deployment.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, deployment.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, deployment.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, deployment.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, deployment.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, deployment.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, deployment.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, deployment.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, deployment.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, deployment.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, deployment.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, deployment.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, deployment.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, deployment.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, deployment.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, deployment.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, deployment.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, deployment.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, deployment.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, deployment.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, deployment.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, deployment.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, deployment.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, deployment.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, deployment.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, deployment.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, deployment.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, deployment.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, deployment.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, deployment.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, deployment.UpdatedAtNotNil())
	}
	if i.TenantID != nil {
		predicates = append(predicates, deployment.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deployment.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deployment.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deployment.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deployment.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deployment.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deployment.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deployment.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.AppID != nil {
		predicates = append(predicates, deployment.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, deployment.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, deployment.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, deployment.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.AppIDGT != nil {
		predicates = append(predicates, deployment.AppIDGT(*i.AppIDGT))
	}
	if i.AppIDGTE != nil {
		predicates = append(predicates, deployment.AppIDGTE(*i.AppIDGTE))
	}
	if i.AppIDLT != nil {
		predicates = append(predicates, deployment.AppIDLT(*i.AppIDLT))
	}
	if i.AppIDLTE != nil {
		predicates = append(predicates, deployment.AppIDLTE(*i.AppIDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, deployment.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, deployment.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, deployment.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, deployment.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, deployment.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, deployment.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, deployment.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, deployment.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, deployment.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, deployment.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, deployment.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, deployment.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, deployment.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, deployment.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, deployment.NameContainsFold(*i.NameContainsFold))
	}
	if i.Source != nil {
		predicates = append(predicates, deployment.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, deployment.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, deployment.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, deployment.SourceNotIn(i.SourceNotIn...))
	}
	if i.SourceGT != nil {
		predicates = append(predicates, deployment.SourceGT(*i.SourceGT))
	}
	if i.SourceGTE != nil {
		predicates = append(predicates, deployment.SourceGTE(*i.SourceGTE))
	}
	if i.SourceLT != nil {
		predicates = append(predicates, deployment.SourceLT(*i.SourceLT))
	}
	if i.SourceLTE != nil {
		predicates = append(predicates, deployment.SourceLTE(*i.SourceLTE))
	}
	if i.SourceContains != nil {
		predicates = append(predicates, deployment.SourceContains(*i.SourceContains))
	}
	if i.SourceHasPrefix != nil {
		predicates = append(predicates, deployment.SourceHasPrefix(*i.SourceHasPrefix))
	}
	if i.SourceHasSuffix != nil {
		predicates = append(predicates, deployment.SourceHasSuffix(*i.SourceHasSuffix))
	}
	if i.SourceIsNil {
		predicates = append(predicates, deployment.SourceIsNil())
	}
	if i.SourceNotNil {
		predicates = append(predicates, deployment.SourceNotNil())
	}
	if i.SourceEqualFold != nil {
		predicates = append(predicates, deployment.SourceEqualFold(*i.SourceEqualFold))
	}
	if i.SourceContainsFold != nil {
		predicates = append(predicates, deployment.SourceContainsFold(*i.SourceContainsFold))
	}
	if i.DeployTime != nil {
		predicates = append(predicates, deployment.DeployTimeEQ(*i.DeployTime))
	}
	if i.DeployTimeNEQ != nil {
		predicates = append(predicates, deployment.DeployTimeNEQ(*i.DeployTimeNEQ))
	}
	if len(i.DeployTimeIn) > 0 {
		predicates = append(predicates, deployment.DeployTimeIn(i.DeployTimeIn...))
	}
	if len(i.DeployTimeNotIn) > 0 {
		predicates = append(predicates, deployment.DeployTimeNotIn(i.DeployTimeNotIn...))
	}
	if i.DeployTimeGT != nil {
		predicates = append(predicates, deployment.DeployTimeGT(*i.DeployTimeGT))
	}
	if i.DeployTimeGTE != nil {
		predicates = append(predicates, deployment.DeployTimeGTE(*i.DeployTimeGTE))
	}
	if i.DeployTimeLT != nil {
		predicates = append(predicates, deployment.DeployTimeLT(*i.DeployTimeLT))
	}
	if i.DeployTimeLTE != nil {
		predicates = append(predicates, deployment.DeployTimeLTE(*i.DeployTimeLTE))
	}

	if i.HasProcDefs != nil {
		p := deployment.HasProcDefs()
		if !*i.HasProcDefs {
			p = deployment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcDefsWith) > 0 {
		with := make([]predicate.ProcDef, 0, len(i.HasProcDefsWith))
		for _, w := range i.HasProcDefsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcDefsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deployment.HasProcDefsWith(with...))
	}
	if i.HasDecisionReqs != nil {
		p := deployment.HasDecisionReqs()
		if !*i.HasDecisionReqs {
			p = deployment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDecisionReqsWith) > 0 {
		with := make([]predicate.DecisionReqDef, 0, len(i.HasDecisionReqsWith))
		for _, w := range i.HasDecisionReqsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDecisionReqsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deployment.HasDecisionReqsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeploymentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deployment.And(predicates...), nil
	}
}

// IdentityLinkWhereInput represents a where input for filtering IdentityLink queries.
type IdentityLinkWhereInput struct {
	Predicates []predicate.IdentityLink  `json:"-"`
	Not        *IdentityLinkWhereInput   `json:"not,omitempty"`
	Or         []*IdentityLinkWhereInput `json:"or,omitempty"`
	And        []*IdentityLinkWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "task_id" field predicates.
	TaskID      *int  `json:"taskID,omitempty"`
	TaskIDNEQ   *int  `json:"taskIDNEQ,omitempty"`
	TaskIDIn    []int `json:"taskIDIn,omitempty"`
	TaskIDNotIn []int `json:"taskIDNotIn,omitempty"`

	// "proc_def_id" field predicates.
	ProcDefID      *int  `json:"procDefID,omitempty"`
	ProcDefIDNEQ   *int  `json:"procDefIDNEQ,omitempty"`
	ProcDefIDIn    []int `json:"procDefIDIn,omitempty"`
	ProcDefIDNotIn []int `json:"procDefIDNotIn,omitempty"`
	ProcDefIDGT    *int  `json:"procDefIDGT,omitempty"`
	ProcDefIDGTE   *int  `json:"procDefIDGTE,omitempty"`
	ProcDefIDLT    *int  `json:"procDefIDLT,omitempty"`
	ProcDefIDLTE   *int  `json:"procDefIDLTE,omitempty"`

	// "group_id" field predicates.
	GroupID       *int  `json:"groupID,omitempty"`
	GroupIDNEQ    *int  `json:"groupIDNEQ,omitempty"`
	GroupIDIn     []int `json:"groupIDIn,omitempty"`
	GroupIDNotIn  []int `json:"groupIDNotIn,omitempty"`
	GroupIDGT     *int  `json:"groupIDGT,omitempty"`
	GroupIDGTE    *int  `json:"groupIDGTE,omitempty"`
	GroupIDLT     *int  `json:"groupIDLT,omitempty"`
	GroupIDLTE    *int  `json:"groupIDLTE,omitempty"`
	GroupIDIsNil  bool  `json:"groupIDIsNil,omitempty"`
	GroupIDNotNil bool  `json:"groupIDNotNil,omitempty"`

	// "user_id" field predicates.
	UserID       *int  `json:"userID,omitempty"`
	UserIDNEQ    *int  `json:"userIDNEQ,omitempty"`
	UserIDIn     []int `json:"userIDIn,omitempty"`
	UserIDNotIn  []int `json:"userIDNotIn,omitempty"`
	UserIDGT     *int  `json:"userIDGT,omitempty"`
	UserIDGTE    *int  `json:"userIDGTE,omitempty"`
	UserIDLT     *int  `json:"userIDLT,omitempty"`
	UserIDLTE    *int  `json:"userIDLTE,omitempty"`
	UserIDIsNil  bool  `json:"userIDIsNil,omitempty"`
	UserIDNotNil bool  `json:"userIDNotNil,omitempty"`

	// "assigner_id" field predicates.
	AssignerID       *int  `json:"assignerID,omitempty"`
	AssignerIDNEQ    *int  `json:"assignerIDNEQ,omitempty"`
	AssignerIDIn     []int `json:"assignerIDIn,omitempty"`
	AssignerIDNotIn  []int `json:"assignerIDNotIn,omitempty"`
	AssignerIDGT     *int  `json:"assignerIDGT,omitempty"`
	AssignerIDGTE    *int  `json:"assignerIDGTE,omitempty"`
	AssignerIDLT     *int  `json:"assignerIDLT,omitempty"`
	AssignerIDLTE    *int  `json:"assignerIDLTE,omitempty"`
	AssignerIDIsNil  bool  `json:"assignerIDIsNil,omitempty"`
	AssignerIDNotNil bool  `json:"assignerIDNotNil,omitempty"`

	// "link_type" field predicates.
	LinkType      *identitylink.LinkType  `json:"linkType,omitempty"`
	LinkTypeNEQ   *identitylink.LinkType  `json:"linkTypeNEQ,omitempty"`
	LinkTypeIn    []identitylink.LinkType `json:"linkTypeIn,omitempty"`
	LinkTypeNotIn []identitylink.LinkType `json:"linkTypeNotIn,omitempty"`

	// "operation_type" field predicates.
	OperationType      *identitylink.OperationType  `json:"operationType,omitempty"`
	OperationTypeNEQ   *identitylink.OperationType  `json:"operationTypeNEQ,omitempty"`
	OperationTypeIn    []identitylink.OperationType `json:"operationTypeIn,omitempty"`
	OperationTypeNotIn []identitylink.OperationType `json:"operationTypeNotIn,omitempty"`

	// "task" edge predicates.
	HasTask     *bool             `json:"hasTask,omitempty"`
	HasTaskWith []*TaskWhereInput `json:"hasTaskWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *IdentityLinkWhereInput) AddPredicates(predicates ...predicate.IdentityLink) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the IdentityLinkWhereInput filter on the IdentityLinkQuery builder.
func (i *IdentityLinkWhereInput) Filter(q *IdentityLinkQuery) (*IdentityLinkQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyIdentityLinkWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyIdentityLinkWhereInput is returned in case the IdentityLinkWhereInput is empty.
var ErrEmptyIdentityLinkWhereInput = errors.New("ent: empty predicate IdentityLinkWhereInput")

// P returns a predicate for filtering identitylinks.
// An error is returned if the input is empty or invalid.
func (i *IdentityLinkWhereInput) P() (predicate.IdentityLink, error) {
	var predicates []predicate.IdentityLink
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, identitylink.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.IdentityLink, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, identitylink.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.IdentityLink, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, identitylink.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, identitylink.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, identitylink.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, identitylink.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, identitylink.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, identitylink.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, identitylink.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, identitylink.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, identitylink.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, identitylink.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, identitylink.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, identitylink.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, identitylink.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, identitylink.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, identitylink.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, identitylink.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, identitylink.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TaskID != nil {
		predicates = append(predicates, identitylink.TaskIDEQ(*i.TaskID))
	}
	if i.TaskIDNEQ != nil {
		predicates = append(predicates, identitylink.TaskIDNEQ(*i.TaskIDNEQ))
	}
	if len(i.TaskIDIn) > 0 {
		predicates = append(predicates, identitylink.TaskIDIn(i.TaskIDIn...))
	}
	if len(i.TaskIDNotIn) > 0 {
		predicates = append(predicates, identitylink.TaskIDNotIn(i.TaskIDNotIn...))
	}
	if i.ProcDefID != nil {
		predicates = append(predicates, identitylink.ProcDefIDEQ(*i.ProcDefID))
	}
	if i.ProcDefIDNEQ != nil {
		predicates = append(predicates, identitylink.ProcDefIDNEQ(*i.ProcDefIDNEQ))
	}
	if len(i.ProcDefIDIn) > 0 {
		predicates = append(predicates, identitylink.ProcDefIDIn(i.ProcDefIDIn...))
	}
	if len(i.ProcDefIDNotIn) > 0 {
		predicates = append(predicates, identitylink.ProcDefIDNotIn(i.ProcDefIDNotIn...))
	}
	if i.ProcDefIDGT != nil {
		predicates = append(predicates, identitylink.ProcDefIDGT(*i.ProcDefIDGT))
	}
	if i.ProcDefIDGTE != nil {
		predicates = append(predicates, identitylink.ProcDefIDGTE(*i.ProcDefIDGTE))
	}
	if i.ProcDefIDLT != nil {
		predicates = append(predicates, identitylink.ProcDefIDLT(*i.ProcDefIDLT))
	}
	if i.ProcDefIDLTE != nil {
		predicates = append(predicates, identitylink.ProcDefIDLTE(*i.ProcDefIDLTE))
	}
	if i.GroupID != nil {
		predicates = append(predicates, identitylink.GroupIDEQ(*i.GroupID))
	}
	if i.GroupIDNEQ != nil {
		predicates = append(predicates, identitylink.GroupIDNEQ(*i.GroupIDNEQ))
	}
	if len(i.GroupIDIn) > 0 {
		predicates = append(predicates, identitylink.GroupIDIn(i.GroupIDIn...))
	}
	if len(i.GroupIDNotIn) > 0 {
		predicates = append(predicates, identitylink.GroupIDNotIn(i.GroupIDNotIn...))
	}
	if i.GroupIDGT != nil {
		predicates = append(predicates, identitylink.GroupIDGT(*i.GroupIDGT))
	}
	if i.GroupIDGTE != nil {
		predicates = append(predicates, identitylink.GroupIDGTE(*i.GroupIDGTE))
	}
	if i.GroupIDLT != nil {
		predicates = append(predicates, identitylink.GroupIDLT(*i.GroupIDLT))
	}
	if i.GroupIDLTE != nil {
		predicates = append(predicates, identitylink.GroupIDLTE(*i.GroupIDLTE))
	}
	if i.GroupIDIsNil {
		predicates = append(predicates, identitylink.GroupIDIsNil())
	}
	if i.GroupIDNotNil {
		predicates = append(predicates, identitylink.GroupIDNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, identitylink.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, identitylink.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, identitylink.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, identitylink.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, identitylink.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, identitylink.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, identitylink.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, identitylink.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, identitylink.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, identitylink.UserIDNotNil())
	}
	if i.AssignerID != nil {
		predicates = append(predicates, identitylink.AssignerIDEQ(*i.AssignerID))
	}
	if i.AssignerIDNEQ != nil {
		predicates = append(predicates, identitylink.AssignerIDNEQ(*i.AssignerIDNEQ))
	}
	if len(i.AssignerIDIn) > 0 {
		predicates = append(predicates, identitylink.AssignerIDIn(i.AssignerIDIn...))
	}
	if len(i.AssignerIDNotIn) > 0 {
		predicates = append(predicates, identitylink.AssignerIDNotIn(i.AssignerIDNotIn...))
	}
	if i.AssignerIDGT != nil {
		predicates = append(predicates, identitylink.AssignerIDGT(*i.AssignerIDGT))
	}
	if i.AssignerIDGTE != nil {
		predicates = append(predicates, identitylink.AssignerIDGTE(*i.AssignerIDGTE))
	}
	if i.AssignerIDLT != nil {
		predicates = append(predicates, identitylink.AssignerIDLT(*i.AssignerIDLT))
	}
	if i.AssignerIDLTE != nil {
		predicates = append(predicates, identitylink.AssignerIDLTE(*i.AssignerIDLTE))
	}
	if i.AssignerIDIsNil {
		predicates = append(predicates, identitylink.AssignerIDIsNil())
	}
	if i.AssignerIDNotNil {
		predicates = append(predicates, identitylink.AssignerIDNotNil())
	}
	if i.LinkType != nil {
		predicates = append(predicates, identitylink.LinkTypeEQ(*i.LinkType))
	}
	if i.LinkTypeNEQ != nil {
		predicates = append(predicates, identitylink.LinkTypeNEQ(*i.LinkTypeNEQ))
	}
	if len(i.LinkTypeIn) > 0 {
		predicates = append(predicates, identitylink.LinkTypeIn(i.LinkTypeIn...))
	}
	if len(i.LinkTypeNotIn) > 0 {
		predicates = append(predicates, identitylink.LinkTypeNotIn(i.LinkTypeNotIn...))
	}
	if i.OperationType != nil {
		predicates = append(predicates, identitylink.OperationTypeEQ(*i.OperationType))
	}
	if i.OperationTypeNEQ != nil {
		predicates = append(predicates, identitylink.OperationTypeNEQ(*i.OperationTypeNEQ))
	}
	if len(i.OperationTypeIn) > 0 {
		predicates = append(predicates, identitylink.OperationTypeIn(i.OperationTypeIn...))
	}
	if len(i.OperationTypeNotIn) > 0 {
		predicates = append(predicates, identitylink.OperationTypeNotIn(i.OperationTypeNotIn...))
	}

	if i.HasTask != nil {
		p := identitylink.HasTask()
		if !*i.HasTask {
			p = identitylink.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTaskWith))
		for _, w := range i.HasTaskWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, identitylink.HasTaskWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyIdentityLinkWhereInput
	case 1:
		return predicates[0], nil
	default:
		return identitylink.And(predicates...), nil
	}
}

// OrgRoleWhereInput represents a where input for filtering OrgRole queries.
type OrgRoleWhereInput struct {
	Predicates []predicate.OrgRole  `json:"-"`
	Not        *OrgRoleWhereInput   `json:"not,omitempty"`
	Or         []*OrgRoleWhereInput `json:"or,omitempty"`
	And        []*OrgRoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "org_id" field predicates.
	OrgID       *int  `json:"orgID,omitempty"`
	OrgIDNEQ    *int  `json:"orgIDNEQ,omitempty"`
	OrgIDIn     []int `json:"orgIDIn,omitempty"`
	OrgIDNotIn  []int `json:"orgIDNotIn,omitempty"`
	OrgIDGT     *int  `json:"orgIDGT,omitempty"`
	OrgIDGTE    *int  `json:"orgIDGTE,omitempty"`
	OrgIDLT     *int  `json:"orgIDLT,omitempty"`
	OrgIDLTE    *int  `json:"orgIDLTE,omitempty"`
	OrgIDIsNil  bool  `json:"orgIDIsNil,omitempty"`
	OrgIDNotNil bool  `json:"orgIDNotNil,omitempty"`

	// "kind" field predicates.
	Kind      *orgrole.Kind  `json:"kind,omitempty"`
	KindNEQ   *orgrole.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []orgrole.Kind `json:"kindIn,omitempty"`
	KindNotIn []orgrole.Kind `json:"kindNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgRoleWhereInput) AddPredicates(predicates ...predicate.OrgRole) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgRoleWhereInput filter on the OrgRoleQuery builder.
func (i *OrgRoleWhereInput) Filter(q *OrgRoleQuery) (*OrgRoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgRoleWhereInput is returned in case the OrgRoleWhereInput is empty.
var ErrEmptyOrgRoleWhereInput = errors.New("ent: empty predicate OrgRoleWhereInput")

// P returns a predicate for filtering orgroles.
// An error is returned if the input is empty or invalid.
func (i *OrgRoleWhereInput) P() (predicate.OrgRole, error) {
	var predicates []predicate.OrgRole
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orgrole.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgRole, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orgrole.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgRole, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orgrole.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orgrole.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orgrole.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orgrole.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orgrole.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orgrole.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orgrole.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orgrole.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orgrole.IDLTE(*i.IDLTE))
	}
	if i.OrgID != nil {
		predicates = append(predicates, orgrole.OrgIDEQ(*i.OrgID))
	}
	if i.OrgIDNEQ != nil {
		predicates = append(predicates, orgrole.OrgIDNEQ(*i.OrgIDNEQ))
	}
	if len(i.OrgIDIn) > 0 {
		predicates = append(predicates, orgrole.OrgIDIn(i.OrgIDIn...))
	}
	if len(i.OrgIDNotIn) > 0 {
		predicates = append(predicates, orgrole.OrgIDNotIn(i.OrgIDNotIn...))
	}
	if i.OrgIDGT != nil {
		predicates = append(predicates, orgrole.OrgIDGT(*i.OrgIDGT))
	}
	if i.OrgIDGTE != nil {
		predicates = append(predicates, orgrole.OrgIDGTE(*i.OrgIDGTE))
	}
	if i.OrgIDLT != nil {
		predicates = append(predicates, orgrole.OrgIDLT(*i.OrgIDLT))
	}
	if i.OrgIDLTE != nil {
		predicates = append(predicates, orgrole.OrgIDLTE(*i.OrgIDLTE))
	}
	if i.OrgIDIsNil {
		predicates = append(predicates, orgrole.OrgIDIsNil())
	}
	if i.OrgIDNotNil {
		predicates = append(predicates, orgrole.OrgIDNotNil())
	}
	if i.Kind != nil {
		predicates = append(predicates, orgrole.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, orgrole.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, orgrole.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, orgrole.KindNotIn(i.KindNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, orgrole.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, orgrole.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, orgrole.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, orgrole.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, orgrole.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, orgrole.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, orgrole.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, orgrole.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, orgrole.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, orgrole.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, orgrole.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, orgrole.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, orgrole.NameContainsFold(*i.NameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orgrole.And(predicates...), nil
	}
}

// OrgUserWhereInput represents a where input for filtering OrgUser queries.
type OrgUserWhereInput struct {
	Predicates []predicate.OrgUser  `json:"-"`
	Not        *OrgUserWhereInput   `json:"not,omitempty"`
	Or         []*OrgUserWhereInput `json:"or,omitempty"`
	And        []*OrgUserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "org_id" field predicates.
	OrgID      *int  `json:"orgID,omitempty"`
	OrgIDNEQ   *int  `json:"orgIDNEQ,omitempty"`
	OrgIDIn    []int `json:"orgIDIn,omitempty"`
	OrgIDNotIn []int `json:"orgIDNotIn,omitempty"`
	OrgIDGT    *int  `json:"orgIDGT,omitempty"`
	OrgIDGTE   *int  `json:"orgIDGTE,omitempty"`
	OrgIDLT    *int  `json:"orgIDLT,omitempty"`
	OrgIDLTE   *int  `json:"orgIDLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`
	UserIDGT    *int  `json:"userIDGT,omitempty"`
	UserIDGTE   *int  `json:"userIDGTE,omitempty"`
	UserIDLT    *int  `json:"userIDLT,omitempty"`
	UserIDLTE   *int  `json:"userIDLTE,omitempty"`

	// "joined_at" field predicates.
	JoinedAt      *time.Time  `json:"joinedAt,omitempty"`
	JoinedAtNEQ   *time.Time  `json:"joinedAtNEQ,omitempty"`
	JoinedAtIn    []time.Time `json:"joinedAtIn,omitempty"`
	JoinedAtNotIn []time.Time `json:"joinedAtNotIn,omitempty"`
	JoinedAtGT    *time.Time  `json:"joinedAtGT,omitempty"`
	JoinedAtGTE   *time.Time  `json:"joinedAtGTE,omitempty"`
	JoinedAtLT    *time.Time  `json:"joinedAtLT,omitempty"`
	JoinedAtLTE   *time.Time  `json:"joinedAtLTE,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrgUserWhereInput) AddPredicates(predicates ...predicate.OrgUser) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrgUserWhereInput filter on the OrgUserQuery builder.
func (i *OrgUserWhereInput) Filter(q *OrgUserQuery) (*OrgUserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrgUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrgUserWhereInput is returned in case the OrgUserWhereInput is empty.
var ErrEmptyOrgUserWhereInput = errors.New("ent: empty predicate OrgUserWhereInput")

// P returns a predicate for filtering orgusers.
// An error is returned if the input is empty or invalid.
func (i *OrgUserWhereInput) P() (predicate.OrgUser, error) {
	var predicates []predicate.OrgUser
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orguser.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrgUser, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orguser.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrgUser, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orguser.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orguser.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orguser.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orguser.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orguser.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orguser.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orguser.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orguser.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orguser.IDLTE(*i.IDLTE))
	}
	if i.OrgID != nil {
		predicates = append(predicates, orguser.OrgIDEQ(*i.OrgID))
	}
	if i.OrgIDNEQ != nil {
		predicates = append(predicates, orguser.OrgIDNEQ(*i.OrgIDNEQ))
	}
	if len(i.OrgIDIn) > 0 {
		predicates = append(predicates, orguser.OrgIDIn(i.OrgIDIn...))
	}
	if len(i.OrgIDNotIn) > 0 {
		predicates = append(predicates, orguser.OrgIDNotIn(i.OrgIDNotIn...))
	}
	if i.OrgIDGT != nil {
		predicates = append(predicates, orguser.OrgIDGT(*i.OrgIDGT))
	}
	if i.OrgIDGTE != nil {
		predicates = append(predicates, orguser.OrgIDGTE(*i.OrgIDGTE))
	}
	if i.OrgIDLT != nil {
		predicates = append(predicates, orguser.OrgIDLT(*i.OrgIDLT))
	}
	if i.OrgIDLTE != nil {
		predicates = append(predicates, orguser.OrgIDLTE(*i.OrgIDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, orguser.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, orguser.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, orguser.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, orguser.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, orguser.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, orguser.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, orguser.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, orguser.UserIDLTE(*i.UserIDLTE))
	}
	if i.JoinedAt != nil {
		predicates = append(predicates, orguser.JoinedAtEQ(*i.JoinedAt))
	}
	if i.JoinedAtNEQ != nil {
		predicates = append(predicates, orguser.JoinedAtNEQ(*i.JoinedAtNEQ))
	}
	if len(i.JoinedAtIn) > 0 {
		predicates = append(predicates, orguser.JoinedAtIn(i.JoinedAtIn...))
	}
	if len(i.JoinedAtNotIn) > 0 {
		predicates = append(predicates, orguser.JoinedAtNotIn(i.JoinedAtNotIn...))
	}
	if i.JoinedAtGT != nil {
		predicates = append(predicates, orguser.JoinedAtGT(*i.JoinedAtGT))
	}
	if i.JoinedAtGTE != nil {
		predicates = append(predicates, orguser.JoinedAtGTE(*i.JoinedAtGTE))
	}
	if i.JoinedAtLT != nil {
		predicates = append(predicates, orguser.JoinedAtLT(*i.JoinedAtLT))
	}
	if i.JoinedAtLTE != nil {
		predicates = append(predicates, orguser.JoinedAtLTE(*i.JoinedAtLTE))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, orguser.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, orguser.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, orguser.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, orguser.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, orguser.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, orguser.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, orguser.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, orguser.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, orguser.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, orguser.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, orguser.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, orguser.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, orguser.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrgUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orguser.And(predicates...), nil
	}
}

// ProcDefWhereInput represents a where input for filtering ProcDef queries.
type ProcDefWhereInput struct {
	Predicates []predicate.ProcDef  `json:"-"`
	Not        *ProcDefWhereInput   `json:"not,omitempty"`
	Or         []*ProcDefWhereInput `json:"or,omitempty"`
	And        []*ProcDefWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "deployment_id" field predicates.
	DeploymentID      *int  `json:"deploymentID,omitempty"`
	DeploymentIDNEQ   *int  `json:"deploymentIDNEQ,omitempty"`
	DeploymentIDIn    []int `json:"deploymentIDIn,omitempty"`
	DeploymentIDNotIn []int `json:"deploymentIDNotIn,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`
	AppIDGT    *int  `json:"appIDGT,omitempty"`
	AppIDGTE   *int  `json:"appIDGTE,omitempty"`
	AppIDLT    *int  `json:"appIDLT,omitempty"`
	AppIDLTE   *int  `json:"appIDLTE,omitempty"`

	// "category" field predicates.
	Category             *string  `json:"category,omitempty"`
	CategoryNEQ          *string  `json:"categoryNEQ,omitempty"`
	CategoryIn           []string `json:"categoryIn,omitempty"`
	CategoryNotIn        []string `json:"categoryNotIn,omitempty"`
	CategoryGT           *string  `json:"categoryGT,omitempty"`
	CategoryGTE          *string  `json:"categoryGTE,omitempty"`
	CategoryLT           *string  `json:"categoryLT,omitempty"`
	CategoryLTE          *string  `json:"categoryLTE,omitempty"`
	CategoryContains     *string  `json:"categoryContains,omitempty"`
	CategoryHasPrefix    *string  `json:"categoryHasPrefix,omitempty"`
	CategoryHasSuffix    *string  `json:"categoryHasSuffix,omitempty"`
	CategoryIsNil        bool     `json:"categoryIsNil,omitempty"`
	CategoryNotNil       bool     `json:"categoryNotNil,omitempty"`
	CategoryEqualFold    *string  `json:"categoryEqualFold,omitempty"`
	CategoryContainsFold *string  `json:"categoryContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "version" field predicates.
	Version       *int32  `json:"version,omitempty"`
	VersionNEQ    *int32  `json:"versionNEQ,omitempty"`
	VersionIn     []int32 `json:"versionIn,omitempty"`
	VersionNotIn  []int32 `json:"versionNotIn,omitempty"`
	VersionGT     *int32  `json:"versionGT,omitempty"`
	VersionGTE    *int32  `json:"versionGTE,omitempty"`
	VersionLT     *int32  `json:"versionLT,omitempty"`
	VersionLTE    *int32  `json:"versionLTE,omitempty"`
	VersionIsNil  bool    `json:"versionIsNil,omitempty"`
	VersionNotNil bool    `json:"versionNotNil,omitempty"`

	// "revision" field predicates.
	Revision       *int32  `json:"revision,omitempty"`
	RevisionNEQ    *int32  `json:"revisionNEQ,omitempty"`
	RevisionIn     []int32 `json:"revisionIn,omitempty"`
	RevisionNotIn  []int32 `json:"revisionNotIn,omitempty"`
	RevisionGT     *int32  `json:"revisionGT,omitempty"`
	RevisionGTE    *int32  `json:"revisionGTE,omitempty"`
	RevisionLT     *int32  `json:"revisionLT,omitempty"`
	RevisionLTE    *int32  `json:"revisionLTE,omitempty"`
	RevisionIsNil  bool    `json:"revisionIsNil,omitempty"`
	RevisionNotNil bool    `json:"revisionNotNil,omitempty"`

	// "version_tag" field predicates.
	VersionTag             *string  `json:"versionTag,omitempty"`
	VersionTagNEQ          *string  `json:"versionTagNEQ,omitempty"`
	VersionTagIn           []string `json:"versionTagIn,omitempty"`
	VersionTagNotIn        []string `json:"versionTagNotIn,omitempty"`
	VersionTagGT           *string  `json:"versionTagGT,omitempty"`
	VersionTagGTE          *string  `json:"versionTagGTE,omitempty"`
	VersionTagLT           *string  `json:"versionTagLT,omitempty"`
	VersionTagLTE          *string  `json:"versionTagLTE,omitempty"`
	VersionTagContains     *string  `json:"versionTagContains,omitempty"`
	VersionTagHasPrefix    *string  `json:"versionTagHasPrefix,omitempty"`
	VersionTagHasSuffix    *string  `json:"versionTagHasSuffix,omitempty"`
	VersionTagIsNil        bool     `json:"versionTagIsNil,omitempty"`
	VersionTagNotNil       bool     `json:"versionTagNotNil,omitempty"`
	VersionTagEqualFold    *string  `json:"versionTagEqualFold,omitempty"`
	VersionTagContainsFold *string  `json:"versionTagContainsFold,omitempty"`

	// "status" field predicates.
	Status      *typex.SimpleStatus  `json:"status,omitempty"`
	StatusNEQ   *typex.SimpleStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []typex.SimpleStatus `json:"statusIn,omitempty"`
	StatusNotIn []typex.SimpleStatus `json:"statusNotIn,omitempty"`

	// "deployment" edge predicates.
	HasDeployment     *bool                   `json:"hasDeployment,omitempty"`
	HasDeploymentWith []*DeploymentWhereInput `json:"hasDeploymentWith,omitempty"`

	// "proc_instances" edge predicates.
	HasProcInstances     *bool                 `json:"hasProcInstances,omitempty"`
	HasProcInstancesWith []*ProcInstWhereInput `json:"hasProcInstancesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProcDefWhereInput) AddPredicates(predicates ...predicate.ProcDef) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProcDefWhereInput filter on the ProcDefQuery builder.
func (i *ProcDefWhereInput) Filter(q *ProcDefQuery) (*ProcDefQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProcDefWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProcDefWhereInput is returned in case the ProcDefWhereInput is empty.
var ErrEmptyProcDefWhereInput = errors.New("ent: empty predicate ProcDefWhereInput")

// P returns a predicate for filtering procdefs.
// An error is returned if the input is empty or invalid.
func (i *ProcDefWhereInput) P() (predicate.ProcDef, error) {
	var predicates []predicate.ProcDef
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, procdef.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProcDef, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, procdef.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProcDef, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, procdef.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, procdef.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, procdef.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, procdef.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, procdef.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, procdef.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, procdef.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, procdef.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, procdef.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, procdef.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, procdef.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, procdef.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, procdef.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, procdef.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, procdef.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, procdef.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, procdef.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, procdef.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, procdef.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, procdef.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, procdef.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, procdef.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, procdef.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, procdef.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, procdef.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, procdef.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, procdef.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, procdef.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, procdef.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, procdef.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, procdef.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, procdef.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, procdef.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, procdef.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, procdef.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, procdef.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, procdef.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, procdef.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, procdef.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, procdef.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, procdef.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, procdef.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, procdef.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, procdef.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, procdef.UpdatedAtNotNil())
	}
	if i.TenantID != nil {
		predicates = append(predicates, procdef.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, procdef.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, procdef.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, procdef.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, procdef.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, procdef.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, procdef.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, procdef.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.DeploymentID != nil {
		predicates = append(predicates, procdef.DeploymentIDEQ(*i.DeploymentID))
	}
	if i.DeploymentIDNEQ != nil {
		predicates = append(predicates, procdef.DeploymentIDNEQ(*i.DeploymentIDNEQ))
	}
	if len(i.DeploymentIDIn) > 0 {
		predicates = append(predicates, procdef.DeploymentIDIn(i.DeploymentIDIn...))
	}
	if len(i.DeploymentIDNotIn) > 0 {
		predicates = append(predicates, procdef.DeploymentIDNotIn(i.DeploymentIDNotIn...))
	}
	if i.AppID != nil {
		predicates = append(predicates, procdef.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, procdef.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, procdef.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, procdef.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.AppIDGT != nil {
		predicates = append(predicates, procdef.AppIDGT(*i.AppIDGT))
	}
	if i.AppIDGTE != nil {
		predicates = append(predicates, procdef.AppIDGTE(*i.AppIDGTE))
	}
	if i.AppIDLT != nil {
		predicates = append(predicates, procdef.AppIDLT(*i.AppIDLT))
	}
	if i.AppIDLTE != nil {
		predicates = append(predicates, procdef.AppIDLTE(*i.AppIDLTE))
	}
	if i.Category != nil {
		predicates = append(predicates, procdef.CategoryEQ(*i.Category))
	}
	if i.CategoryNEQ != nil {
		predicates = append(predicates, procdef.CategoryNEQ(*i.CategoryNEQ))
	}
	if len(i.CategoryIn) > 0 {
		predicates = append(predicates, procdef.CategoryIn(i.CategoryIn...))
	}
	if len(i.CategoryNotIn) > 0 {
		predicates = append(predicates, procdef.CategoryNotIn(i.CategoryNotIn...))
	}
	if i.CategoryGT != nil {
		predicates = append(predicates, procdef.CategoryGT(*i.CategoryGT))
	}
	if i.CategoryGTE != nil {
		predicates = append(predicates, procdef.CategoryGTE(*i.CategoryGTE))
	}
	if i.CategoryLT != nil {
		predicates = append(predicates, procdef.CategoryLT(*i.CategoryLT))
	}
	if i.CategoryLTE != nil {
		predicates = append(predicates, procdef.CategoryLTE(*i.CategoryLTE))
	}
	if i.CategoryContains != nil {
		predicates = append(predicates, procdef.CategoryContains(*i.CategoryContains))
	}
	if i.CategoryHasPrefix != nil {
		predicates = append(predicates, procdef.CategoryHasPrefix(*i.CategoryHasPrefix))
	}
	if i.CategoryHasSuffix != nil {
		predicates = append(predicates, procdef.CategoryHasSuffix(*i.CategoryHasSuffix))
	}
	if i.CategoryIsNil {
		predicates = append(predicates, procdef.CategoryIsNil())
	}
	if i.CategoryNotNil {
		predicates = append(predicates, procdef.CategoryNotNil())
	}
	if i.CategoryEqualFold != nil {
		predicates = append(predicates, procdef.CategoryEqualFold(*i.CategoryEqualFold))
	}
	if i.CategoryContainsFold != nil {
		predicates = append(predicates, procdef.CategoryContainsFold(*i.CategoryContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, procdef.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, procdef.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, procdef.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, procdef.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, procdef.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, procdef.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, procdef.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, procdef.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, procdef.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, procdef.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, procdef.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, procdef.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, procdef.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, procdef.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, procdef.NameContainsFold(*i.NameContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, procdef.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, procdef.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, procdef.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, procdef.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, procdef.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, procdef.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, procdef.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, procdef.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, procdef.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, procdef.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, procdef.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, procdef.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, procdef.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Version != nil {
		predicates = append(predicates, procdef.VersionEQ(*i.Version))
	}
	if i.VersionNEQ != nil {
		predicates = append(predicates, procdef.VersionNEQ(*i.VersionNEQ))
	}
	if len(i.VersionIn) > 0 {
		predicates = append(predicates, procdef.VersionIn(i.VersionIn...))
	}
	if len(i.VersionNotIn) > 0 {
		predicates = append(predicates, procdef.VersionNotIn(i.VersionNotIn...))
	}
	if i.VersionGT != nil {
		predicates = append(predicates, procdef.VersionGT(*i.VersionGT))
	}
	if i.VersionGTE != nil {
		predicates = append(predicates, procdef.VersionGTE(*i.VersionGTE))
	}
	if i.VersionLT != nil {
		predicates = append(predicates, procdef.VersionLT(*i.VersionLT))
	}
	if i.VersionLTE != nil {
		predicates = append(predicates, procdef.VersionLTE(*i.VersionLTE))
	}
	if i.VersionIsNil {
		predicates = append(predicates, procdef.VersionIsNil())
	}
	if i.VersionNotNil {
		predicates = append(predicates, procdef.VersionNotNil())
	}
	if i.Revision != nil {
		predicates = append(predicates, procdef.RevisionEQ(*i.Revision))
	}
	if i.RevisionNEQ != nil {
		predicates = append(predicates, procdef.RevisionNEQ(*i.RevisionNEQ))
	}
	if len(i.RevisionIn) > 0 {
		predicates = append(predicates, procdef.RevisionIn(i.RevisionIn...))
	}
	if len(i.RevisionNotIn) > 0 {
		predicates = append(predicates, procdef.RevisionNotIn(i.RevisionNotIn...))
	}
	if i.RevisionGT != nil {
		predicates = append(predicates, procdef.RevisionGT(*i.RevisionGT))
	}
	if i.RevisionGTE != nil {
		predicates = append(predicates, procdef.RevisionGTE(*i.RevisionGTE))
	}
	if i.RevisionLT != nil {
		predicates = append(predicates, procdef.RevisionLT(*i.RevisionLT))
	}
	if i.RevisionLTE != nil {
		predicates = append(predicates, procdef.RevisionLTE(*i.RevisionLTE))
	}
	if i.RevisionIsNil {
		predicates = append(predicates, procdef.RevisionIsNil())
	}
	if i.RevisionNotNil {
		predicates = append(predicates, procdef.RevisionNotNil())
	}
	if i.VersionTag != nil {
		predicates = append(predicates, procdef.VersionTagEQ(*i.VersionTag))
	}
	if i.VersionTagNEQ != nil {
		predicates = append(predicates, procdef.VersionTagNEQ(*i.VersionTagNEQ))
	}
	if len(i.VersionTagIn) > 0 {
		predicates = append(predicates, procdef.VersionTagIn(i.VersionTagIn...))
	}
	if len(i.VersionTagNotIn) > 0 {
		predicates = append(predicates, procdef.VersionTagNotIn(i.VersionTagNotIn...))
	}
	if i.VersionTagGT != nil {
		predicates = append(predicates, procdef.VersionTagGT(*i.VersionTagGT))
	}
	if i.VersionTagGTE != nil {
		predicates = append(predicates, procdef.VersionTagGTE(*i.VersionTagGTE))
	}
	if i.VersionTagLT != nil {
		predicates = append(predicates, procdef.VersionTagLT(*i.VersionTagLT))
	}
	if i.VersionTagLTE != nil {
		predicates = append(predicates, procdef.VersionTagLTE(*i.VersionTagLTE))
	}
	if i.VersionTagContains != nil {
		predicates = append(predicates, procdef.VersionTagContains(*i.VersionTagContains))
	}
	if i.VersionTagHasPrefix != nil {
		predicates = append(predicates, procdef.VersionTagHasPrefix(*i.VersionTagHasPrefix))
	}
	if i.VersionTagHasSuffix != nil {
		predicates = append(predicates, procdef.VersionTagHasSuffix(*i.VersionTagHasSuffix))
	}
	if i.VersionTagIsNil {
		predicates = append(predicates, procdef.VersionTagIsNil())
	}
	if i.VersionTagNotNil {
		predicates = append(predicates, procdef.VersionTagNotNil())
	}
	if i.VersionTagEqualFold != nil {
		predicates = append(predicates, procdef.VersionTagEqualFold(*i.VersionTagEqualFold))
	}
	if i.VersionTagContainsFold != nil {
		predicates = append(predicates, procdef.VersionTagContainsFold(*i.VersionTagContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, procdef.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, procdef.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, procdef.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, procdef.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasDeployment != nil {
		p := procdef.HasDeployment()
		if !*i.HasDeployment {
			p = procdef.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeploymentWith) > 0 {
		with := make([]predicate.Deployment, 0, len(i.HasDeploymentWith))
		for _, w := range i.HasDeploymentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeploymentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procdef.HasDeploymentWith(with...))
	}
	if i.HasProcInstances != nil {
		p := procdef.HasProcInstances()
		if !*i.HasProcInstances {
			p = procdef.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcInstancesWith) > 0 {
		with := make([]predicate.ProcInst, 0, len(i.HasProcInstancesWith))
		for _, w := range i.HasProcInstancesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcInstancesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procdef.HasProcInstancesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProcDefWhereInput
	case 1:
		return predicates[0], nil
	default:
		return procdef.And(predicates...), nil
	}
}

// ProcInstWhereInput represents a where input for filtering ProcInst queries.
type ProcInstWhereInput struct {
	Predicates []predicate.ProcInst  `json:"-"`
	Not        *ProcInstWhereInput   `json:"not,omitempty"`
	Or         []*ProcInstWhereInput `json:"or,omitempty"`
	And        []*ProcInstWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_by" field predicates.
	CreatedBy      *int  `json:"createdBy,omitempty"`
	CreatedByNEQ   *int  `json:"createdByNEQ,omitempty"`
	CreatedByIn    []int `json:"createdByIn,omitempty"`
	CreatedByNotIn []int `json:"createdByNotIn,omitempty"`
	CreatedByGT    *int  `json:"createdByGT,omitempty"`
	CreatedByGTE   *int  `json:"createdByGTE,omitempty"`
	CreatedByLT    *int  `json:"createdByLT,omitempty"`
	CreatedByLTE   *int  `json:"createdByLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_by" field predicates.
	UpdatedBy       *int  `json:"updatedBy,omitempty"`
	UpdatedByNEQ    *int  `json:"updatedByNEQ,omitempty"`
	UpdatedByIn     []int `json:"updatedByIn,omitempty"`
	UpdatedByNotIn  []int `json:"updatedByNotIn,omitempty"`
	UpdatedByGT     *int  `json:"updatedByGT,omitempty"`
	UpdatedByGTE    *int  `json:"updatedByGTE,omitempty"`
	UpdatedByLT     *int  `json:"updatedByLT,omitempty"`
	UpdatedByLTE    *int  `json:"updatedByLTE,omitempty"`
	UpdatedByIsNil  bool  `json:"updatedByIsNil,omitempty"`
	UpdatedByNotNil bool  `json:"updatedByNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "proc_def_id" field predicates.
	ProcDefID      *int  `json:"procDefID,omitempty"`
	ProcDefIDNEQ   *int  `json:"procDefIDNEQ,omitempty"`
	ProcDefIDIn    []int `json:"procDefIDIn,omitempty"`
	ProcDefIDNotIn []int `json:"procDefIDNotIn,omitempty"`

	// "app_id" field predicates.
	AppID      *int  `json:"appID,omitempty"`
	AppIDNEQ   *int  `json:"appIDNEQ,omitempty"`
	AppIDIn    []int `json:"appIDIn,omitempty"`
	AppIDNotIn []int `json:"appIDNotIn,omitempty"`
	AppIDGT    *int  `json:"appIDGT,omitempty"`
	AppIDGTE   *int  `json:"appIDGTE,omitempty"`
	AppIDLT    *int  `json:"appIDLT,omitempty"`
	AppIDLTE   *int  `json:"appIDLTE,omitempty"`

	// "business_key" field predicates.
	BusinessKey             *string  `json:"businessKey,omitempty"`
	BusinessKeyNEQ          *string  `json:"businessKeyNEQ,omitempty"`
	BusinessKeyIn           []string `json:"businessKeyIn,omitempty"`
	BusinessKeyNotIn        []string `json:"businessKeyNotIn,omitempty"`
	BusinessKeyGT           *string  `json:"businessKeyGT,omitempty"`
	BusinessKeyGTE          *string  `json:"businessKeyGTE,omitempty"`
	BusinessKeyLT           *string  `json:"businessKeyLT,omitempty"`
	BusinessKeyLTE          *string  `json:"businessKeyLTE,omitempty"`
	BusinessKeyContains     *string  `json:"businessKeyContains,omitempty"`
	BusinessKeyHasPrefix    *string  `json:"businessKeyHasPrefix,omitempty"`
	BusinessKeyHasSuffix    *string  `json:"businessKeyHasSuffix,omitempty"`
	BusinessKeyEqualFold    *string  `json:"businessKeyEqualFold,omitempty"`
	BusinessKeyContainsFold *string  `json:"businessKeyContainsFold,omitempty"`

	// "start_time" field predicates.
	StartTime      *time.Time  `json:"startTime,omitempty"`
	StartTimeNEQ   *time.Time  `json:"startTimeNEQ,omitempty"`
	StartTimeIn    []time.Time `json:"startTimeIn,omitempty"`
	StartTimeNotIn []time.Time `json:"startTimeNotIn,omitempty"`
	StartTimeGT    *time.Time  `json:"startTimeGT,omitempty"`
	StartTimeGTE   *time.Time  `json:"startTimeGTE,omitempty"`
	StartTimeLT    *time.Time  `json:"startTimeLT,omitempty"`
	StartTimeLTE   *time.Time  `json:"startTimeLTE,omitempty"`

	// "end_time" field predicates.
	EndTime       *time.Time  `json:"endTime,omitempty"`
	EndTimeNEQ    *time.Time  `json:"endTimeNEQ,omitempty"`
	EndTimeIn     []time.Time `json:"endTimeIn,omitempty"`
	EndTimeNotIn  []time.Time `json:"endTimeNotIn,omitempty"`
	EndTimeGT     *time.Time  `json:"endTimeGT,omitempty"`
	EndTimeGTE    *time.Time  `json:"endTimeGTE,omitempty"`
	EndTimeLT     *time.Time  `json:"endTimeLT,omitempty"`
	EndTimeLTE    *time.Time  `json:"endTimeLTE,omitempty"`
	EndTimeIsNil  bool        `json:"endTimeIsNil,omitempty"`
	EndTimeNotNil bool        `json:"endTimeNotNil,omitempty"`

	// "duration" field predicates.
	Duration       *int  `json:"duration,omitempty"`
	DurationNEQ    *int  `json:"durationNEQ,omitempty"`
	DurationIn     []int `json:"durationIn,omitempty"`
	DurationNotIn  []int `json:"durationNotIn,omitempty"`
	DurationGT     *int  `json:"durationGT,omitempty"`
	DurationGTE    *int  `json:"durationGTE,omitempty"`
	DurationLT     *int  `json:"durationLT,omitempty"`
	DurationLTE    *int  `json:"durationLTE,omitempty"`
	DurationIsNil  bool  `json:"durationIsNil,omitempty"`
	DurationNotNil bool  `json:"durationNotNil,omitempty"`

	// "start_user_id" field predicates.
	StartUserID      *int  `json:"startUserID,omitempty"`
	StartUserIDNEQ   *int  `json:"startUserIDNEQ,omitempty"`
	StartUserIDIn    []int `json:"startUserIDIn,omitempty"`
	StartUserIDNotIn []int `json:"startUserIDNotIn,omitempty"`
	StartUserIDGT    *int  `json:"startUserIDGT,omitempty"`
	StartUserIDGTE   *int  `json:"startUserIDGTE,omitempty"`
	StartUserIDLT    *int  `json:"startUserIDLT,omitempty"`
	StartUserIDLTE   *int  `json:"startUserIDLTE,omitempty"`

	// "supper_instance_id" field predicates.
	SupperInstanceID       *int  `json:"supperInstanceID,omitempty"`
	SupperInstanceIDNEQ    *int  `json:"supperInstanceIDNEQ,omitempty"`
	SupperInstanceIDIn     []int `json:"supperInstanceIDIn,omitempty"`
	SupperInstanceIDNotIn  []int `json:"supperInstanceIDNotIn,omitempty"`
	SupperInstanceIDGT     *int  `json:"supperInstanceIDGT,omitempty"`
	SupperInstanceIDGTE    *int  `json:"supperInstanceIDGTE,omitempty"`
	SupperInstanceIDLT     *int  `json:"supperInstanceIDLT,omitempty"`
	SupperInstanceIDLTE    *int  `json:"supperInstanceIDLTE,omitempty"`
	SupperInstanceIDIsNil  bool  `json:"supperInstanceIDIsNil,omitempty"`
	SupperInstanceIDNotNil bool  `json:"supperInstanceIDNotNil,omitempty"`

	// "root_instance_id" field predicates.
	RootInstanceID       *int  `json:"rootInstanceID,omitempty"`
	RootInstanceIDNEQ    *int  `json:"rootInstanceIDNEQ,omitempty"`
	RootInstanceIDIn     []int `json:"rootInstanceIDIn,omitempty"`
	RootInstanceIDNotIn  []int `json:"rootInstanceIDNotIn,omitempty"`
	RootInstanceIDGT     *int  `json:"rootInstanceIDGT,omitempty"`
	RootInstanceIDGTE    *int  `json:"rootInstanceIDGTE,omitempty"`
	RootInstanceIDLT     *int  `json:"rootInstanceIDLT,omitempty"`
	RootInstanceIDLTE    *int  `json:"rootInstanceIDLTE,omitempty"`
	RootInstanceIDIsNil  bool  `json:"rootInstanceIDIsNil,omitempty"`
	RootInstanceIDNotNil bool  `json:"rootInstanceIDNotNil,omitempty"`

	// "deleted_time" field predicates.
	DeletedTime       *time.Time  `json:"deletedTime,omitempty"`
	DeletedTimeNEQ    *time.Time  `json:"deletedTimeNEQ,omitempty"`
	DeletedTimeIn     []time.Time `json:"deletedTimeIn,omitempty"`
	DeletedTimeNotIn  []time.Time `json:"deletedTimeNotIn,omitempty"`
	DeletedTimeGT     *time.Time  `json:"deletedTimeGT,omitempty"`
	DeletedTimeGTE    *time.Time  `json:"deletedTimeGTE,omitempty"`
	DeletedTimeLT     *time.Time  `json:"deletedTimeLT,omitempty"`
	DeletedTimeLTE    *time.Time  `json:"deletedTimeLTE,omitempty"`
	DeletedTimeIsNil  bool        `json:"deletedTimeIsNil,omitempty"`
	DeletedTimeNotNil bool        `json:"deletedTimeNotNil,omitempty"`

	// "deleted_reason" field predicates.
	DeletedReason             *string  `json:"deletedReason,omitempty"`
	DeletedReasonNEQ          *string  `json:"deletedReasonNEQ,omitempty"`
	DeletedReasonIn           []string `json:"deletedReasonIn,omitempty"`
	DeletedReasonNotIn        []string `json:"deletedReasonNotIn,omitempty"`
	DeletedReasonGT           *string  `json:"deletedReasonGT,omitempty"`
	DeletedReasonGTE          *string  `json:"deletedReasonGTE,omitempty"`
	DeletedReasonLT           *string  `json:"deletedReasonLT,omitempty"`
	DeletedReasonLTE          *string  `json:"deletedReasonLTE,omitempty"`
	DeletedReasonContains     *string  `json:"deletedReasonContains,omitempty"`
	DeletedReasonHasPrefix    *string  `json:"deletedReasonHasPrefix,omitempty"`
	DeletedReasonHasSuffix    *string  `json:"deletedReasonHasSuffix,omitempty"`
	DeletedReasonIsNil        bool     `json:"deletedReasonIsNil,omitempty"`
	DeletedReasonNotNil       bool     `json:"deletedReasonNotNil,omitempty"`
	DeletedReasonEqualFold    *string  `json:"deletedReasonEqualFold,omitempty"`
	DeletedReasonContainsFold *string  `json:"deletedReasonContainsFold,omitempty"`

	// "status" field predicates.
	Status      *procinst.Status  `json:"status,omitempty"`
	StatusNEQ   *procinst.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []procinst.Status `json:"statusIn,omitempty"`
	StatusNotIn []procinst.Status `json:"statusNotIn,omitempty"`

	// "proc_def" edge predicates.
	HasProcDef     *bool                `json:"hasProcDef,omitempty"`
	HasProcDefWith []*ProcDefWhereInput `json:"hasProcDefWith,omitempty"`

	// "tasks" edge predicates.
	HasTasks     *bool             `json:"hasTasks,omitempty"`
	HasTasksWith []*TaskWhereInput `json:"hasTasksWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProcInstWhereInput) AddPredicates(predicates ...predicate.ProcInst) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProcInstWhereInput filter on the ProcInstQuery builder.
func (i *ProcInstWhereInput) Filter(q *ProcInstQuery) (*ProcInstQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProcInstWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProcInstWhereInput is returned in case the ProcInstWhereInput is empty.
var ErrEmptyProcInstWhereInput = errors.New("ent: empty predicate ProcInstWhereInput")

// P returns a predicate for filtering procinsts.
// An error is returned if the input is empty or invalid.
func (i *ProcInstWhereInput) P() (predicate.ProcInst, error) {
	var predicates []predicate.ProcInst
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, procinst.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProcInst, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, procinst.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProcInst, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, procinst.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, procinst.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, procinst.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, procinst.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, procinst.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, procinst.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, procinst.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, procinst.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, procinst.IDLTE(*i.IDLTE))
	}
	if i.CreatedBy != nil {
		predicates = append(predicates, procinst.CreatedByEQ(*i.CreatedBy))
	}
	if i.CreatedByNEQ != nil {
		predicates = append(predicates, procinst.CreatedByNEQ(*i.CreatedByNEQ))
	}
	if len(i.CreatedByIn) > 0 {
		predicates = append(predicates, procinst.CreatedByIn(i.CreatedByIn...))
	}
	if len(i.CreatedByNotIn) > 0 {
		predicates = append(predicates, procinst.CreatedByNotIn(i.CreatedByNotIn...))
	}
	if i.CreatedByGT != nil {
		predicates = append(predicates, procinst.CreatedByGT(*i.CreatedByGT))
	}
	if i.CreatedByGTE != nil {
		predicates = append(predicates, procinst.CreatedByGTE(*i.CreatedByGTE))
	}
	if i.CreatedByLT != nil {
		predicates = append(predicates, procinst.CreatedByLT(*i.CreatedByLT))
	}
	if i.CreatedByLTE != nil {
		predicates = append(predicates, procinst.CreatedByLTE(*i.CreatedByLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, procinst.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, procinst.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, procinst.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, procinst.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, procinst.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, procinst.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, procinst.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, procinst.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedBy != nil {
		predicates = append(predicates, procinst.UpdatedByEQ(*i.UpdatedBy))
	}
	if i.UpdatedByNEQ != nil {
		predicates = append(predicates, procinst.UpdatedByNEQ(*i.UpdatedByNEQ))
	}
	if len(i.UpdatedByIn) > 0 {
		predicates = append(predicates, procinst.UpdatedByIn(i.UpdatedByIn...))
	}
	if len(i.UpdatedByNotIn) > 0 {
		predicates = append(predicates, procinst.UpdatedByNotIn(i.UpdatedByNotIn...))
	}
	if i.UpdatedByGT != nil {
		predicates = append(predicates, procinst.UpdatedByGT(*i.UpdatedByGT))
	}
	if i.UpdatedByGTE != nil {
		predicates = append(predicates, procinst.UpdatedByGTE(*i.UpdatedByGTE))
	}
	if i.UpdatedByLT != nil {
		predicates = append(predicates, procinst.UpdatedByLT(*i.UpdatedByLT))
	}
	if i.UpdatedByLTE != nil {
		predicates = append(predicates, procinst.UpdatedByLTE(*i.UpdatedByLTE))
	}
	if i.UpdatedByIsNil {
		predicates = append(predicates, procinst.UpdatedByIsNil())
	}
	if i.UpdatedByNotNil {
		predicates = append(predicates, procinst.UpdatedByNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, procinst.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, procinst.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, procinst.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, procinst.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, procinst.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, procinst.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, procinst.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, procinst.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, procinst.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, procinst.UpdatedAtNotNil())
	}
	if i.TenantID != nil {
		predicates = append(predicates, procinst.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, procinst.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, procinst.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, procinst.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, procinst.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, procinst.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, procinst.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, procinst.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.ProcDefID != nil {
		predicates = append(predicates, procinst.ProcDefIDEQ(*i.ProcDefID))
	}
	if i.ProcDefIDNEQ != nil {
		predicates = append(predicates, procinst.ProcDefIDNEQ(*i.ProcDefIDNEQ))
	}
	if len(i.ProcDefIDIn) > 0 {
		predicates = append(predicates, procinst.ProcDefIDIn(i.ProcDefIDIn...))
	}
	if len(i.ProcDefIDNotIn) > 0 {
		predicates = append(predicates, procinst.ProcDefIDNotIn(i.ProcDefIDNotIn...))
	}
	if i.AppID != nil {
		predicates = append(predicates, procinst.AppIDEQ(*i.AppID))
	}
	if i.AppIDNEQ != nil {
		predicates = append(predicates, procinst.AppIDNEQ(*i.AppIDNEQ))
	}
	if len(i.AppIDIn) > 0 {
		predicates = append(predicates, procinst.AppIDIn(i.AppIDIn...))
	}
	if len(i.AppIDNotIn) > 0 {
		predicates = append(predicates, procinst.AppIDNotIn(i.AppIDNotIn...))
	}
	if i.AppIDGT != nil {
		predicates = append(predicates, procinst.AppIDGT(*i.AppIDGT))
	}
	if i.AppIDGTE != nil {
		predicates = append(predicates, procinst.AppIDGTE(*i.AppIDGTE))
	}
	if i.AppIDLT != nil {
		predicates = append(predicates, procinst.AppIDLT(*i.AppIDLT))
	}
	if i.AppIDLTE != nil {
		predicates = append(predicates, procinst.AppIDLTE(*i.AppIDLTE))
	}
	if i.BusinessKey != nil {
		predicates = append(predicates, procinst.BusinessKeyEQ(*i.BusinessKey))
	}
	if i.BusinessKeyNEQ != nil {
		predicates = append(predicates, procinst.BusinessKeyNEQ(*i.BusinessKeyNEQ))
	}
	if len(i.BusinessKeyIn) > 0 {
		predicates = append(predicates, procinst.BusinessKeyIn(i.BusinessKeyIn...))
	}
	if len(i.BusinessKeyNotIn) > 0 {
		predicates = append(predicates, procinst.BusinessKeyNotIn(i.BusinessKeyNotIn...))
	}
	if i.BusinessKeyGT != nil {
		predicates = append(predicates, procinst.BusinessKeyGT(*i.BusinessKeyGT))
	}
	if i.BusinessKeyGTE != nil {
		predicates = append(predicates, procinst.BusinessKeyGTE(*i.BusinessKeyGTE))
	}
	if i.BusinessKeyLT != nil {
		predicates = append(predicates, procinst.BusinessKeyLT(*i.BusinessKeyLT))
	}
	if i.BusinessKeyLTE != nil {
		predicates = append(predicates, procinst.BusinessKeyLTE(*i.BusinessKeyLTE))
	}
	if i.BusinessKeyContains != nil {
		predicates = append(predicates, procinst.BusinessKeyContains(*i.BusinessKeyContains))
	}
	if i.BusinessKeyHasPrefix != nil {
		predicates = append(predicates, procinst.BusinessKeyHasPrefix(*i.BusinessKeyHasPrefix))
	}
	if i.BusinessKeyHasSuffix != nil {
		predicates = append(predicates, procinst.BusinessKeyHasSuffix(*i.BusinessKeyHasSuffix))
	}
	if i.BusinessKeyEqualFold != nil {
		predicates = append(predicates, procinst.BusinessKeyEqualFold(*i.BusinessKeyEqualFold))
	}
	if i.BusinessKeyContainsFold != nil {
		predicates = append(predicates, procinst.BusinessKeyContainsFold(*i.BusinessKeyContainsFold))
	}
	if i.StartTime != nil {
		predicates = append(predicates, procinst.StartTimeEQ(*i.StartTime))
	}
	if i.StartTimeNEQ != nil {
		predicates = append(predicates, procinst.StartTimeNEQ(*i.StartTimeNEQ))
	}
	if len(i.StartTimeIn) > 0 {
		predicates = append(predicates, procinst.StartTimeIn(i.StartTimeIn...))
	}
	if len(i.StartTimeNotIn) > 0 {
		predicates = append(predicates, procinst.StartTimeNotIn(i.StartTimeNotIn...))
	}
	if i.StartTimeGT != nil {
		predicates = append(predicates, procinst.StartTimeGT(*i.StartTimeGT))
	}
	if i.StartTimeGTE != nil {
		predicates = append(predicates, procinst.StartTimeGTE(*i.StartTimeGTE))
	}
	if i.StartTimeLT != nil {
		predicates = append(predicates, procinst.StartTimeLT(*i.StartTimeLT))
	}
	if i.StartTimeLTE != nil {
		predicates = append(predicates, procinst.StartTimeLTE(*i.StartTimeLTE))
	}
	if i.EndTime != nil {
		predicates = append(predicates, procinst.EndTimeEQ(*i.EndTime))
	}
	if i.EndTimeNEQ != nil {
		predicates = append(predicates, procinst.EndTimeNEQ(*i.EndTimeNEQ))
	}
	if len(i.EndTimeIn) > 0 {
		predicates = append(predicates, procinst.EndTimeIn(i.EndTimeIn...))
	}
	if len(i.EndTimeNotIn) > 0 {
		predicates = append(predicates, procinst.EndTimeNotIn(i.EndTimeNotIn...))
	}
	if i.EndTimeGT != nil {
		predicates = append(predicates, procinst.EndTimeGT(*i.EndTimeGT))
	}
	if i.EndTimeGTE != nil {
		predicates = append(predicates, procinst.EndTimeGTE(*i.EndTimeGTE))
	}
	if i.EndTimeLT != nil {
		predicates = append(predicates, procinst.EndTimeLT(*i.EndTimeLT))
	}
	if i.EndTimeLTE != nil {
		predicates = append(predicates, procinst.EndTimeLTE(*i.EndTimeLTE))
	}
	if i.EndTimeIsNil {
		predicates = append(predicates, procinst.EndTimeIsNil())
	}
	if i.EndTimeNotNil {
		predicates = append(predicates, procinst.EndTimeNotNil())
	}
	if i.Duration != nil {
		predicates = append(predicates, procinst.DurationEQ(*i.Duration))
	}
	if i.DurationNEQ != nil {
		predicates = append(predicates, procinst.DurationNEQ(*i.DurationNEQ))
	}
	if len(i.DurationIn) > 0 {
		predicates = append(predicates, procinst.DurationIn(i.DurationIn...))
	}
	if len(i.DurationNotIn) > 0 {
		predicates = append(predicates, procinst.DurationNotIn(i.DurationNotIn...))
	}
	if i.DurationGT != nil {
		predicates = append(predicates, procinst.DurationGT(*i.DurationGT))
	}
	if i.DurationGTE != nil {
		predicates = append(predicates, procinst.DurationGTE(*i.DurationGTE))
	}
	if i.DurationLT != nil {
		predicates = append(predicates, procinst.DurationLT(*i.DurationLT))
	}
	if i.DurationLTE != nil {
		predicates = append(predicates, procinst.DurationLTE(*i.DurationLTE))
	}
	if i.DurationIsNil {
		predicates = append(predicates, procinst.DurationIsNil())
	}
	if i.DurationNotNil {
		predicates = append(predicates, procinst.DurationNotNil())
	}
	if i.StartUserID != nil {
		predicates = append(predicates, procinst.StartUserIDEQ(*i.StartUserID))
	}
	if i.StartUserIDNEQ != nil {
		predicates = append(predicates, procinst.StartUserIDNEQ(*i.StartUserIDNEQ))
	}
	if len(i.StartUserIDIn) > 0 {
		predicates = append(predicates, procinst.StartUserIDIn(i.StartUserIDIn...))
	}
	if len(i.StartUserIDNotIn) > 0 {
		predicates = append(predicates, procinst.StartUserIDNotIn(i.StartUserIDNotIn...))
	}
	if i.StartUserIDGT != nil {
		predicates = append(predicates, procinst.StartUserIDGT(*i.StartUserIDGT))
	}
	if i.StartUserIDGTE != nil {
		predicates = append(predicates, procinst.StartUserIDGTE(*i.StartUserIDGTE))
	}
	if i.StartUserIDLT != nil {
		predicates = append(predicates, procinst.StartUserIDLT(*i.StartUserIDLT))
	}
	if i.StartUserIDLTE != nil {
		predicates = append(predicates, procinst.StartUserIDLTE(*i.StartUserIDLTE))
	}
	if i.SupperInstanceID != nil {
		predicates = append(predicates, procinst.SupperInstanceIDEQ(*i.SupperInstanceID))
	}
	if i.SupperInstanceIDNEQ != nil {
		predicates = append(predicates, procinst.SupperInstanceIDNEQ(*i.SupperInstanceIDNEQ))
	}
	if len(i.SupperInstanceIDIn) > 0 {
		predicates = append(predicates, procinst.SupperInstanceIDIn(i.SupperInstanceIDIn...))
	}
	if len(i.SupperInstanceIDNotIn) > 0 {
		predicates = append(predicates, procinst.SupperInstanceIDNotIn(i.SupperInstanceIDNotIn...))
	}
	if i.SupperInstanceIDGT != nil {
		predicates = append(predicates, procinst.SupperInstanceIDGT(*i.SupperInstanceIDGT))
	}
	if i.SupperInstanceIDGTE != nil {
		predicates = append(predicates, procinst.SupperInstanceIDGTE(*i.SupperInstanceIDGTE))
	}
	if i.SupperInstanceIDLT != nil {
		predicates = append(predicates, procinst.SupperInstanceIDLT(*i.SupperInstanceIDLT))
	}
	if i.SupperInstanceIDLTE != nil {
		predicates = append(predicates, procinst.SupperInstanceIDLTE(*i.SupperInstanceIDLTE))
	}
	if i.SupperInstanceIDIsNil {
		predicates = append(predicates, procinst.SupperInstanceIDIsNil())
	}
	if i.SupperInstanceIDNotNil {
		predicates = append(predicates, procinst.SupperInstanceIDNotNil())
	}
	if i.RootInstanceID != nil {
		predicates = append(predicates, procinst.RootInstanceIDEQ(*i.RootInstanceID))
	}
	if i.RootInstanceIDNEQ != nil {
		predicates = append(predicates, procinst.RootInstanceIDNEQ(*i.RootInstanceIDNEQ))
	}
	if len(i.RootInstanceIDIn) > 0 {
		predicates = append(predicates, procinst.RootInstanceIDIn(i.RootInstanceIDIn...))
	}
	if len(i.RootInstanceIDNotIn) > 0 {
		predicates = append(predicates, procinst.RootInstanceIDNotIn(i.RootInstanceIDNotIn...))
	}
	if i.RootInstanceIDGT != nil {
		predicates = append(predicates, procinst.RootInstanceIDGT(*i.RootInstanceIDGT))
	}
	if i.RootInstanceIDGTE != nil {
		predicates = append(predicates, procinst.RootInstanceIDGTE(*i.RootInstanceIDGTE))
	}
	if i.RootInstanceIDLT != nil {
		predicates = append(predicates, procinst.RootInstanceIDLT(*i.RootInstanceIDLT))
	}
	if i.RootInstanceIDLTE != nil {
		predicates = append(predicates, procinst.RootInstanceIDLTE(*i.RootInstanceIDLTE))
	}
	if i.RootInstanceIDIsNil {
		predicates = append(predicates, procinst.RootInstanceIDIsNil())
	}
	if i.RootInstanceIDNotNil {
		predicates = append(predicates, procinst.RootInstanceIDNotNil())
	}
	if i.DeletedTime != nil {
		predicates = append(predicates, procinst.DeletedTimeEQ(*i.DeletedTime))
	}
	if i.DeletedTimeNEQ != nil {
		predicates = append(predicates, procinst.DeletedTimeNEQ(*i.DeletedTimeNEQ))
	}
	if len(i.DeletedTimeIn) > 0 {
		predicates = append(predicates, procinst.DeletedTimeIn(i.DeletedTimeIn...))
	}
	if len(i.DeletedTimeNotIn) > 0 {
		predicates = append(predicates, procinst.DeletedTimeNotIn(i.DeletedTimeNotIn...))
	}
	if i.DeletedTimeGT != nil {
		predicates = append(predicates, procinst.DeletedTimeGT(*i.DeletedTimeGT))
	}
	if i.DeletedTimeGTE != nil {
		predicates = append(predicates, procinst.DeletedTimeGTE(*i.DeletedTimeGTE))
	}
	if i.DeletedTimeLT != nil {
		predicates = append(predicates, procinst.DeletedTimeLT(*i.DeletedTimeLT))
	}
	if i.DeletedTimeLTE != nil {
		predicates = append(predicates, procinst.DeletedTimeLTE(*i.DeletedTimeLTE))
	}
	if i.DeletedTimeIsNil {
		predicates = append(predicates, procinst.DeletedTimeIsNil())
	}
	if i.DeletedTimeNotNil {
		predicates = append(predicates, procinst.DeletedTimeNotNil())
	}
	if i.DeletedReason != nil {
		predicates = append(predicates, procinst.DeletedReasonEQ(*i.DeletedReason))
	}
	if i.DeletedReasonNEQ != nil {
		predicates = append(predicates, procinst.DeletedReasonNEQ(*i.DeletedReasonNEQ))
	}
	if len(i.DeletedReasonIn) > 0 {
		predicates = append(predicates, procinst.DeletedReasonIn(i.DeletedReasonIn...))
	}
	if len(i.DeletedReasonNotIn) > 0 {
		predicates = append(predicates, procinst.DeletedReasonNotIn(i.DeletedReasonNotIn...))
	}
	if i.DeletedReasonGT != nil {
		predicates = append(predicates, procinst.DeletedReasonGT(*i.DeletedReasonGT))
	}
	if i.DeletedReasonGTE != nil {
		predicates = append(predicates, procinst.DeletedReasonGTE(*i.DeletedReasonGTE))
	}
	if i.DeletedReasonLT != nil {
		predicates = append(predicates, procinst.DeletedReasonLT(*i.DeletedReasonLT))
	}
	if i.DeletedReasonLTE != nil {
		predicates = append(predicates, procinst.DeletedReasonLTE(*i.DeletedReasonLTE))
	}
	if i.DeletedReasonContains != nil {
		predicates = append(predicates, procinst.DeletedReasonContains(*i.DeletedReasonContains))
	}
	if i.DeletedReasonHasPrefix != nil {
		predicates = append(predicates, procinst.DeletedReasonHasPrefix(*i.DeletedReasonHasPrefix))
	}
	if i.DeletedReasonHasSuffix != nil {
		predicates = append(predicates, procinst.DeletedReasonHasSuffix(*i.DeletedReasonHasSuffix))
	}
	if i.DeletedReasonIsNil {
		predicates = append(predicates, procinst.DeletedReasonIsNil())
	}
	if i.DeletedReasonNotNil {
		predicates = append(predicates, procinst.DeletedReasonNotNil())
	}
	if i.DeletedReasonEqualFold != nil {
		predicates = append(predicates, procinst.DeletedReasonEqualFold(*i.DeletedReasonEqualFold))
	}
	if i.DeletedReasonContainsFold != nil {
		predicates = append(predicates, procinst.DeletedReasonContainsFold(*i.DeletedReasonContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, procinst.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, procinst.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, procinst.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, procinst.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasProcDef != nil {
		p := procinst.HasProcDef()
		if !*i.HasProcDef {
			p = procinst.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcDefWith) > 0 {
		with := make([]predicate.ProcDef, 0, len(i.HasProcDefWith))
		for _, w := range i.HasProcDefWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcDefWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procinst.HasProcDefWith(with...))
	}
	if i.HasTasks != nil {
		p := procinst.HasTasks()
		if !*i.HasTasks {
			p = procinst.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTasksWith) > 0 {
		with := make([]predicate.Task, 0, len(i.HasTasksWith))
		for _, w := range i.HasTasksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTasksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, procinst.HasTasksWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProcInstWhereInput
	case 1:
		return predicates[0], nil
	default:
		return procinst.And(predicates...), nil
	}
}

// TaskWhereInput represents a where input for filtering Task queries.
type TaskWhereInput struct {
	Predicates []predicate.Task  `json:"-"`
	Not        *TaskWhereInput   `json:"not,omitempty"`
	Or         []*TaskWhereInput `json:"or,omitempty"`
	And        []*TaskWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID      *int  `json:"tenantID,omitempty"`
	TenantIDNEQ   *int  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn    []int `json:"tenantIDIn,omitempty"`
	TenantIDNotIn []int `json:"tenantIDNotIn,omitempty"`
	TenantIDGT    *int  `json:"tenantIDGT,omitempty"`
	TenantIDGTE   *int  `json:"tenantIDGTE,omitempty"`
	TenantIDLT    *int  `json:"tenantIDLT,omitempty"`
	TenantIDLTE   *int  `json:"tenantIDLTE,omitempty"`

	// "proc_inst_id" field predicates.
	ProcInstID      *int  `json:"procInstID,omitempty"`
	ProcInstIDNEQ   *int  `json:"procInstIDNEQ,omitempty"`
	ProcInstIDIn    []int `json:"procInstIDIn,omitempty"`
	ProcInstIDNotIn []int `json:"procInstIDNotIn,omitempty"`

	// "proc_def_id" field predicates.
	ProcDefID      *int  `json:"procDefID,omitempty"`
	ProcDefIDNEQ   *int  `json:"procDefIDNEQ,omitempty"`
	ProcDefIDIn    []int `json:"procDefIDIn,omitempty"`
	ProcDefIDNotIn []int `json:"procDefIDNotIn,omitempty"`
	ProcDefIDGT    *int  `json:"procDefIDGT,omitempty"`
	ProcDefIDGTE   *int  `json:"procDefIDGTE,omitempty"`
	ProcDefIDLT    *int  `json:"procDefIDLT,omitempty"`
	ProcDefIDLTE   *int  `json:"procDefIDLTE,omitempty"`

	// "execution_id" field predicates.
	ExecutionID             *string  `json:"executionID,omitempty"`
	ExecutionIDNEQ          *string  `json:"executionIDNEQ,omitempty"`
	ExecutionIDIn           []string `json:"executionIDIn,omitempty"`
	ExecutionIDNotIn        []string `json:"executionIDNotIn,omitempty"`
	ExecutionIDGT           *string  `json:"executionIDGT,omitempty"`
	ExecutionIDGTE          *string  `json:"executionIDGTE,omitempty"`
	ExecutionIDLT           *string  `json:"executionIDLT,omitempty"`
	ExecutionIDLTE          *string  `json:"executionIDLTE,omitempty"`
	ExecutionIDContains     *string  `json:"executionIDContains,omitempty"`
	ExecutionIDHasPrefix    *string  `json:"executionIDHasPrefix,omitempty"`
	ExecutionIDHasSuffix    *string  `json:"executionIDHasSuffix,omitempty"`
	ExecutionIDEqualFold    *string  `json:"executionIDEqualFold,omitempty"`
	ExecutionIDContainsFold *string  `json:"executionIDContainsFold,omitempty"`

	// "run_id" field predicates.
	RunID             *string  `json:"runID,omitempty"`
	RunIDNEQ          *string  `json:"runIDNEQ,omitempty"`
	RunIDIn           []string `json:"runIDIn,omitempty"`
	RunIDNotIn        []string `json:"runIDNotIn,omitempty"`
	RunIDGT           *string  `json:"runIDGT,omitempty"`
	RunIDGTE          *string  `json:"runIDGTE,omitempty"`
	RunIDLT           *string  `json:"runIDLT,omitempty"`
	RunIDLTE          *string  `json:"runIDLTE,omitempty"`
	RunIDContains     *string  `json:"runIDContains,omitempty"`
	RunIDHasPrefix    *string  `json:"runIDHasPrefix,omitempty"`
	RunIDHasSuffix    *string  `json:"runIDHasSuffix,omitempty"`
	RunIDIsNil        bool     `json:"runIDIsNil,omitempty"`
	RunIDNotNil       bool     `json:"runIDNotNil,omitempty"`
	RunIDEqualFold    *string  `json:"runIDEqualFold,omitempty"`
	RunIDContainsFold *string  `json:"runIDContainsFold,omitempty"`

	// "task_def_key" field predicates.
	TaskDefKey             *string  `json:"taskDefKey,omitempty"`
	TaskDefKeyNEQ          *string  `json:"taskDefKeyNEQ,omitempty"`
	TaskDefKeyIn           []string `json:"taskDefKeyIn,omitempty"`
	TaskDefKeyNotIn        []string `json:"taskDefKeyNotIn,omitempty"`
	TaskDefKeyGT           *string  `json:"taskDefKeyGT,omitempty"`
	TaskDefKeyGTE          *string  `json:"taskDefKeyGTE,omitempty"`
	TaskDefKeyLT           *string  `json:"taskDefKeyLT,omitempty"`
	TaskDefKeyLTE          *string  `json:"taskDefKeyLTE,omitempty"`
	TaskDefKeyContains     *string  `json:"taskDefKeyContains,omitempty"`
	TaskDefKeyHasPrefix    *string  `json:"taskDefKeyHasPrefix,omitempty"`
	TaskDefKeyHasSuffix    *string  `json:"taskDefKeyHasSuffix,omitempty"`
	TaskDefKeyEqualFold    *string  `json:"taskDefKeyEqualFold,omitempty"`
	TaskDefKeyContainsFold *string  `json:"taskDefKeyContainsFold,omitempty"`

	// "parent_id" field predicates.
	ParentID       *int  `json:"parentID,omitempty"`
	ParentIDNEQ    *int  `json:"parentIDNEQ,omitempty"`
	ParentIDIn     []int `json:"parentIDIn,omitempty"`
	ParentIDNotIn  []int `json:"parentIDNotIn,omitempty"`
	ParentIDGT     *int  `json:"parentIDGT,omitempty"`
	ParentIDGTE    *int  `json:"parentIDGTE,omitempty"`
	ParentIDLT     *int  `json:"parentIDLT,omitempty"`
	ParentIDLTE    *int  `json:"parentIDLTE,omitempty"`
	ParentIDIsNil  bool  `json:"parentIDIsNil,omitempty"`
	ParentIDNotNil bool  `json:"parentIDNotNil,omitempty"`

	// "assignee" field predicates.
	Assignee             *string  `json:"assignee,omitempty"`
	AssigneeNEQ          *string  `json:"assigneeNEQ,omitempty"`
	AssigneeIn           []string `json:"assigneeIn,omitempty"`
	AssigneeNotIn        []string `json:"assigneeNotIn,omitempty"`
	AssigneeGT           *string  `json:"assigneeGT,omitempty"`
	AssigneeGTE          *string  `json:"assigneeGTE,omitempty"`
	AssigneeLT           *string  `json:"assigneeLT,omitempty"`
	AssigneeLTE          *string  `json:"assigneeLTE,omitempty"`
	AssigneeContains     *string  `json:"assigneeContains,omitempty"`
	AssigneeHasPrefix    *string  `json:"assigneeHasPrefix,omitempty"`
	AssigneeHasSuffix    *string  `json:"assigneeHasSuffix,omitempty"`
	AssigneeIsNil        bool     `json:"assigneeIsNil,omitempty"`
	AssigneeNotNil       bool     `json:"assigneeNotNil,omitempty"`
	AssigneeEqualFold    *string  `json:"assigneeEqualFold,omitempty"`
	AssigneeContainsFold *string  `json:"assigneeContainsFold,omitempty"`

	// "member_count" field predicates.
	MemberCount      *int32  `json:"memberCount,omitempty"`
	MemberCountNEQ   *int32  `json:"memberCountNEQ,omitempty"`
	MemberCountIn    []int32 `json:"memberCountIn,omitempty"`
	MemberCountNotIn []int32 `json:"memberCountNotIn,omitempty"`
	MemberCountGT    *int32  `json:"memberCountGT,omitempty"`
	MemberCountGTE   *int32  `json:"memberCountGTE,omitempty"`
	MemberCountLT    *int32  `json:"memberCountLT,omitempty"`
	MemberCountLTE   *int32  `json:"memberCountLTE,omitempty"`

	// "unfinished_count" field predicates.
	UnfinishedCount      *int32  `json:"unfinishedCount,omitempty"`
	UnfinishedCountNEQ   *int32  `json:"unfinishedCountNEQ,omitempty"`
	UnfinishedCountIn    []int32 `json:"unfinishedCountIn,omitempty"`
	UnfinishedCountNotIn []int32 `json:"unfinishedCountNotIn,omitempty"`
	UnfinishedCountGT    *int32  `json:"unfinishedCountGT,omitempty"`
	UnfinishedCountGTE   *int32  `json:"unfinishedCountGTE,omitempty"`
	UnfinishedCountLT    *int32  `json:"unfinishedCountLT,omitempty"`
	UnfinishedCountLTE   *int32  `json:"unfinishedCountLTE,omitempty"`

	// "agree_count" field predicates.
	AgreeCount      *int32  `json:"agreeCount,omitempty"`
	AgreeCountNEQ   *int32  `json:"agreeCountNEQ,omitempty"`
	AgreeCountIn    []int32 `json:"agreeCountIn,omitempty"`
	AgreeCountNotIn []int32 `json:"agreeCountNotIn,omitempty"`
	AgreeCountGT    *int32  `json:"agreeCountGT,omitempty"`
	AgreeCountGTE   *int32  `json:"agreeCountGTE,omitempty"`
	AgreeCountLT    *int32  `json:"agreeCountLT,omitempty"`
	AgreeCountLTE   *int32  `json:"agreeCountLTE,omitempty"`

	// "kind" field predicates.
	Kind      *task.Kind  `json:"kind,omitempty"`
	KindNEQ   *task.Kind  `json:"kindNEQ,omitempty"`
	KindIn    []task.Kind `json:"kindIn,omitempty"`
	KindNotIn []task.Kind `json:"kindNotIn,omitempty"`

	// "sequential" field predicates.
	Sequential    *bool `json:"sequential,omitempty"`
	SequentialNEQ *bool `json:"sequentialNEQ,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "status" field predicates.
	Status      *task.Status  `json:"status,omitempty"`
	StatusNEQ   *task.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []task.Status `json:"statusIn,omitempty"`
	StatusNotIn []task.Status `json:"statusNotIn,omitempty"`

	// "proc_inst" edge predicates.
	HasProcInst     *bool                 `json:"hasProcInst,omitempty"`
	HasProcInstWith []*ProcInstWhereInput `json:"hasProcInstWith,omitempty"`

	// "task_identities" edge predicates.
	HasTaskIdentities     *bool                     `json:"hasTaskIdentities,omitempty"`
	HasTaskIdentitiesWith []*IdentityLinkWhereInput `json:"hasTaskIdentitiesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TaskWhereInput) AddPredicates(predicates ...predicate.Task) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TaskWhereInput filter on the TaskQuery builder.
func (i *TaskWhereInput) Filter(q *TaskQuery) (*TaskQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTaskWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTaskWhereInput is returned in case the TaskWhereInput is empty.
var ErrEmptyTaskWhereInput = errors.New("ent: empty predicate TaskWhereInput")

// P returns a predicate for filtering tasks.
// An error is returned if the input is empty or invalid.
func (i *TaskWhereInput) P() (predicate.Task, error) {
	var predicates []predicate.Task
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, task.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Task, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, task.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Task, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, task.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, task.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, task.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, task.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, task.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, task.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, task.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, task.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, task.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, task.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, task.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, task.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, task.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, task.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, task.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, task.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, task.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.ProcInstID != nil {
		predicates = append(predicates, task.ProcInstIDEQ(*i.ProcInstID))
	}
	if i.ProcInstIDNEQ != nil {
		predicates = append(predicates, task.ProcInstIDNEQ(*i.ProcInstIDNEQ))
	}
	if len(i.ProcInstIDIn) > 0 {
		predicates = append(predicates, task.ProcInstIDIn(i.ProcInstIDIn...))
	}
	if len(i.ProcInstIDNotIn) > 0 {
		predicates = append(predicates, task.ProcInstIDNotIn(i.ProcInstIDNotIn...))
	}
	if i.ProcDefID != nil {
		predicates = append(predicates, task.ProcDefIDEQ(*i.ProcDefID))
	}
	if i.ProcDefIDNEQ != nil {
		predicates = append(predicates, task.ProcDefIDNEQ(*i.ProcDefIDNEQ))
	}
	if len(i.ProcDefIDIn) > 0 {
		predicates = append(predicates, task.ProcDefIDIn(i.ProcDefIDIn...))
	}
	if len(i.ProcDefIDNotIn) > 0 {
		predicates = append(predicates, task.ProcDefIDNotIn(i.ProcDefIDNotIn...))
	}
	if i.ProcDefIDGT != nil {
		predicates = append(predicates, task.ProcDefIDGT(*i.ProcDefIDGT))
	}
	if i.ProcDefIDGTE != nil {
		predicates = append(predicates, task.ProcDefIDGTE(*i.ProcDefIDGTE))
	}
	if i.ProcDefIDLT != nil {
		predicates = append(predicates, task.ProcDefIDLT(*i.ProcDefIDLT))
	}
	if i.ProcDefIDLTE != nil {
		predicates = append(predicates, task.ProcDefIDLTE(*i.ProcDefIDLTE))
	}
	if i.ExecutionID != nil {
		predicates = append(predicates, task.ExecutionIDEQ(*i.ExecutionID))
	}
	if i.ExecutionIDNEQ != nil {
		predicates = append(predicates, task.ExecutionIDNEQ(*i.ExecutionIDNEQ))
	}
	if len(i.ExecutionIDIn) > 0 {
		predicates = append(predicates, task.ExecutionIDIn(i.ExecutionIDIn...))
	}
	if len(i.ExecutionIDNotIn) > 0 {
		predicates = append(predicates, task.ExecutionIDNotIn(i.ExecutionIDNotIn...))
	}
	if i.ExecutionIDGT != nil {
		predicates = append(predicates, task.ExecutionIDGT(*i.ExecutionIDGT))
	}
	if i.ExecutionIDGTE != nil {
		predicates = append(predicates, task.ExecutionIDGTE(*i.ExecutionIDGTE))
	}
	if i.ExecutionIDLT != nil {
		predicates = append(predicates, task.ExecutionIDLT(*i.ExecutionIDLT))
	}
	if i.ExecutionIDLTE != nil {
		predicates = append(predicates, task.ExecutionIDLTE(*i.ExecutionIDLTE))
	}
	if i.ExecutionIDContains != nil {
		predicates = append(predicates, task.ExecutionIDContains(*i.ExecutionIDContains))
	}
	if i.ExecutionIDHasPrefix != nil {
		predicates = append(predicates, task.ExecutionIDHasPrefix(*i.ExecutionIDHasPrefix))
	}
	if i.ExecutionIDHasSuffix != nil {
		predicates = append(predicates, task.ExecutionIDHasSuffix(*i.ExecutionIDHasSuffix))
	}
	if i.ExecutionIDEqualFold != nil {
		predicates = append(predicates, task.ExecutionIDEqualFold(*i.ExecutionIDEqualFold))
	}
	if i.ExecutionIDContainsFold != nil {
		predicates = append(predicates, task.ExecutionIDContainsFold(*i.ExecutionIDContainsFold))
	}
	if i.RunID != nil {
		predicates = append(predicates, task.RunIDEQ(*i.RunID))
	}
	if i.RunIDNEQ != nil {
		predicates = append(predicates, task.RunIDNEQ(*i.RunIDNEQ))
	}
	if len(i.RunIDIn) > 0 {
		predicates = append(predicates, task.RunIDIn(i.RunIDIn...))
	}
	if len(i.RunIDNotIn) > 0 {
		predicates = append(predicates, task.RunIDNotIn(i.RunIDNotIn...))
	}
	if i.RunIDGT != nil {
		predicates = append(predicates, task.RunIDGT(*i.RunIDGT))
	}
	if i.RunIDGTE != nil {
		predicates = append(predicates, task.RunIDGTE(*i.RunIDGTE))
	}
	if i.RunIDLT != nil {
		predicates = append(predicates, task.RunIDLT(*i.RunIDLT))
	}
	if i.RunIDLTE != nil {
		predicates = append(predicates, task.RunIDLTE(*i.RunIDLTE))
	}
	if i.RunIDContains != nil {
		predicates = append(predicates, task.RunIDContains(*i.RunIDContains))
	}
	if i.RunIDHasPrefix != nil {
		predicates = append(predicates, task.RunIDHasPrefix(*i.RunIDHasPrefix))
	}
	if i.RunIDHasSuffix != nil {
		predicates = append(predicates, task.RunIDHasSuffix(*i.RunIDHasSuffix))
	}
	if i.RunIDIsNil {
		predicates = append(predicates, task.RunIDIsNil())
	}
	if i.RunIDNotNil {
		predicates = append(predicates, task.RunIDNotNil())
	}
	if i.RunIDEqualFold != nil {
		predicates = append(predicates, task.RunIDEqualFold(*i.RunIDEqualFold))
	}
	if i.RunIDContainsFold != nil {
		predicates = append(predicates, task.RunIDContainsFold(*i.RunIDContainsFold))
	}
	if i.TaskDefKey != nil {
		predicates = append(predicates, task.TaskDefKeyEQ(*i.TaskDefKey))
	}
	if i.TaskDefKeyNEQ != nil {
		predicates = append(predicates, task.TaskDefKeyNEQ(*i.TaskDefKeyNEQ))
	}
	if len(i.TaskDefKeyIn) > 0 {
		predicates = append(predicates, task.TaskDefKeyIn(i.TaskDefKeyIn...))
	}
	if len(i.TaskDefKeyNotIn) > 0 {
		predicates = append(predicates, task.TaskDefKeyNotIn(i.TaskDefKeyNotIn...))
	}
	if i.TaskDefKeyGT != nil {
		predicates = append(predicates, task.TaskDefKeyGT(*i.TaskDefKeyGT))
	}
	if i.TaskDefKeyGTE != nil {
		predicates = append(predicates, task.TaskDefKeyGTE(*i.TaskDefKeyGTE))
	}
	if i.TaskDefKeyLT != nil {
		predicates = append(predicates, task.TaskDefKeyLT(*i.TaskDefKeyLT))
	}
	if i.TaskDefKeyLTE != nil {
		predicates = append(predicates, task.TaskDefKeyLTE(*i.TaskDefKeyLTE))
	}
	if i.TaskDefKeyContains != nil {
		predicates = append(predicates, task.TaskDefKeyContains(*i.TaskDefKeyContains))
	}
	if i.TaskDefKeyHasPrefix != nil {
		predicates = append(predicates, task.TaskDefKeyHasPrefix(*i.TaskDefKeyHasPrefix))
	}
	if i.TaskDefKeyHasSuffix != nil {
		predicates = append(predicates, task.TaskDefKeyHasSuffix(*i.TaskDefKeyHasSuffix))
	}
	if i.TaskDefKeyEqualFold != nil {
		predicates = append(predicates, task.TaskDefKeyEqualFold(*i.TaskDefKeyEqualFold))
	}
	if i.TaskDefKeyContainsFold != nil {
		predicates = append(predicates, task.TaskDefKeyContainsFold(*i.TaskDefKeyContainsFold))
	}
	if i.ParentID != nil {
		predicates = append(predicates, task.ParentIDEQ(*i.ParentID))
	}
	if i.ParentIDNEQ != nil {
		predicates = append(predicates, task.ParentIDNEQ(*i.ParentIDNEQ))
	}
	if len(i.ParentIDIn) > 0 {
		predicates = append(predicates, task.ParentIDIn(i.ParentIDIn...))
	}
	if len(i.ParentIDNotIn) > 0 {
		predicates = append(predicates, task.ParentIDNotIn(i.ParentIDNotIn...))
	}
	if i.ParentIDGT != nil {
		predicates = append(predicates, task.ParentIDGT(*i.ParentIDGT))
	}
	if i.ParentIDGTE != nil {
		predicates = append(predicates, task.ParentIDGTE(*i.ParentIDGTE))
	}
	if i.ParentIDLT != nil {
		predicates = append(predicates, task.ParentIDLT(*i.ParentIDLT))
	}
	if i.ParentIDLTE != nil {
		predicates = append(predicates, task.ParentIDLTE(*i.ParentIDLTE))
	}
	if i.ParentIDIsNil {
		predicates = append(predicates, task.ParentIDIsNil())
	}
	if i.ParentIDNotNil {
		predicates = append(predicates, task.ParentIDNotNil())
	}
	if i.Assignee != nil {
		predicates = append(predicates, task.AssigneeEQ(*i.Assignee))
	}
	if i.AssigneeNEQ != nil {
		predicates = append(predicates, task.AssigneeNEQ(*i.AssigneeNEQ))
	}
	if len(i.AssigneeIn) > 0 {
		predicates = append(predicates, task.AssigneeIn(i.AssigneeIn...))
	}
	if len(i.AssigneeNotIn) > 0 {
		predicates = append(predicates, task.AssigneeNotIn(i.AssigneeNotIn...))
	}
	if i.AssigneeGT != nil {
		predicates = append(predicates, task.AssigneeGT(*i.AssigneeGT))
	}
	if i.AssigneeGTE != nil {
		predicates = append(predicates, task.AssigneeGTE(*i.AssigneeGTE))
	}
	if i.AssigneeLT != nil {
		predicates = append(predicates, task.AssigneeLT(*i.AssigneeLT))
	}
	if i.AssigneeLTE != nil {
		predicates = append(predicates, task.AssigneeLTE(*i.AssigneeLTE))
	}
	if i.AssigneeContains != nil {
		predicates = append(predicates, task.AssigneeContains(*i.AssigneeContains))
	}
	if i.AssigneeHasPrefix != nil {
		predicates = append(predicates, task.AssigneeHasPrefix(*i.AssigneeHasPrefix))
	}
	if i.AssigneeHasSuffix != nil {
		predicates = append(predicates, task.AssigneeHasSuffix(*i.AssigneeHasSuffix))
	}
	if i.AssigneeIsNil {
		predicates = append(predicates, task.AssigneeIsNil())
	}
	if i.AssigneeNotNil {
		predicates = append(predicates, task.AssigneeNotNil())
	}
	if i.AssigneeEqualFold != nil {
		predicates = append(predicates, task.AssigneeEqualFold(*i.AssigneeEqualFold))
	}
	if i.AssigneeContainsFold != nil {
		predicates = append(predicates, task.AssigneeContainsFold(*i.AssigneeContainsFold))
	}
	if i.MemberCount != nil {
		predicates = append(predicates, task.MemberCountEQ(*i.MemberCount))
	}
	if i.MemberCountNEQ != nil {
		predicates = append(predicates, task.MemberCountNEQ(*i.MemberCountNEQ))
	}
	if len(i.MemberCountIn) > 0 {
		predicates = append(predicates, task.MemberCountIn(i.MemberCountIn...))
	}
	if len(i.MemberCountNotIn) > 0 {
		predicates = append(predicates, task.MemberCountNotIn(i.MemberCountNotIn...))
	}
	if i.MemberCountGT != nil {
		predicates = append(predicates, task.MemberCountGT(*i.MemberCountGT))
	}
	if i.MemberCountGTE != nil {
		predicates = append(predicates, task.MemberCountGTE(*i.MemberCountGTE))
	}
	if i.MemberCountLT != nil {
		predicates = append(predicates, task.MemberCountLT(*i.MemberCountLT))
	}
	if i.MemberCountLTE != nil {
		predicates = append(predicates, task.MemberCountLTE(*i.MemberCountLTE))
	}
	if i.UnfinishedCount != nil {
		predicates = append(predicates, task.UnfinishedCountEQ(*i.UnfinishedCount))
	}
	if i.UnfinishedCountNEQ != nil {
		predicates = append(predicates, task.UnfinishedCountNEQ(*i.UnfinishedCountNEQ))
	}
	if len(i.UnfinishedCountIn) > 0 {
		predicates = append(predicates, task.UnfinishedCountIn(i.UnfinishedCountIn...))
	}
	if len(i.UnfinishedCountNotIn) > 0 {
		predicates = append(predicates, task.UnfinishedCountNotIn(i.UnfinishedCountNotIn...))
	}
	if i.UnfinishedCountGT != nil {
		predicates = append(predicates, task.UnfinishedCountGT(*i.UnfinishedCountGT))
	}
	if i.UnfinishedCountGTE != nil {
		predicates = append(predicates, task.UnfinishedCountGTE(*i.UnfinishedCountGTE))
	}
	if i.UnfinishedCountLT != nil {
		predicates = append(predicates, task.UnfinishedCountLT(*i.UnfinishedCountLT))
	}
	if i.UnfinishedCountLTE != nil {
		predicates = append(predicates, task.UnfinishedCountLTE(*i.UnfinishedCountLTE))
	}
	if i.AgreeCount != nil {
		predicates = append(predicates, task.AgreeCountEQ(*i.AgreeCount))
	}
	if i.AgreeCountNEQ != nil {
		predicates = append(predicates, task.AgreeCountNEQ(*i.AgreeCountNEQ))
	}
	if len(i.AgreeCountIn) > 0 {
		predicates = append(predicates, task.AgreeCountIn(i.AgreeCountIn...))
	}
	if len(i.AgreeCountNotIn) > 0 {
		predicates = append(predicates, task.AgreeCountNotIn(i.AgreeCountNotIn...))
	}
	if i.AgreeCountGT != nil {
		predicates = append(predicates, task.AgreeCountGT(*i.AgreeCountGT))
	}
	if i.AgreeCountGTE != nil {
		predicates = append(predicates, task.AgreeCountGTE(*i.AgreeCountGTE))
	}
	if i.AgreeCountLT != nil {
		predicates = append(predicates, task.AgreeCountLT(*i.AgreeCountLT))
	}
	if i.AgreeCountLTE != nil {
		predicates = append(predicates, task.AgreeCountLTE(*i.AgreeCountLTE))
	}
	if i.Kind != nil {
		predicates = append(predicates, task.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, task.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, task.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, task.KindNotIn(i.KindNotIn...))
	}
	if i.Sequential != nil {
		predicates = append(predicates, task.SequentialEQ(*i.Sequential))
	}
	if i.SequentialNEQ != nil {
		predicates = append(predicates, task.SequentialNEQ(*i.SequentialNEQ))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, task.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, task.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, task.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, task.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, task.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, task.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, task.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, task.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, task.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, task.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, task.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, task.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, task.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, task.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, task.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, task.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, task.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, task.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, task.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, task.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasProcInst != nil {
		p := task.HasProcInst()
		if !*i.HasProcInst {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProcInstWith) > 0 {
		with := make([]predicate.ProcInst, 0, len(i.HasProcInstWith))
		for _, w := range i.HasProcInstWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProcInstWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasProcInstWith(with...))
	}
	if i.HasTaskIdentities != nil {
		p := task.HasTaskIdentities()
		if !*i.HasTaskIdentities {
			p = task.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTaskIdentitiesWith) > 0 {
		with := make([]predicate.IdentityLink, 0, len(i.HasTaskIdentitiesWith))
		for _, w := range i.HasTaskIdentitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTaskIdentitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, task.HasTaskIdentitiesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTaskWhereInput
	case 1:
		return predicates[0], nil
	default:
		return task.And(predicates...), nil
	}
}
