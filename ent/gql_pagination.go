// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/woocoos/entco/pkg/pagination"
	"github.com/woocoos/workflow/ent/decisiondef"
	"github.com/woocoos/workflow/ent/decisionreqdef"
	"github.com/woocoos/workflow/ent/deployment"
	"github.com/woocoos/workflow/ent/identitylink"
	"github.com/woocoos/workflow/ent/orgrole"
	"github.com/woocoos/workflow/ent/orguser"
	"github.com/woocoos/workflow/ent/procdef"
	"github.com/woocoos/workflow/ent/procinst"
	"github.com/woocoos/workflow/ent/task"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// DecisionDefEdge is the edge representation of DecisionDef.
type DecisionDefEdge struct {
	Node   *DecisionDef `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// DecisionDefConnection is the connection containing edges to DecisionDef.
type DecisionDefConnection struct {
	Edges      []*DecisionDefEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *DecisionDefConnection) build(nodes []*DecisionDef, pager *decisiondefPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DecisionDef
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DecisionDef {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DecisionDef {
			return nodes[i]
		}
	}
	c.Edges = make([]*DecisionDefEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DecisionDefEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DecisionDefPaginateOption enables pagination customization.
type DecisionDefPaginateOption func(*decisiondefPager) error

// WithDecisionDefOrder configures pagination ordering.
func WithDecisionDefOrder(order *DecisionDefOrder) DecisionDefPaginateOption {
	if order == nil {
		order = DefaultDecisionDefOrder
	}
	o := *order
	return func(pager *decisiondefPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDecisionDefOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDecisionDefFilter configures pagination filter.
func WithDecisionDefFilter(filter func(*DecisionDefQuery) (*DecisionDefQuery, error)) DecisionDefPaginateOption {
	return func(pager *decisiondefPager) error {
		if filter == nil {
			return errors.New("DecisionDefQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type decisiondefPager struct {
	reverse bool
	order   *DecisionDefOrder
	filter  func(*DecisionDefQuery) (*DecisionDefQuery, error)
}

func newDecisionDefPager(opts []DecisionDefPaginateOption, reverse bool) (*decisiondefPager, error) {
	pager := &decisiondefPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDecisionDefOrder
	}
	return pager, nil
}

func (p *decisiondefPager) applyFilter(query *DecisionDefQuery) (*DecisionDefQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *decisiondefPager) toCursor(dd *DecisionDef) Cursor {
	return p.order.Field.toCursor(dd)
}

func (p *decisiondefPager) applyCursors(query *DecisionDefQuery, after, before *Cursor) (*DecisionDefQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDecisionDefOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *decisiondefPager) applyOrder(query *DecisionDefQuery) *DecisionDefQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDecisionDefOrder.Field {
		query = query.Order(DefaultDecisionDefOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *decisiondefPager) orderExpr(query *DecisionDefQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDecisionDefOrder.Field {
			b.Comma().Ident(DefaultDecisionDefOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DecisionDef.
func (dd *DecisionDefQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DecisionDefPaginateOption,
) (*DecisionDefConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDecisionDefPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dd, err = pager.applyFilter(dd); err != nil {
		return nil, err
	}
	conn := &DecisionDefConnection{Edges: []*DecisionDefEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dd, err = pager.applyCursors(dd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		dd.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			dd.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			dd.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dd = pager.applyOrder(dd)
	nodes, err := dd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DecisionDefOrderFieldCreatedAt orders DecisionDef by created_at.
	DecisionDefOrderFieldCreatedAt = &DecisionDefOrderField{
		Value: func(dd *DecisionDef) (ent.Value, error) {
			return dd.CreatedAt, nil
		},
		column: decisiondef.FieldCreatedAt,
		toTerm: decisiondef.ByCreatedAt,
		toCursor: func(dd *DecisionDef) Cursor {
			return Cursor{
				ID:    dd.ID,
				Value: dd.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DecisionDefOrderField) String() string {
	var str string
	switch f.column {
	case DecisionDefOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DecisionDefOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DecisionDefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DecisionDefOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *DecisionDefOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid DecisionDefOrderField", str)
	}
	return nil
}

// DecisionDefOrderField defines the ordering field of DecisionDef.
type DecisionDefOrderField struct {
	// Value extracts the ordering value from the given DecisionDef.
	Value    func(*DecisionDef) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) decisiondef.OrderOption
	toCursor func(*DecisionDef) Cursor
}

// DecisionDefOrder defines the ordering of DecisionDef.
type DecisionDefOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *DecisionDefOrderField `json:"field"`
}

// DefaultDecisionDefOrder is the default ordering of DecisionDef.
var DefaultDecisionDefOrder = &DecisionDefOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DecisionDefOrderField{
		Value: func(dd *DecisionDef) (ent.Value, error) {
			return dd.ID, nil
		},
		column: decisiondef.FieldID,
		toTerm: decisiondef.ByID,
		toCursor: func(dd *DecisionDef) Cursor {
			return Cursor{ID: dd.ID}
		},
	},
}

// ToEdge converts DecisionDef into DecisionDefEdge.
func (dd *DecisionDef) ToEdge(order *DecisionDefOrder) *DecisionDefEdge {
	if order == nil {
		order = DefaultDecisionDefOrder
	}
	return &DecisionDefEdge{
		Node:   dd,
		Cursor: order.Field.toCursor(dd),
	}
}

// DecisionReqDefEdge is the edge representation of DecisionReqDef.
type DecisionReqDefEdge struct {
	Node   *DecisionReqDef `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// DecisionReqDefConnection is the connection containing edges to DecisionReqDef.
type DecisionReqDefConnection struct {
	Edges      []*DecisionReqDefEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *DecisionReqDefConnection) build(nodes []*DecisionReqDef, pager *decisionreqdefPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DecisionReqDef
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DecisionReqDef {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DecisionReqDef {
			return nodes[i]
		}
	}
	c.Edges = make([]*DecisionReqDefEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DecisionReqDefEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DecisionReqDefPaginateOption enables pagination customization.
type DecisionReqDefPaginateOption func(*decisionreqdefPager) error

// WithDecisionReqDefOrder configures pagination ordering.
func WithDecisionReqDefOrder(order *DecisionReqDefOrder) DecisionReqDefPaginateOption {
	if order == nil {
		order = DefaultDecisionReqDefOrder
	}
	o := *order
	return func(pager *decisionreqdefPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDecisionReqDefOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDecisionReqDefFilter configures pagination filter.
func WithDecisionReqDefFilter(filter func(*DecisionReqDefQuery) (*DecisionReqDefQuery, error)) DecisionReqDefPaginateOption {
	return func(pager *decisionreqdefPager) error {
		if filter == nil {
			return errors.New("DecisionReqDefQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type decisionreqdefPager struct {
	reverse bool
	order   *DecisionReqDefOrder
	filter  func(*DecisionReqDefQuery) (*DecisionReqDefQuery, error)
}

func newDecisionReqDefPager(opts []DecisionReqDefPaginateOption, reverse bool) (*decisionreqdefPager, error) {
	pager := &decisionreqdefPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDecisionReqDefOrder
	}
	return pager, nil
}

func (p *decisionreqdefPager) applyFilter(query *DecisionReqDefQuery) (*DecisionReqDefQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *decisionreqdefPager) toCursor(drd *DecisionReqDef) Cursor {
	return p.order.Field.toCursor(drd)
}

func (p *decisionreqdefPager) applyCursors(query *DecisionReqDefQuery, after, before *Cursor) (*DecisionReqDefQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDecisionReqDefOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *decisionreqdefPager) applyOrder(query *DecisionReqDefQuery) *DecisionReqDefQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDecisionReqDefOrder.Field {
		query = query.Order(DefaultDecisionReqDefOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *decisionreqdefPager) orderExpr(query *DecisionReqDefQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDecisionReqDefOrder.Field {
			b.Comma().Ident(DefaultDecisionReqDefOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DecisionReqDef.
func (drd *DecisionReqDefQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DecisionReqDefPaginateOption,
) (*DecisionReqDefConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDecisionReqDefPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if drd, err = pager.applyFilter(drd); err != nil {
		return nil, err
	}
	conn := &DecisionReqDefConnection{Edges: []*DecisionReqDefEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := drd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if drd, err = pager.applyCursors(drd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		drd.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			drd.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			drd.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := drd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	drd = pager.applyOrder(drd)
	nodes, err := drd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DecisionReqDefOrderFieldCreatedAt orders DecisionReqDef by created_at.
	DecisionReqDefOrderFieldCreatedAt = &DecisionReqDefOrderField{
		Value: func(drd *DecisionReqDef) (ent.Value, error) {
			return drd.CreatedAt, nil
		},
		column: decisionreqdef.FieldCreatedAt,
		toTerm: decisionreqdef.ByCreatedAt,
		toCursor: func(drd *DecisionReqDef) Cursor {
			return Cursor{
				ID:    drd.ID,
				Value: drd.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DecisionReqDefOrderField) String() string {
	var str string
	switch f.column {
	case DecisionReqDefOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DecisionReqDefOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DecisionReqDefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DecisionReqDefOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *DecisionReqDefOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid DecisionReqDefOrderField", str)
	}
	return nil
}

// DecisionReqDefOrderField defines the ordering field of DecisionReqDef.
type DecisionReqDefOrderField struct {
	// Value extracts the ordering value from the given DecisionReqDef.
	Value    func(*DecisionReqDef) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) decisionreqdef.OrderOption
	toCursor func(*DecisionReqDef) Cursor
}

// DecisionReqDefOrder defines the ordering of DecisionReqDef.
type DecisionReqDefOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *DecisionReqDefOrderField `json:"field"`
}

// DefaultDecisionReqDefOrder is the default ordering of DecisionReqDef.
var DefaultDecisionReqDefOrder = &DecisionReqDefOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DecisionReqDefOrderField{
		Value: func(drd *DecisionReqDef) (ent.Value, error) {
			return drd.ID, nil
		},
		column: decisionreqdef.FieldID,
		toTerm: decisionreqdef.ByID,
		toCursor: func(drd *DecisionReqDef) Cursor {
			return Cursor{ID: drd.ID}
		},
	},
}

// ToEdge converts DecisionReqDef into DecisionReqDefEdge.
func (drd *DecisionReqDef) ToEdge(order *DecisionReqDefOrder) *DecisionReqDefEdge {
	if order == nil {
		order = DefaultDecisionReqDefOrder
	}
	return &DecisionReqDefEdge{
		Node:   drd,
		Cursor: order.Field.toCursor(drd),
	}
}

// DeploymentEdge is the edge representation of Deployment.
type DeploymentEdge struct {
	Node   *Deployment `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// DeploymentConnection is the connection containing edges to Deployment.
type DeploymentConnection struct {
	Edges      []*DeploymentEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *DeploymentConnection) build(nodes []*Deployment, pager *deploymentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Deployment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Deployment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Deployment {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeploymentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeploymentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeploymentPaginateOption enables pagination customization.
type DeploymentPaginateOption func(*deploymentPager) error

// WithDeploymentOrder configures pagination ordering.
func WithDeploymentOrder(order *DeploymentOrder) DeploymentPaginateOption {
	if order == nil {
		order = DefaultDeploymentOrder
	}
	o := *order
	return func(pager *deploymentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeploymentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeploymentFilter configures pagination filter.
func WithDeploymentFilter(filter func(*DeploymentQuery) (*DeploymentQuery, error)) DeploymentPaginateOption {
	return func(pager *deploymentPager) error {
		if filter == nil {
			return errors.New("DeploymentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deploymentPager struct {
	reverse bool
	order   *DeploymentOrder
	filter  func(*DeploymentQuery) (*DeploymentQuery, error)
}

func newDeploymentPager(opts []DeploymentPaginateOption, reverse bool) (*deploymentPager, error) {
	pager := &deploymentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeploymentOrder
	}
	return pager, nil
}

func (p *deploymentPager) applyFilter(query *DeploymentQuery) (*DeploymentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deploymentPager) toCursor(d *Deployment) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *deploymentPager) applyCursors(query *DeploymentQuery, after, before *Cursor) (*DeploymentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeploymentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deploymentPager) applyOrder(query *DeploymentQuery) *DeploymentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeploymentOrder.Field {
		query = query.Order(DefaultDeploymentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deploymentPager) orderExpr(query *DeploymentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeploymentOrder.Field {
			b.Comma().Ident(DefaultDeploymentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Deployment.
func (d *DeploymentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeploymentPaginateOption,
) (*DeploymentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeploymentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DeploymentConnection{Edges: []*DeploymentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := d.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			d.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			d.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DeploymentOrderFieldCreatedAt orders Deployment by created_at.
	DeploymentOrderFieldCreatedAt = &DeploymentOrderField{
		Value: func(d *Deployment) (ent.Value, error) {
			return d.CreatedAt, nil
		},
		column: deployment.FieldCreatedAt,
		toTerm: deployment.ByCreatedAt,
		toCursor: func(d *Deployment) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DeploymentOrderField) String() string {
	var str string
	switch f.column {
	case DeploymentOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DeploymentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DeploymentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DeploymentOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *DeploymentOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid DeploymentOrderField", str)
	}
	return nil
}

// DeploymentOrderField defines the ordering field of Deployment.
type DeploymentOrderField struct {
	// Value extracts the ordering value from the given Deployment.
	Value    func(*Deployment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deployment.OrderOption
	toCursor func(*Deployment) Cursor
}

// DeploymentOrder defines the ordering of Deployment.
type DeploymentOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *DeploymentOrderField `json:"field"`
}

// DefaultDeploymentOrder is the default ordering of Deployment.
var DefaultDeploymentOrder = &DeploymentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeploymentOrderField{
		Value: func(d *Deployment) (ent.Value, error) {
			return d.ID, nil
		},
		column: deployment.FieldID,
		toTerm: deployment.ByID,
		toCursor: func(d *Deployment) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Deployment into DeploymentEdge.
func (d *Deployment) ToEdge(order *DeploymentOrder) *DeploymentEdge {
	if order == nil {
		order = DefaultDeploymentOrder
	}
	return &DeploymentEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// IdentityLinkEdge is the edge representation of IdentityLink.
type IdentityLinkEdge struct {
	Node   *IdentityLink `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// IdentityLinkConnection is the connection containing edges to IdentityLink.
type IdentityLinkConnection struct {
	Edges      []*IdentityLinkEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *IdentityLinkConnection) build(nodes []*IdentityLink, pager *identitylinkPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *IdentityLink
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IdentityLink {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IdentityLink {
			return nodes[i]
		}
	}
	c.Edges = make([]*IdentityLinkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IdentityLinkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IdentityLinkPaginateOption enables pagination customization.
type IdentityLinkPaginateOption func(*identitylinkPager) error

// WithIdentityLinkOrder configures pagination ordering.
func WithIdentityLinkOrder(order *IdentityLinkOrder) IdentityLinkPaginateOption {
	if order == nil {
		order = DefaultIdentityLinkOrder
	}
	o := *order
	return func(pager *identitylinkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIdentityLinkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIdentityLinkFilter configures pagination filter.
func WithIdentityLinkFilter(filter func(*IdentityLinkQuery) (*IdentityLinkQuery, error)) IdentityLinkPaginateOption {
	return func(pager *identitylinkPager) error {
		if filter == nil {
			return errors.New("IdentityLinkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type identitylinkPager struct {
	reverse bool
	order   *IdentityLinkOrder
	filter  func(*IdentityLinkQuery) (*IdentityLinkQuery, error)
}

func newIdentityLinkPager(opts []IdentityLinkPaginateOption, reverse bool) (*identitylinkPager, error) {
	pager := &identitylinkPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIdentityLinkOrder
	}
	return pager, nil
}

func (p *identitylinkPager) applyFilter(query *IdentityLinkQuery) (*IdentityLinkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *identitylinkPager) toCursor(il *IdentityLink) Cursor {
	return p.order.Field.toCursor(il)
}

func (p *identitylinkPager) applyCursors(query *IdentityLinkQuery, after, before *Cursor) (*IdentityLinkQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIdentityLinkOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *identitylinkPager) applyOrder(query *IdentityLinkQuery) *IdentityLinkQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIdentityLinkOrder.Field {
		query = query.Order(DefaultIdentityLinkOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *identitylinkPager) orderExpr(query *IdentityLinkQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIdentityLinkOrder.Field {
			b.Comma().Ident(DefaultIdentityLinkOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to IdentityLink.
func (il *IdentityLinkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IdentityLinkPaginateOption,
) (*IdentityLinkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIdentityLinkPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if il, err = pager.applyFilter(il); err != nil {
		return nil, err
	}
	conn := &IdentityLinkConnection{Edges: []*IdentityLinkEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := il.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if il, err = pager.applyCursors(il, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		il.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			il.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			il.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := il.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	il = pager.applyOrder(il)
	nodes, err := il.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// IdentityLinkOrderField defines the ordering field of IdentityLink.
type IdentityLinkOrderField struct {
	// Value extracts the ordering value from the given IdentityLink.
	Value    func(*IdentityLink) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) identitylink.OrderOption
	toCursor func(*IdentityLink) Cursor
}

// IdentityLinkOrder defines the ordering of IdentityLink.
type IdentityLinkOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *IdentityLinkOrderField `json:"field"`
}

// DefaultIdentityLinkOrder is the default ordering of IdentityLink.
var DefaultIdentityLinkOrder = &IdentityLinkOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IdentityLinkOrderField{
		Value: func(il *IdentityLink) (ent.Value, error) {
			return il.ID, nil
		},
		column: identitylink.FieldID,
		toTerm: identitylink.ByID,
		toCursor: func(il *IdentityLink) Cursor {
			return Cursor{ID: il.ID}
		},
	},
}

// ToEdge converts IdentityLink into IdentityLinkEdge.
func (il *IdentityLink) ToEdge(order *IdentityLinkOrder) *IdentityLinkEdge {
	if order == nil {
		order = DefaultIdentityLinkOrder
	}
	return &IdentityLinkEdge{
		Node:   il,
		Cursor: order.Field.toCursor(il),
	}
}

// OrgRoleEdge is the edge representation of OrgRole.
type OrgRoleEdge struct {
	Node   *OrgRole `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// OrgRoleConnection is the connection containing edges to OrgRole.
type OrgRoleConnection struct {
	Edges      []*OrgRoleEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *OrgRoleConnection) build(nodes []*OrgRole, pager *orgrolePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrgRole
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgRole {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgRole {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgRoleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgRoleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgRolePaginateOption enables pagination customization.
type OrgRolePaginateOption func(*orgrolePager) error

// WithOrgRoleOrder configures pagination ordering.
func WithOrgRoleOrder(order *OrgRoleOrder) OrgRolePaginateOption {
	if order == nil {
		order = DefaultOrgRoleOrder
	}
	o := *order
	return func(pager *orgrolePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgRoleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgRoleFilter configures pagination filter.
func WithOrgRoleFilter(filter func(*OrgRoleQuery) (*OrgRoleQuery, error)) OrgRolePaginateOption {
	return func(pager *orgrolePager) error {
		if filter == nil {
			return errors.New("OrgRoleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orgrolePager struct {
	reverse bool
	order   *OrgRoleOrder
	filter  func(*OrgRoleQuery) (*OrgRoleQuery, error)
}

func newOrgRolePager(opts []OrgRolePaginateOption, reverse bool) (*orgrolePager, error) {
	pager := &orgrolePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgRoleOrder
	}
	return pager, nil
}

func (p *orgrolePager) applyFilter(query *OrgRoleQuery) (*OrgRoleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orgrolePager) toCursor(or *OrgRole) Cursor {
	return p.order.Field.toCursor(or)
}

func (p *orgrolePager) applyCursors(query *OrgRoleQuery, after, before *Cursor) (*OrgRoleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgRoleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orgrolePager) applyOrder(query *OrgRoleQuery) *OrgRoleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgRoleOrder.Field {
		query = query.Order(DefaultOrgRoleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orgrolePager) orderExpr(query *OrgRoleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgRoleOrder.Field {
			b.Comma().Ident(DefaultOrgRoleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgRole.
func (or *OrgRoleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgRolePaginateOption,
) (*OrgRoleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgRolePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if or, err = pager.applyFilter(or); err != nil {
		return nil, err
	}
	conn := &OrgRoleConnection{Edges: []*OrgRoleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := or.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if or, err = pager.applyCursors(or, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		or.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			or.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			or.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := or.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	or = pager.applyOrder(or)
	nodes, err := or.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrgRoleOrderField defines the ordering field of OrgRole.
type OrgRoleOrderField struct {
	// Value extracts the ordering value from the given OrgRole.
	Value    func(*OrgRole) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orgrole.OrderOption
	toCursor func(*OrgRole) Cursor
}

// OrgRoleOrder defines the ordering of OrgRole.
type OrgRoleOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *OrgRoleOrderField `json:"field"`
}

// DefaultOrgRoleOrder is the default ordering of OrgRole.
var DefaultOrgRoleOrder = &OrgRoleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgRoleOrderField{
		Value: func(or *OrgRole) (ent.Value, error) {
			return or.ID, nil
		},
		column: orgrole.FieldID,
		toTerm: orgrole.ByID,
		toCursor: func(or *OrgRole) Cursor {
			return Cursor{ID: or.ID}
		},
	},
}

// ToEdge converts OrgRole into OrgRoleEdge.
func (or *OrgRole) ToEdge(order *OrgRoleOrder) *OrgRoleEdge {
	if order == nil {
		order = DefaultOrgRoleOrder
	}
	return &OrgRoleEdge{
		Node:   or,
		Cursor: order.Field.toCursor(or),
	}
}

// OrgUserEdge is the edge representation of OrgUser.
type OrgUserEdge struct {
	Node   *OrgUser `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// OrgUserConnection is the connection containing edges to OrgUser.
type OrgUserConnection struct {
	Edges      []*OrgUserEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *OrgUserConnection) build(nodes []*OrgUser, pager *orguserPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrgUser
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrgUser {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrgUser {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrgUserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrgUserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrgUserPaginateOption enables pagination customization.
type OrgUserPaginateOption func(*orguserPager) error

// WithOrgUserOrder configures pagination ordering.
func WithOrgUserOrder(order *OrgUserOrder) OrgUserPaginateOption {
	if order == nil {
		order = DefaultOrgUserOrder
	}
	o := *order
	return func(pager *orguserPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrgUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrgUserFilter configures pagination filter.
func WithOrgUserFilter(filter func(*OrgUserQuery) (*OrgUserQuery, error)) OrgUserPaginateOption {
	return func(pager *orguserPager) error {
		if filter == nil {
			return errors.New("OrgUserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orguserPager struct {
	reverse bool
	order   *OrgUserOrder
	filter  func(*OrgUserQuery) (*OrgUserQuery, error)
}

func newOrgUserPager(opts []OrgUserPaginateOption, reverse bool) (*orguserPager, error) {
	pager := &orguserPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrgUserOrder
	}
	return pager, nil
}

func (p *orguserPager) applyFilter(query *OrgUserQuery) (*OrgUserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orguserPager) toCursor(ou *OrgUser) Cursor {
	return p.order.Field.toCursor(ou)
}

func (p *orguserPager) applyCursors(query *OrgUserQuery, after, before *Cursor) (*OrgUserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrgUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orguserPager) applyOrder(query *OrgUserQuery) *OrgUserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrgUserOrder.Field {
		query = query.Order(DefaultOrgUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orguserPager) orderExpr(query *OrgUserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrgUserOrder.Field {
			b.Comma().Ident(DefaultOrgUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrgUser.
func (ou *OrgUserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrgUserPaginateOption,
) (*OrgUserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrgUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ou, err = pager.applyFilter(ou); err != nil {
		return nil, err
	}
	conn := &OrgUserConnection{Edges: []*OrgUserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ou.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ou, err = pager.applyCursors(ou, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ou.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			ou.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			ou.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ou.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ou = pager.applyOrder(ou)
	nodes, err := ou.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrgUserOrderField defines the ordering field of OrgUser.
type OrgUserOrderField struct {
	// Value extracts the ordering value from the given OrgUser.
	Value    func(*OrgUser) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orguser.OrderOption
	toCursor func(*OrgUser) Cursor
}

// OrgUserOrder defines the ordering of OrgUser.
type OrgUserOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *OrgUserOrderField `json:"field"`
}

// DefaultOrgUserOrder is the default ordering of OrgUser.
var DefaultOrgUserOrder = &OrgUserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrgUserOrderField{
		Value: func(ou *OrgUser) (ent.Value, error) {
			return ou.ID, nil
		},
		column: orguser.FieldID,
		toTerm: orguser.ByID,
		toCursor: func(ou *OrgUser) Cursor {
			return Cursor{ID: ou.ID}
		},
	},
}

// ToEdge converts OrgUser into OrgUserEdge.
func (ou *OrgUser) ToEdge(order *OrgUserOrder) *OrgUserEdge {
	if order == nil {
		order = DefaultOrgUserOrder
	}
	return &OrgUserEdge{
		Node:   ou,
		Cursor: order.Field.toCursor(ou),
	}
}

// ProcDefEdge is the edge representation of ProcDef.
type ProcDefEdge struct {
	Node   *ProcDef `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProcDefConnection is the connection containing edges to ProcDef.
type ProcDefConnection struct {
	Edges      []*ProcDefEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProcDefConnection) build(nodes []*ProcDef, pager *procdefPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProcDef
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProcDef {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProcDef {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcDefEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcDefEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcDefPaginateOption enables pagination customization.
type ProcDefPaginateOption func(*procdefPager) error

// WithProcDefOrder configures pagination ordering.
func WithProcDefOrder(order *ProcDefOrder) ProcDefPaginateOption {
	if order == nil {
		order = DefaultProcDefOrder
	}
	o := *order
	return func(pager *procdefPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProcDefOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProcDefFilter configures pagination filter.
func WithProcDefFilter(filter func(*ProcDefQuery) (*ProcDefQuery, error)) ProcDefPaginateOption {
	return func(pager *procdefPager) error {
		if filter == nil {
			return errors.New("ProcDefQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procdefPager struct {
	reverse bool
	order   *ProcDefOrder
	filter  func(*ProcDefQuery) (*ProcDefQuery, error)
}

func newProcDefPager(opts []ProcDefPaginateOption, reverse bool) (*procdefPager, error) {
	pager := &procdefPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProcDefOrder
	}
	return pager, nil
}

func (p *procdefPager) applyFilter(query *ProcDefQuery) (*ProcDefQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procdefPager) toCursor(pd *ProcDef) Cursor {
	return p.order.Field.toCursor(pd)
}

func (p *procdefPager) applyCursors(query *ProcDefQuery, after, before *Cursor) (*ProcDefQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProcDefOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *procdefPager) applyOrder(query *ProcDefQuery) *ProcDefQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProcDefOrder.Field {
		query = query.Order(DefaultProcDefOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *procdefPager) orderExpr(query *ProcDefQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProcDefOrder.Field {
			b.Comma().Ident(DefaultProcDefOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProcDef.
func (pd *ProcDefQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcDefPaginateOption,
) (*ProcDefConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcDefPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pd, err = pager.applyFilter(pd); err != nil {
		return nil, err
	}
	conn := &ProcDefConnection{Edges: []*ProcDefEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pd, err = pager.applyCursors(pd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pd.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			pd.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			pd.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pd = pager.applyOrder(pd)
	nodes, err := pd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcDefOrderFieldCreatedAt orders ProcDef by created_at.
	ProcDefOrderFieldCreatedAt = &ProcDefOrderField{
		Value: func(pd *ProcDef) (ent.Value, error) {
			return pd.CreatedAt, nil
		},
		column: procdef.FieldCreatedAt,
		toTerm: procdef.ByCreatedAt,
		toCursor: func(pd *ProcDef) Cursor {
			return Cursor{
				ID:    pd.ID,
				Value: pd.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcDefOrderField) String() string {
	var str string
	switch f.column {
	case ProcDefOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcDefOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcDefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcDefOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *ProcDefOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ProcDefOrderField", str)
	}
	return nil
}

// ProcDefOrderField defines the ordering field of ProcDef.
type ProcDefOrderField struct {
	// Value extracts the ordering value from the given ProcDef.
	Value    func(*ProcDef) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procdef.OrderOption
	toCursor func(*ProcDef) Cursor
}

// ProcDefOrder defines the ordering of ProcDef.
type ProcDefOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProcDefOrderField `json:"field"`
}

// DefaultProcDefOrder is the default ordering of ProcDef.
var DefaultProcDefOrder = &ProcDefOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcDefOrderField{
		Value: func(pd *ProcDef) (ent.Value, error) {
			return pd.ID, nil
		},
		column: procdef.FieldID,
		toTerm: procdef.ByID,
		toCursor: func(pd *ProcDef) Cursor {
			return Cursor{ID: pd.ID}
		},
	},
}

// ToEdge converts ProcDef into ProcDefEdge.
func (pd *ProcDef) ToEdge(order *ProcDefOrder) *ProcDefEdge {
	if order == nil {
		order = DefaultProcDefOrder
	}
	return &ProcDefEdge{
		Node:   pd,
		Cursor: order.Field.toCursor(pd),
	}
}

// ProcInstEdge is the edge representation of ProcInst.
type ProcInstEdge struct {
	Node   *ProcInst `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ProcInstConnection is the connection containing edges to ProcInst.
type ProcInstConnection struct {
	Edges      []*ProcInstEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ProcInstConnection) build(nodes []*ProcInst, pager *procinstPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProcInst
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProcInst {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProcInst {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProcInstEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProcInstEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProcInstPaginateOption enables pagination customization.
type ProcInstPaginateOption func(*procinstPager) error

// WithProcInstOrder configures pagination ordering.
func WithProcInstOrder(order *ProcInstOrder) ProcInstPaginateOption {
	if order == nil {
		order = DefaultProcInstOrder
	}
	o := *order
	return func(pager *procinstPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProcInstOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProcInstFilter configures pagination filter.
func WithProcInstFilter(filter func(*ProcInstQuery) (*ProcInstQuery, error)) ProcInstPaginateOption {
	return func(pager *procinstPager) error {
		if filter == nil {
			return errors.New("ProcInstQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type procinstPager struct {
	reverse bool
	order   *ProcInstOrder
	filter  func(*ProcInstQuery) (*ProcInstQuery, error)
}

func newProcInstPager(opts []ProcInstPaginateOption, reverse bool) (*procinstPager, error) {
	pager := &procinstPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProcInstOrder
	}
	return pager, nil
}

func (p *procinstPager) applyFilter(query *ProcInstQuery) (*ProcInstQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *procinstPager) toCursor(pi *ProcInst) Cursor {
	return p.order.Field.toCursor(pi)
}

func (p *procinstPager) applyCursors(query *ProcInstQuery, after, before *Cursor) (*ProcInstQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProcInstOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *procinstPager) applyOrder(query *ProcInstQuery) *ProcInstQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProcInstOrder.Field {
		query = query.Order(DefaultProcInstOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *procinstPager) orderExpr(query *ProcInstQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProcInstOrder.Field {
			b.Comma().Ident(DefaultProcInstOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProcInst.
func (pi *ProcInstQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProcInstPaginateOption,
) (*ProcInstConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProcInstPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pi, err = pager.applyFilter(pi); err != nil {
		return nil, err
	}
	conn := &ProcInstConnection{Edges: []*ProcInstEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pi.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pi, err = pager.applyCursors(pi, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pi.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			pi.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			pi.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pi = pager.applyOrder(pi)
	nodes, err := pi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProcInstOrderFieldCreatedAt orders ProcInst by created_at.
	ProcInstOrderFieldCreatedAt = &ProcInstOrderField{
		Value: func(pi *ProcInst) (ent.Value, error) {
			return pi.CreatedAt, nil
		},
		column: procinst.FieldCreatedAt,
		toTerm: procinst.ByCreatedAt,
		toCursor: func(pi *ProcInst) Cursor {
			return Cursor{
				ID:    pi.ID,
				Value: pi.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProcInstOrderField) String() string {
	var str string
	switch f.column {
	case ProcInstOrderFieldCreatedAt.column:
		str = "createdAt"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProcInstOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProcInstOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProcInstOrderField %T must be a string", v)
	}
	switch str {
	case "createdAt":
		*f = *ProcInstOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ProcInstOrderField", str)
	}
	return nil
}

// ProcInstOrderField defines the ordering field of ProcInst.
type ProcInstOrderField struct {
	// Value extracts the ordering value from the given ProcInst.
	Value    func(*ProcInst) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) procinst.OrderOption
	toCursor func(*ProcInst) Cursor
}

// ProcInstOrder defines the ordering of ProcInst.
type ProcInstOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ProcInstOrderField `json:"field"`
}

// DefaultProcInstOrder is the default ordering of ProcInst.
var DefaultProcInstOrder = &ProcInstOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProcInstOrderField{
		Value: func(pi *ProcInst) (ent.Value, error) {
			return pi.ID, nil
		},
		column: procinst.FieldID,
		toTerm: procinst.ByID,
		toCursor: func(pi *ProcInst) Cursor {
			return Cursor{ID: pi.ID}
		},
	},
}

// ToEdge converts ProcInst into ProcInstEdge.
func (pi *ProcInst) ToEdge(order *ProcInstOrder) *ProcInstEdge {
	if order == nil {
		order = DefaultProcInstOrder
	}
	return &ProcInstEdge{
		Node:   pi,
		Cursor: order.Field.toCursor(pi),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TaskConnection) build(nodes []*Task, pager *taskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}
	c.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order *TaskOrder) TaskPaginateOption {
	if order == nil {
		order = DefaultTaskOrder
	}
	o := *order
	return func(pager *taskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	reverse bool
	order   *TaskOrder
	filter  func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption, reverse bool) (*taskPager, error) {
	pager := &taskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskOrder
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(t *Task) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) (*TaskQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTaskOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *taskPager) applyOrder(query *TaskQuery) *TaskQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTaskOrder.Field {
		query = query.Order(DefaultTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *taskPager) orderExpr(query *TaskQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTaskOrder.Field {
			b.Comma().Ident(DefaultTaskOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (t *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TaskConnection{Edges: []*TaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if sp, ok := pagination.SimplePaginationFromContext(ctx); ok {
		if first != nil {
			t.Offset((sp.PageIndex - sp.CurrentIndex - 1) * *first)
		}
		if last != nil {
			t.Offset((sp.CurrentIndex - sp.PageIndex - 1) * *last)
		}
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	// Value extracts the ordering value from the given Task.
	Value    func(*Task) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) task.OrderOption
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TaskOrderField{
		Value: func(t *Task) (ent.Value, error) {
			return t.ID, nil
		},
		column: task.FieldID,
		toTerm: task.ByID,
		toCursor: func(t *Task) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (t *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}
