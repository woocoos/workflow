// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/woocoos/entco/schemax/typex"
	"github.com/woocoos/workflow/ent/decisiondef"
	"github.com/woocoos/workflow/ent/decisionreqdef"
	"github.com/woocoos/workflow/ent/deployment"
	"github.com/woocoos/workflow/ent/identitylink"
	"github.com/woocoos/workflow/ent/orgapp"
	"github.com/woocoos/workflow/ent/orgrole"
	"github.com/woocoos/workflow/ent/orgroleuser"
	"github.com/woocoos/workflow/ent/orguser"
	"github.com/woocoos/workflow/ent/predicate"
	"github.com/woocoos/workflow/ent/procdef"
	"github.com/woocoos/workflow/ent/procinst"
	"github.com/woocoos/workflow/ent/task"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDecisionDef    = "DecisionDef"
	TypeDecisionReqDef = "DecisionReqDef"
	TypeDeployment     = "Deployment"
	TypeIdentityLink   = "IdentityLink"
	TypeOrgApp         = "OrgApp"
	TypeOrgRole        = "OrgRole"
	TypeOrgRoleUser    = "OrgRoleUser"
	TypeOrgUser        = "OrgUser"
	TypeProcDef        = "ProcDef"
	TypeProcInst       = "ProcInst"
	TypeTask           = "Task"
)

// DecisionDefMutation represents an operation that mutates the DecisionDef nodes in the graph.
type DecisionDefMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_by       *int
	addcreated_by    *int
	created_at       *time.Time
	updated_by       *int
	addupdated_by    *int
	updated_at       *time.Time
	tenant_id        *int
	addtenant_id     *int
	deployment_id    *int
	adddeployment_id *int
	app_id           *int
	addapp_id        *int
	category         *string
	name             *string
	key              *string
	req_def_key      *string
	version          *int32
	addversion       *int32
	revision         *int32
	addrevision      *int32
	version_tag      *string
	clearedFields    map[string]struct{}
	req_def          *int
	clearedreq_def   bool
	done             bool
	oldValue         func(context.Context) (*DecisionDef, error)
	predicates       []predicate.DecisionDef
}

var _ ent.Mutation = (*DecisionDefMutation)(nil)

// decisiondefOption allows management of the mutation configuration using functional options.
type decisiondefOption func(*DecisionDefMutation)

// newDecisionDefMutation creates new mutation for the DecisionDef entity.
func newDecisionDefMutation(c config, op Op, opts ...decisiondefOption) *DecisionDefMutation {
	m := &DecisionDefMutation{
		config:        c,
		op:            op,
		typ:           TypeDecisionDef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDecisionDefID sets the ID field of the mutation.
func withDecisionDefID(id int) decisiondefOption {
	return func(m *DecisionDefMutation) {
		var (
			err   error
			once  sync.Once
			value *DecisionDef
		)
		m.oldValue = func(ctx context.Context) (*DecisionDef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DecisionDef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDecisionDef sets the old DecisionDef of the mutation.
func withDecisionDef(node *DecisionDef) decisiondefOption {
	return func(m *DecisionDefMutation) {
		m.oldValue = func(context.Context) (*DecisionDef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DecisionDefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DecisionDefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DecisionDef entities.
func (m *DecisionDefMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DecisionDefMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DecisionDefMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DecisionDef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DecisionDefMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DecisionDefMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DecisionDefMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DecisionDefMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DecisionDefMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DecisionDefMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DecisionDefMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DecisionDefMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DecisionDefMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DecisionDefMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DecisionDefMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DecisionDefMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DecisionDefMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[decisiondef.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DecisionDefMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[decisiondef.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DecisionDefMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, decisiondef.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DecisionDefMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DecisionDefMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DecisionDefMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[decisiondef.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DecisionDefMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[decisiondef.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DecisionDefMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, decisiondef.FieldUpdatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *DecisionDefMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DecisionDefMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *DecisionDefMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DecisionDefMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DecisionDefMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetDeploymentID sets the "deployment_id" field.
func (m *DecisionDefMutation) SetDeploymentID(i int) {
	m.deployment_id = &i
	m.adddeployment_id = nil
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *DecisionDefMutation) DeploymentID() (r int, exists bool) {
	v := m.deployment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldDeploymentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// AddDeploymentID adds i to the "deployment_id" field.
func (m *DecisionDefMutation) AddDeploymentID(i int) {
	if m.adddeployment_id != nil {
		*m.adddeployment_id += i
	} else {
		m.adddeployment_id = &i
	}
}

// AddedDeploymentID returns the value that was added to the "deployment_id" field in this mutation.
func (m *DecisionDefMutation) AddedDeploymentID() (r int, exists bool) {
	v := m.adddeployment_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *DecisionDefMutation) ResetDeploymentID() {
	m.deployment_id = nil
	m.adddeployment_id = nil
}

// SetAppID sets the "app_id" field.
func (m *DecisionDefMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *DecisionDefMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *DecisionDefMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *DecisionDefMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *DecisionDefMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetReqDefID sets the "req_def_id" field.
func (m *DecisionDefMutation) SetReqDefID(i int) {
	m.req_def = &i
}

// ReqDefID returns the value of the "req_def_id" field in the mutation.
func (m *DecisionDefMutation) ReqDefID() (r int, exists bool) {
	v := m.req_def
	if v == nil {
		return
	}
	return *v, true
}

// OldReqDefID returns the old "req_def_id" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldReqDefID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqDefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqDefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqDefID: %w", err)
	}
	return oldValue.ReqDefID, nil
}

// ResetReqDefID resets all changes to the "req_def_id" field.
func (m *DecisionDefMutation) ResetReqDefID() {
	m.req_def = nil
}

// SetCategory sets the "category" field.
func (m *DecisionDefMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *DecisionDefMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *DecisionDefMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[decisiondef.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *DecisionDefMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[decisiondef.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *DecisionDefMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, decisiondef.FieldCategory)
}

// SetName sets the "name" field.
func (m *DecisionDefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DecisionDefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DecisionDefMutation) ClearName() {
	m.name = nil
	m.clearedFields[decisiondef.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DecisionDefMutation) NameCleared() bool {
	_, ok := m.clearedFields[decisiondef.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DecisionDefMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, decisiondef.FieldName)
}

// SetKey sets the "key" field.
func (m *DecisionDefMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DecisionDefMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DecisionDefMutation) ResetKey() {
	m.key = nil
}

// SetReqDefKey sets the "req_def_key" field.
func (m *DecisionDefMutation) SetReqDefKey(s string) {
	m.req_def_key = &s
}

// ReqDefKey returns the value of the "req_def_key" field in the mutation.
func (m *DecisionDefMutation) ReqDefKey() (r string, exists bool) {
	v := m.req_def_key
	if v == nil {
		return
	}
	return *v, true
}

// OldReqDefKey returns the old "req_def_key" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldReqDefKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqDefKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqDefKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqDefKey: %w", err)
	}
	return oldValue.ReqDefKey, nil
}

// ResetReqDefKey resets all changes to the "req_def_key" field.
func (m *DecisionDefMutation) ResetReqDefKey() {
	m.req_def_key = nil
}

// SetVersion sets the "version" field.
func (m *DecisionDefMutation) SetVersion(i int32) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *DecisionDefMutation) Version() (r int32, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *DecisionDefMutation) AddVersion(i int32) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *DecisionDefMutation) AddedVersion() (r int32, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *DecisionDefMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetRevision sets the "revision" field.
func (m *DecisionDefMutation) SetRevision(i int32) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *DecisionDefMutation) Revision() (r int32, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldRevision(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *DecisionDefMutation) AddRevision(i int32) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *DecisionDefMutation) AddedRevision() (r int32, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevision clears the value of the "revision" field.
func (m *DecisionDefMutation) ClearRevision() {
	m.revision = nil
	m.addrevision = nil
	m.clearedFields[decisiondef.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *DecisionDefMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[decisiondef.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *DecisionDefMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
	delete(m.clearedFields, decisiondef.FieldRevision)
}

// SetVersionTag sets the "version_tag" field.
func (m *DecisionDefMutation) SetVersionTag(s string) {
	m.version_tag = &s
}

// VersionTag returns the value of the "version_tag" field in the mutation.
func (m *DecisionDefMutation) VersionTag() (r string, exists bool) {
	v := m.version_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionTag returns the old "version_tag" field's value of the DecisionDef entity.
// If the DecisionDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionDefMutation) OldVersionTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionTag: %w", err)
	}
	return oldValue.VersionTag, nil
}

// ClearVersionTag clears the value of the "version_tag" field.
func (m *DecisionDefMutation) ClearVersionTag() {
	m.version_tag = nil
	m.clearedFields[decisiondef.FieldVersionTag] = struct{}{}
}

// VersionTagCleared returns if the "version_tag" field was cleared in this mutation.
func (m *DecisionDefMutation) VersionTagCleared() bool {
	_, ok := m.clearedFields[decisiondef.FieldVersionTag]
	return ok
}

// ResetVersionTag resets all changes to the "version_tag" field.
func (m *DecisionDefMutation) ResetVersionTag() {
	m.version_tag = nil
	delete(m.clearedFields, decisiondef.FieldVersionTag)
}

// ClearReqDef clears the "req_def" edge to the DecisionReqDef entity.
func (m *DecisionDefMutation) ClearReqDef() {
	m.clearedreq_def = true
}

// ReqDefCleared reports if the "req_def" edge to the DecisionReqDef entity was cleared.
func (m *DecisionDefMutation) ReqDefCleared() bool {
	return m.clearedreq_def
}

// ReqDefIDs returns the "req_def" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReqDefID instead. It exists only for internal usage by the builders.
func (m *DecisionDefMutation) ReqDefIDs() (ids []int) {
	if id := m.req_def; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReqDef resets all changes to the "req_def" edge.
func (m *DecisionDefMutation) ResetReqDef() {
	m.req_def = nil
	m.clearedreq_def = false
}

// Where appends a list predicates to the DecisionDefMutation builder.
func (m *DecisionDefMutation) Where(ps ...predicate.DecisionDef) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DecisionDefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DecisionDefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DecisionDef, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DecisionDefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DecisionDefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DecisionDef).
func (m *DecisionDefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DecisionDefMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_by != nil {
		fields = append(fields, decisiondef.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, decisiondef.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, decisiondef.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, decisiondef.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, decisiondef.FieldTenantID)
	}
	if m.deployment_id != nil {
		fields = append(fields, decisiondef.FieldDeploymentID)
	}
	if m.app_id != nil {
		fields = append(fields, decisiondef.FieldAppID)
	}
	if m.req_def != nil {
		fields = append(fields, decisiondef.FieldReqDefID)
	}
	if m.category != nil {
		fields = append(fields, decisiondef.FieldCategory)
	}
	if m.name != nil {
		fields = append(fields, decisiondef.FieldName)
	}
	if m.key != nil {
		fields = append(fields, decisiondef.FieldKey)
	}
	if m.req_def_key != nil {
		fields = append(fields, decisiondef.FieldReqDefKey)
	}
	if m.version != nil {
		fields = append(fields, decisiondef.FieldVersion)
	}
	if m.revision != nil {
		fields = append(fields, decisiondef.FieldRevision)
	}
	if m.version_tag != nil {
		fields = append(fields, decisiondef.FieldVersionTag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DecisionDefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case decisiondef.FieldCreatedBy:
		return m.CreatedBy()
	case decisiondef.FieldCreatedAt:
		return m.CreatedAt()
	case decisiondef.FieldUpdatedBy:
		return m.UpdatedBy()
	case decisiondef.FieldUpdatedAt:
		return m.UpdatedAt()
	case decisiondef.FieldTenantID:
		return m.TenantID()
	case decisiondef.FieldDeploymentID:
		return m.DeploymentID()
	case decisiondef.FieldAppID:
		return m.AppID()
	case decisiondef.FieldReqDefID:
		return m.ReqDefID()
	case decisiondef.FieldCategory:
		return m.Category()
	case decisiondef.FieldName:
		return m.Name()
	case decisiondef.FieldKey:
		return m.Key()
	case decisiondef.FieldReqDefKey:
		return m.ReqDefKey()
	case decisiondef.FieldVersion:
		return m.Version()
	case decisiondef.FieldRevision:
		return m.Revision()
	case decisiondef.FieldVersionTag:
		return m.VersionTag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DecisionDefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case decisiondef.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case decisiondef.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case decisiondef.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case decisiondef.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case decisiondef.FieldTenantID:
		return m.OldTenantID(ctx)
	case decisiondef.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case decisiondef.FieldAppID:
		return m.OldAppID(ctx)
	case decisiondef.FieldReqDefID:
		return m.OldReqDefID(ctx)
	case decisiondef.FieldCategory:
		return m.OldCategory(ctx)
	case decisiondef.FieldName:
		return m.OldName(ctx)
	case decisiondef.FieldKey:
		return m.OldKey(ctx)
	case decisiondef.FieldReqDefKey:
		return m.OldReqDefKey(ctx)
	case decisiondef.FieldVersion:
		return m.OldVersion(ctx)
	case decisiondef.FieldRevision:
		return m.OldRevision(ctx)
	case decisiondef.FieldVersionTag:
		return m.OldVersionTag(ctx)
	}
	return nil, fmt.Errorf("unknown DecisionDef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DecisionDefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case decisiondef.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case decisiondef.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case decisiondef.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case decisiondef.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case decisiondef.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case decisiondef.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case decisiondef.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case decisiondef.FieldReqDefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqDefID(v)
		return nil
	case decisiondef.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case decisiondef.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case decisiondef.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case decisiondef.FieldReqDefKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqDefKey(v)
		return nil
	case decisiondef.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case decisiondef.FieldRevision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case decisiondef.FieldVersionTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionTag(v)
		return nil
	}
	return fmt.Errorf("unknown DecisionDef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DecisionDefMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, decisiondef.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, decisiondef.FieldUpdatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, decisiondef.FieldTenantID)
	}
	if m.adddeployment_id != nil {
		fields = append(fields, decisiondef.FieldDeploymentID)
	}
	if m.addapp_id != nil {
		fields = append(fields, decisiondef.FieldAppID)
	}
	if m.addversion != nil {
		fields = append(fields, decisiondef.FieldVersion)
	}
	if m.addrevision != nil {
		fields = append(fields, decisiondef.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DecisionDefMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case decisiondef.FieldCreatedBy:
		return m.AddedCreatedBy()
	case decisiondef.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case decisiondef.FieldTenantID:
		return m.AddedTenantID()
	case decisiondef.FieldDeploymentID:
		return m.AddedDeploymentID()
	case decisiondef.FieldAppID:
		return m.AddedAppID()
	case decisiondef.FieldVersion:
		return m.AddedVersion()
	case decisiondef.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DecisionDefMutation) AddField(name string, value ent.Value) error {
	switch name {
	case decisiondef.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case decisiondef.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case decisiondef.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case decisiondef.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeploymentID(v)
		return nil
	case decisiondef.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case decisiondef.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case decisiondef.FieldRevision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown DecisionDef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DecisionDefMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(decisiondef.FieldUpdatedBy) {
		fields = append(fields, decisiondef.FieldUpdatedBy)
	}
	if m.FieldCleared(decisiondef.FieldUpdatedAt) {
		fields = append(fields, decisiondef.FieldUpdatedAt)
	}
	if m.FieldCleared(decisiondef.FieldCategory) {
		fields = append(fields, decisiondef.FieldCategory)
	}
	if m.FieldCleared(decisiondef.FieldName) {
		fields = append(fields, decisiondef.FieldName)
	}
	if m.FieldCleared(decisiondef.FieldRevision) {
		fields = append(fields, decisiondef.FieldRevision)
	}
	if m.FieldCleared(decisiondef.FieldVersionTag) {
		fields = append(fields, decisiondef.FieldVersionTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DecisionDefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DecisionDefMutation) ClearField(name string) error {
	switch name {
	case decisiondef.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case decisiondef.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case decisiondef.FieldCategory:
		m.ClearCategory()
		return nil
	case decisiondef.FieldName:
		m.ClearName()
		return nil
	case decisiondef.FieldRevision:
		m.ClearRevision()
		return nil
	case decisiondef.FieldVersionTag:
		m.ClearVersionTag()
		return nil
	}
	return fmt.Errorf("unknown DecisionDef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DecisionDefMutation) ResetField(name string) error {
	switch name {
	case decisiondef.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case decisiondef.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case decisiondef.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case decisiondef.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case decisiondef.FieldTenantID:
		m.ResetTenantID()
		return nil
	case decisiondef.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case decisiondef.FieldAppID:
		m.ResetAppID()
		return nil
	case decisiondef.FieldReqDefID:
		m.ResetReqDefID()
		return nil
	case decisiondef.FieldCategory:
		m.ResetCategory()
		return nil
	case decisiondef.FieldName:
		m.ResetName()
		return nil
	case decisiondef.FieldKey:
		m.ResetKey()
		return nil
	case decisiondef.FieldReqDefKey:
		m.ResetReqDefKey()
		return nil
	case decisiondef.FieldVersion:
		m.ResetVersion()
		return nil
	case decisiondef.FieldRevision:
		m.ResetRevision()
		return nil
	case decisiondef.FieldVersionTag:
		m.ResetVersionTag()
		return nil
	}
	return fmt.Errorf("unknown DecisionDef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DecisionDefMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.req_def != nil {
		edges = append(edges, decisiondef.EdgeReqDef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DecisionDefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case decisiondef.EdgeReqDef:
		if id := m.req_def; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DecisionDefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DecisionDefMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DecisionDefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreq_def {
		edges = append(edges, decisiondef.EdgeReqDef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DecisionDefMutation) EdgeCleared(name string) bool {
	switch name {
	case decisiondef.EdgeReqDef:
		return m.clearedreq_def
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DecisionDefMutation) ClearEdge(name string) error {
	switch name {
	case decisiondef.EdgeReqDef:
		m.ClearReqDef()
		return nil
	}
	return fmt.Errorf("unknown DecisionDef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DecisionDefMutation) ResetEdge(name string) error {
	switch name {
	case decisiondef.EdgeReqDef:
		m.ResetReqDef()
		return nil
	}
	return fmt.Errorf("unknown DecisionDef edge %s", name)
}

// DecisionReqDefMutation represents an operation that mutates the DecisionReqDef nodes in the graph.
type DecisionReqDefMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_by           *int
	addcreated_by        *int
	created_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_at           *time.Time
	tenant_id            *int
	addtenant_id         *int
	app_id               *int
	addapp_id            *int
	category             *string
	name                 *string
	key                  *string
	version              *int32
	addversion           *int32
	revision             *int32
	addrevision          *int32
	resource_key         *string
	resource_id          *int
	addresource_id       *int
	clearedFields        map[string]struct{}
	deployment           *int
	cleareddeployment    bool
	decision_defs        map[int]struct{}
	removeddecision_defs map[int]struct{}
	cleareddecision_defs bool
	done                 bool
	oldValue             func(context.Context) (*DecisionReqDef, error)
	predicates           []predicate.DecisionReqDef
}

var _ ent.Mutation = (*DecisionReqDefMutation)(nil)

// decisionreqdefOption allows management of the mutation configuration using functional options.
type decisionreqdefOption func(*DecisionReqDefMutation)

// newDecisionReqDefMutation creates new mutation for the DecisionReqDef entity.
func newDecisionReqDefMutation(c config, op Op, opts ...decisionreqdefOption) *DecisionReqDefMutation {
	m := &DecisionReqDefMutation{
		config:        c,
		op:            op,
		typ:           TypeDecisionReqDef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDecisionReqDefID sets the ID field of the mutation.
func withDecisionReqDefID(id int) decisionreqdefOption {
	return func(m *DecisionReqDefMutation) {
		var (
			err   error
			once  sync.Once
			value *DecisionReqDef
		)
		m.oldValue = func(ctx context.Context) (*DecisionReqDef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DecisionReqDef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDecisionReqDef sets the old DecisionReqDef of the mutation.
func withDecisionReqDef(node *DecisionReqDef) decisionreqdefOption {
	return func(m *DecisionReqDefMutation) {
		m.oldValue = func(context.Context) (*DecisionReqDef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DecisionReqDefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DecisionReqDefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DecisionReqDef entities.
func (m *DecisionReqDefMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DecisionReqDefMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DecisionReqDefMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DecisionReqDef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DecisionReqDefMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DecisionReqDefMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DecisionReqDefMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DecisionReqDefMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DecisionReqDefMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DecisionReqDefMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DecisionReqDefMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DecisionReqDefMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DecisionReqDefMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DecisionReqDefMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DecisionReqDefMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DecisionReqDefMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DecisionReqDefMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[decisionreqdef.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DecisionReqDefMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[decisionreqdef.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DecisionReqDefMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, decisionreqdef.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DecisionReqDefMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DecisionReqDefMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DecisionReqDefMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[decisionreqdef.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DecisionReqDefMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[decisionreqdef.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DecisionReqDefMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, decisionreqdef.FieldUpdatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *DecisionReqDefMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DecisionReqDefMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *DecisionReqDefMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DecisionReqDefMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DecisionReqDefMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetDeploymentID sets the "deployment_id" field.
func (m *DecisionReqDefMutation) SetDeploymentID(i int) {
	m.deployment = &i
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *DecisionReqDefMutation) DeploymentID() (r int, exists bool) {
	v := m.deployment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldDeploymentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *DecisionReqDefMutation) ResetDeploymentID() {
	m.deployment = nil
}

// SetAppID sets the "app_id" field.
func (m *DecisionReqDefMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *DecisionReqDefMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *DecisionReqDefMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *DecisionReqDefMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *DecisionReqDefMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetCategory sets the "category" field.
func (m *DecisionReqDefMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *DecisionReqDefMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *DecisionReqDefMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[decisionreqdef.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *DecisionReqDefMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[decisionreqdef.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *DecisionReqDefMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, decisionreqdef.FieldCategory)
}

// SetName sets the "name" field.
func (m *DecisionReqDefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DecisionReqDefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DecisionReqDefMutation) ClearName() {
	m.name = nil
	m.clearedFields[decisionreqdef.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DecisionReqDefMutation) NameCleared() bool {
	_, ok := m.clearedFields[decisionreqdef.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DecisionReqDefMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, decisionreqdef.FieldName)
}

// SetKey sets the "key" field.
func (m *DecisionReqDefMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DecisionReqDefMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DecisionReqDefMutation) ResetKey() {
	m.key = nil
}

// SetVersion sets the "version" field.
func (m *DecisionReqDefMutation) SetVersion(i int32) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *DecisionReqDefMutation) Version() (r int32, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *DecisionReqDefMutation) AddVersion(i int32) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *DecisionReqDefMutation) AddedVersion() (r int32, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *DecisionReqDefMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetRevision sets the "revision" field.
func (m *DecisionReqDefMutation) SetRevision(i int32) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *DecisionReqDefMutation) Revision() (r int32, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldRevision(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *DecisionReqDefMutation) AddRevision(i int32) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *DecisionReqDefMutation) AddedRevision() (r int32, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevision clears the value of the "revision" field.
func (m *DecisionReqDefMutation) ClearRevision() {
	m.revision = nil
	m.addrevision = nil
	m.clearedFields[decisionreqdef.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *DecisionReqDefMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[decisionreqdef.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *DecisionReqDefMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
	delete(m.clearedFields, decisionreqdef.FieldRevision)
}

// SetResourceKey sets the "resource_key" field.
func (m *DecisionReqDefMutation) SetResourceKey(s string) {
	m.resource_key = &s
}

// ResourceKey returns the value of the "resource_key" field in the mutation.
func (m *DecisionReqDefMutation) ResourceKey() (r string, exists bool) {
	v := m.resource_key
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceKey returns the old "resource_key" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldResourceKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceKey: %w", err)
	}
	return oldValue.ResourceKey, nil
}

// ClearResourceKey clears the value of the "resource_key" field.
func (m *DecisionReqDefMutation) ClearResourceKey() {
	m.resource_key = nil
	m.clearedFields[decisionreqdef.FieldResourceKey] = struct{}{}
}

// ResourceKeyCleared returns if the "resource_key" field was cleared in this mutation.
func (m *DecisionReqDefMutation) ResourceKeyCleared() bool {
	_, ok := m.clearedFields[decisionreqdef.FieldResourceKey]
	return ok
}

// ResetResourceKey resets all changes to the "resource_key" field.
func (m *DecisionReqDefMutation) ResetResourceKey() {
	m.resource_key = nil
	delete(m.clearedFields, decisionreqdef.FieldResourceKey)
}

// SetResourceID sets the "resource_id" field.
func (m *DecisionReqDefMutation) SetResourceID(i int) {
	m.resource_id = &i
	m.addresource_id = nil
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *DecisionReqDefMutation) ResourceID() (r int, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the DecisionReqDef entity.
// If the DecisionReqDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DecisionReqDefMutation) OldResourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// AddResourceID adds i to the "resource_id" field.
func (m *DecisionReqDefMutation) AddResourceID(i int) {
	if m.addresource_id != nil {
		*m.addresource_id += i
	} else {
		m.addresource_id = &i
	}
}

// AddedResourceID returns the value that was added to the "resource_id" field in this mutation.
func (m *DecisionReqDefMutation) AddedResourceID() (r int, exists bool) {
	v := m.addresource_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *DecisionReqDefMutation) ClearResourceID() {
	m.resource_id = nil
	m.addresource_id = nil
	m.clearedFields[decisionreqdef.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *DecisionReqDefMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[decisionreqdef.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *DecisionReqDefMutation) ResetResourceID() {
	m.resource_id = nil
	m.addresource_id = nil
	delete(m.clearedFields, decisionreqdef.FieldResourceID)
}

// ClearDeployment clears the "deployment" edge to the Deployment entity.
func (m *DecisionReqDefMutation) ClearDeployment() {
	m.cleareddeployment = true
}

// DeploymentCleared reports if the "deployment" edge to the Deployment entity was cleared.
func (m *DecisionReqDefMutation) DeploymentCleared() bool {
	return m.cleareddeployment
}

// DeploymentIDs returns the "deployment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentID instead. It exists only for internal usage by the builders.
func (m *DecisionReqDefMutation) DeploymentIDs() (ids []int) {
	if id := m.deployment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeployment resets all changes to the "deployment" edge.
func (m *DecisionReqDefMutation) ResetDeployment() {
	m.deployment = nil
	m.cleareddeployment = false
}

// AddDecisionDefIDs adds the "decision_defs" edge to the DecisionDef entity by ids.
func (m *DecisionReqDefMutation) AddDecisionDefIDs(ids ...int) {
	if m.decision_defs == nil {
		m.decision_defs = make(map[int]struct{})
	}
	for i := range ids {
		m.decision_defs[ids[i]] = struct{}{}
	}
}

// ClearDecisionDefs clears the "decision_defs" edge to the DecisionDef entity.
func (m *DecisionReqDefMutation) ClearDecisionDefs() {
	m.cleareddecision_defs = true
}

// DecisionDefsCleared reports if the "decision_defs" edge to the DecisionDef entity was cleared.
func (m *DecisionReqDefMutation) DecisionDefsCleared() bool {
	return m.cleareddecision_defs
}

// RemoveDecisionDefIDs removes the "decision_defs" edge to the DecisionDef entity by IDs.
func (m *DecisionReqDefMutation) RemoveDecisionDefIDs(ids ...int) {
	if m.removeddecision_defs == nil {
		m.removeddecision_defs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.decision_defs, ids[i])
		m.removeddecision_defs[ids[i]] = struct{}{}
	}
}

// RemovedDecisionDefs returns the removed IDs of the "decision_defs" edge to the DecisionDef entity.
func (m *DecisionReqDefMutation) RemovedDecisionDefsIDs() (ids []int) {
	for id := range m.removeddecision_defs {
		ids = append(ids, id)
	}
	return
}

// DecisionDefsIDs returns the "decision_defs" edge IDs in the mutation.
func (m *DecisionReqDefMutation) DecisionDefsIDs() (ids []int) {
	for id := range m.decision_defs {
		ids = append(ids, id)
	}
	return
}

// ResetDecisionDefs resets all changes to the "decision_defs" edge.
func (m *DecisionReqDefMutation) ResetDecisionDefs() {
	m.decision_defs = nil
	m.cleareddecision_defs = false
	m.removeddecision_defs = nil
}

// Where appends a list predicates to the DecisionReqDefMutation builder.
func (m *DecisionReqDefMutation) Where(ps ...predicate.DecisionReqDef) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DecisionReqDefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DecisionReqDefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DecisionReqDef, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DecisionReqDefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DecisionReqDefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DecisionReqDef).
func (m *DecisionReqDefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DecisionReqDefMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_by != nil {
		fields = append(fields, decisionreqdef.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, decisionreqdef.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, decisionreqdef.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, decisionreqdef.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, decisionreqdef.FieldTenantID)
	}
	if m.deployment != nil {
		fields = append(fields, decisionreqdef.FieldDeploymentID)
	}
	if m.app_id != nil {
		fields = append(fields, decisionreqdef.FieldAppID)
	}
	if m.category != nil {
		fields = append(fields, decisionreqdef.FieldCategory)
	}
	if m.name != nil {
		fields = append(fields, decisionreqdef.FieldName)
	}
	if m.key != nil {
		fields = append(fields, decisionreqdef.FieldKey)
	}
	if m.version != nil {
		fields = append(fields, decisionreqdef.FieldVersion)
	}
	if m.revision != nil {
		fields = append(fields, decisionreqdef.FieldRevision)
	}
	if m.resource_key != nil {
		fields = append(fields, decisionreqdef.FieldResourceKey)
	}
	if m.resource_id != nil {
		fields = append(fields, decisionreqdef.FieldResourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DecisionReqDefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case decisionreqdef.FieldCreatedBy:
		return m.CreatedBy()
	case decisionreqdef.FieldCreatedAt:
		return m.CreatedAt()
	case decisionreqdef.FieldUpdatedBy:
		return m.UpdatedBy()
	case decisionreqdef.FieldUpdatedAt:
		return m.UpdatedAt()
	case decisionreqdef.FieldTenantID:
		return m.TenantID()
	case decisionreqdef.FieldDeploymentID:
		return m.DeploymentID()
	case decisionreqdef.FieldAppID:
		return m.AppID()
	case decisionreqdef.FieldCategory:
		return m.Category()
	case decisionreqdef.FieldName:
		return m.Name()
	case decisionreqdef.FieldKey:
		return m.Key()
	case decisionreqdef.FieldVersion:
		return m.Version()
	case decisionreqdef.FieldRevision:
		return m.Revision()
	case decisionreqdef.FieldResourceKey:
		return m.ResourceKey()
	case decisionreqdef.FieldResourceID:
		return m.ResourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DecisionReqDefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case decisionreqdef.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case decisionreqdef.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case decisionreqdef.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case decisionreqdef.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case decisionreqdef.FieldTenantID:
		return m.OldTenantID(ctx)
	case decisionreqdef.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case decisionreqdef.FieldAppID:
		return m.OldAppID(ctx)
	case decisionreqdef.FieldCategory:
		return m.OldCategory(ctx)
	case decisionreqdef.FieldName:
		return m.OldName(ctx)
	case decisionreqdef.FieldKey:
		return m.OldKey(ctx)
	case decisionreqdef.FieldVersion:
		return m.OldVersion(ctx)
	case decisionreqdef.FieldRevision:
		return m.OldRevision(ctx)
	case decisionreqdef.FieldResourceKey:
		return m.OldResourceKey(ctx)
	case decisionreqdef.FieldResourceID:
		return m.OldResourceID(ctx)
	}
	return nil, fmt.Errorf("unknown DecisionReqDef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DecisionReqDefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case decisionreqdef.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case decisionreqdef.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case decisionreqdef.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case decisionreqdef.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case decisionreqdef.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case decisionreqdef.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case decisionreqdef.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case decisionreqdef.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case decisionreqdef.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case decisionreqdef.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case decisionreqdef.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case decisionreqdef.FieldRevision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case decisionreqdef.FieldResourceKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceKey(v)
		return nil
	case decisionreqdef.FieldResourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	}
	return fmt.Errorf("unknown DecisionReqDef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DecisionReqDefMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, decisionreqdef.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, decisionreqdef.FieldUpdatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, decisionreqdef.FieldTenantID)
	}
	if m.addapp_id != nil {
		fields = append(fields, decisionreqdef.FieldAppID)
	}
	if m.addversion != nil {
		fields = append(fields, decisionreqdef.FieldVersion)
	}
	if m.addrevision != nil {
		fields = append(fields, decisionreqdef.FieldRevision)
	}
	if m.addresource_id != nil {
		fields = append(fields, decisionreqdef.FieldResourceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DecisionReqDefMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case decisionreqdef.FieldCreatedBy:
		return m.AddedCreatedBy()
	case decisionreqdef.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case decisionreqdef.FieldTenantID:
		return m.AddedTenantID()
	case decisionreqdef.FieldAppID:
		return m.AddedAppID()
	case decisionreqdef.FieldVersion:
		return m.AddedVersion()
	case decisionreqdef.FieldRevision:
		return m.AddedRevision()
	case decisionreqdef.FieldResourceID:
		return m.AddedResourceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DecisionReqDefMutation) AddField(name string, value ent.Value) error {
	switch name {
	case decisionreqdef.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case decisionreqdef.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case decisionreqdef.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case decisionreqdef.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case decisionreqdef.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case decisionreqdef.FieldRevision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	case decisionreqdef.FieldResourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResourceID(v)
		return nil
	}
	return fmt.Errorf("unknown DecisionReqDef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DecisionReqDefMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(decisionreqdef.FieldUpdatedBy) {
		fields = append(fields, decisionreqdef.FieldUpdatedBy)
	}
	if m.FieldCleared(decisionreqdef.FieldUpdatedAt) {
		fields = append(fields, decisionreqdef.FieldUpdatedAt)
	}
	if m.FieldCleared(decisionreqdef.FieldCategory) {
		fields = append(fields, decisionreqdef.FieldCategory)
	}
	if m.FieldCleared(decisionreqdef.FieldName) {
		fields = append(fields, decisionreqdef.FieldName)
	}
	if m.FieldCleared(decisionreqdef.FieldRevision) {
		fields = append(fields, decisionreqdef.FieldRevision)
	}
	if m.FieldCleared(decisionreqdef.FieldResourceKey) {
		fields = append(fields, decisionreqdef.FieldResourceKey)
	}
	if m.FieldCleared(decisionreqdef.FieldResourceID) {
		fields = append(fields, decisionreqdef.FieldResourceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DecisionReqDefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DecisionReqDefMutation) ClearField(name string) error {
	switch name {
	case decisionreqdef.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case decisionreqdef.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case decisionreqdef.FieldCategory:
		m.ClearCategory()
		return nil
	case decisionreqdef.FieldName:
		m.ClearName()
		return nil
	case decisionreqdef.FieldRevision:
		m.ClearRevision()
		return nil
	case decisionreqdef.FieldResourceKey:
		m.ClearResourceKey()
		return nil
	case decisionreqdef.FieldResourceID:
		m.ClearResourceID()
		return nil
	}
	return fmt.Errorf("unknown DecisionReqDef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DecisionReqDefMutation) ResetField(name string) error {
	switch name {
	case decisionreqdef.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case decisionreqdef.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case decisionreqdef.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case decisionreqdef.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case decisionreqdef.FieldTenantID:
		m.ResetTenantID()
		return nil
	case decisionreqdef.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case decisionreqdef.FieldAppID:
		m.ResetAppID()
		return nil
	case decisionreqdef.FieldCategory:
		m.ResetCategory()
		return nil
	case decisionreqdef.FieldName:
		m.ResetName()
		return nil
	case decisionreqdef.FieldKey:
		m.ResetKey()
		return nil
	case decisionreqdef.FieldVersion:
		m.ResetVersion()
		return nil
	case decisionreqdef.FieldRevision:
		m.ResetRevision()
		return nil
	case decisionreqdef.FieldResourceKey:
		m.ResetResourceKey()
		return nil
	case decisionreqdef.FieldResourceID:
		m.ResetResourceID()
		return nil
	}
	return fmt.Errorf("unknown DecisionReqDef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DecisionReqDefMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.deployment != nil {
		edges = append(edges, decisionreqdef.EdgeDeployment)
	}
	if m.decision_defs != nil {
		edges = append(edges, decisionreqdef.EdgeDecisionDefs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DecisionReqDefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case decisionreqdef.EdgeDeployment:
		if id := m.deployment; id != nil {
			return []ent.Value{*id}
		}
	case decisionreqdef.EdgeDecisionDefs:
		ids := make([]ent.Value, 0, len(m.decision_defs))
		for id := range m.decision_defs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DecisionReqDefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddecision_defs != nil {
		edges = append(edges, decisionreqdef.EdgeDecisionDefs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DecisionReqDefMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case decisionreqdef.EdgeDecisionDefs:
		ids := make([]ent.Value, 0, len(m.removeddecision_defs))
		for id := range m.removeddecision_defs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DecisionReqDefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeployment {
		edges = append(edges, decisionreqdef.EdgeDeployment)
	}
	if m.cleareddecision_defs {
		edges = append(edges, decisionreqdef.EdgeDecisionDefs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DecisionReqDefMutation) EdgeCleared(name string) bool {
	switch name {
	case decisionreqdef.EdgeDeployment:
		return m.cleareddeployment
	case decisionreqdef.EdgeDecisionDefs:
		return m.cleareddecision_defs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DecisionReqDefMutation) ClearEdge(name string) error {
	switch name {
	case decisionreqdef.EdgeDeployment:
		m.ClearDeployment()
		return nil
	}
	return fmt.Errorf("unknown DecisionReqDef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DecisionReqDefMutation) ResetEdge(name string) error {
	switch name {
	case decisionreqdef.EdgeDeployment:
		m.ResetDeployment()
		return nil
	case decisionreqdef.EdgeDecisionDefs:
		m.ResetDecisionDefs()
		return nil
	}
	return fmt.Errorf("unknown DecisionReqDef edge %s", name)
}

// DeploymentMutation represents an operation that mutates the Deployment nodes in the graph.
type DeploymentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_by           *int
	addcreated_by        *int
	created_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_at           *time.Time
	tenant_id            *int
	addtenant_id         *int
	app_id               *int
	addapp_id            *int
	name                 *string
	source               *string
	deploy_time          *time.Time
	clearedFields        map[string]struct{}
	proc_defs            map[int]struct{}
	removedproc_defs     map[int]struct{}
	clearedproc_defs     bool
	decision_reqs        map[int]struct{}
	removeddecision_reqs map[int]struct{}
	cleareddecision_reqs bool
	done                 bool
	oldValue             func(context.Context) (*Deployment, error)
	predicates           []predicate.Deployment
}

var _ ent.Mutation = (*DeploymentMutation)(nil)

// deploymentOption allows management of the mutation configuration using functional options.
type deploymentOption func(*DeploymentMutation)

// newDeploymentMutation creates new mutation for the Deployment entity.
func newDeploymentMutation(c config, op Op, opts ...deploymentOption) *DeploymentMutation {
	m := &DeploymentMutation{
		config:        c,
		op:            op,
		typ:           TypeDeployment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeploymentID sets the ID field of the mutation.
func withDeploymentID(id int) deploymentOption {
	return func(m *DeploymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Deployment
		)
		m.oldValue = func(ctx context.Context) (*Deployment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Deployment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeployment sets the old Deployment of the mutation.
func withDeployment(node *Deployment) deploymentOption {
	return func(m *DeploymentMutation) {
		m.oldValue = func(context.Context) (*Deployment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeploymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeploymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Deployment entities.
func (m *DeploymentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeploymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeploymentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Deployment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *DeploymentMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeploymentMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *DeploymentMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *DeploymentMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeploymentMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeploymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeploymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeploymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeploymentMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeploymentMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DeploymentMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DeploymentMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DeploymentMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[deployment.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DeploymentMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[deployment.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeploymentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, deployment.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeploymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeploymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DeploymentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[deployment.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DeploymentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[deployment.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeploymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, deployment.FieldUpdatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *DeploymentMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeploymentMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *DeploymentMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *DeploymentMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeploymentMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetAppID sets the "app_id" field.
func (m *DeploymentMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *DeploymentMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *DeploymentMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *DeploymentMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *DeploymentMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetName sets the "name" field.
func (m *DeploymentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeploymentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DeploymentMutation) ClearName() {
	m.name = nil
	m.clearedFields[deployment.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DeploymentMutation) NameCleared() bool {
	_, ok := m.clearedFields[deployment.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DeploymentMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, deployment.FieldName)
}

// SetSource sets the "source" field.
func (m *DeploymentMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *DeploymentMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ClearSource clears the value of the "source" field.
func (m *DeploymentMutation) ClearSource() {
	m.source = nil
	m.clearedFields[deployment.FieldSource] = struct{}{}
}

// SourceCleared returns if the "source" field was cleared in this mutation.
func (m *DeploymentMutation) SourceCleared() bool {
	_, ok := m.clearedFields[deployment.FieldSource]
	return ok
}

// ResetSource resets all changes to the "source" field.
func (m *DeploymentMutation) ResetSource() {
	m.source = nil
	delete(m.clearedFields, deployment.FieldSource)
}

// SetDeployTime sets the "deploy_time" field.
func (m *DeploymentMutation) SetDeployTime(t time.Time) {
	m.deploy_time = &t
}

// DeployTime returns the value of the "deploy_time" field in the mutation.
func (m *DeploymentMutation) DeployTime() (r time.Time, exists bool) {
	v := m.deploy_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployTime returns the old "deploy_time" field's value of the Deployment entity.
// If the Deployment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeploymentMutation) OldDeployTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployTime: %w", err)
	}
	return oldValue.DeployTime, nil
}

// ResetDeployTime resets all changes to the "deploy_time" field.
func (m *DeploymentMutation) ResetDeployTime() {
	m.deploy_time = nil
}

// AddProcDefIDs adds the "proc_defs" edge to the ProcDef entity by ids.
func (m *DeploymentMutation) AddProcDefIDs(ids ...int) {
	if m.proc_defs == nil {
		m.proc_defs = make(map[int]struct{})
	}
	for i := range ids {
		m.proc_defs[ids[i]] = struct{}{}
	}
}

// ClearProcDefs clears the "proc_defs" edge to the ProcDef entity.
func (m *DeploymentMutation) ClearProcDefs() {
	m.clearedproc_defs = true
}

// ProcDefsCleared reports if the "proc_defs" edge to the ProcDef entity was cleared.
func (m *DeploymentMutation) ProcDefsCleared() bool {
	return m.clearedproc_defs
}

// RemoveProcDefIDs removes the "proc_defs" edge to the ProcDef entity by IDs.
func (m *DeploymentMutation) RemoveProcDefIDs(ids ...int) {
	if m.removedproc_defs == nil {
		m.removedproc_defs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proc_defs, ids[i])
		m.removedproc_defs[ids[i]] = struct{}{}
	}
}

// RemovedProcDefs returns the removed IDs of the "proc_defs" edge to the ProcDef entity.
func (m *DeploymentMutation) RemovedProcDefsIDs() (ids []int) {
	for id := range m.removedproc_defs {
		ids = append(ids, id)
	}
	return
}

// ProcDefsIDs returns the "proc_defs" edge IDs in the mutation.
func (m *DeploymentMutation) ProcDefsIDs() (ids []int) {
	for id := range m.proc_defs {
		ids = append(ids, id)
	}
	return
}

// ResetProcDefs resets all changes to the "proc_defs" edge.
func (m *DeploymentMutation) ResetProcDefs() {
	m.proc_defs = nil
	m.clearedproc_defs = false
	m.removedproc_defs = nil
}

// AddDecisionReqIDs adds the "decision_reqs" edge to the DecisionReqDef entity by ids.
func (m *DeploymentMutation) AddDecisionReqIDs(ids ...int) {
	if m.decision_reqs == nil {
		m.decision_reqs = make(map[int]struct{})
	}
	for i := range ids {
		m.decision_reqs[ids[i]] = struct{}{}
	}
}

// ClearDecisionReqs clears the "decision_reqs" edge to the DecisionReqDef entity.
func (m *DeploymentMutation) ClearDecisionReqs() {
	m.cleareddecision_reqs = true
}

// DecisionReqsCleared reports if the "decision_reqs" edge to the DecisionReqDef entity was cleared.
func (m *DeploymentMutation) DecisionReqsCleared() bool {
	return m.cleareddecision_reqs
}

// RemoveDecisionReqIDs removes the "decision_reqs" edge to the DecisionReqDef entity by IDs.
func (m *DeploymentMutation) RemoveDecisionReqIDs(ids ...int) {
	if m.removeddecision_reqs == nil {
		m.removeddecision_reqs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.decision_reqs, ids[i])
		m.removeddecision_reqs[ids[i]] = struct{}{}
	}
}

// RemovedDecisionReqs returns the removed IDs of the "decision_reqs" edge to the DecisionReqDef entity.
func (m *DeploymentMutation) RemovedDecisionReqsIDs() (ids []int) {
	for id := range m.removeddecision_reqs {
		ids = append(ids, id)
	}
	return
}

// DecisionReqsIDs returns the "decision_reqs" edge IDs in the mutation.
func (m *DeploymentMutation) DecisionReqsIDs() (ids []int) {
	for id := range m.decision_reqs {
		ids = append(ids, id)
	}
	return
}

// ResetDecisionReqs resets all changes to the "decision_reqs" edge.
func (m *DeploymentMutation) ResetDecisionReqs() {
	m.decision_reqs = nil
	m.cleareddecision_reqs = false
	m.removeddecision_reqs = nil
}

// Where appends a list predicates to the DeploymentMutation builder.
func (m *DeploymentMutation) Where(ps ...predicate.Deployment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeploymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeploymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Deployment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeploymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeploymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Deployment).
func (m *DeploymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeploymentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_by != nil {
		fields = append(fields, deployment.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, deployment.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, deployment.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, deployment.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, deployment.FieldTenantID)
	}
	if m.app_id != nil {
		fields = append(fields, deployment.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, deployment.FieldName)
	}
	if m.source != nil {
		fields = append(fields, deployment.FieldSource)
	}
	if m.deploy_time != nil {
		fields = append(fields, deployment.FieldDeployTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeploymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deployment.FieldCreatedBy:
		return m.CreatedBy()
	case deployment.FieldCreatedAt:
		return m.CreatedAt()
	case deployment.FieldUpdatedBy:
		return m.UpdatedBy()
	case deployment.FieldUpdatedAt:
		return m.UpdatedAt()
	case deployment.FieldTenantID:
		return m.TenantID()
	case deployment.FieldAppID:
		return m.AppID()
	case deployment.FieldName:
		return m.Name()
	case deployment.FieldSource:
		return m.Source()
	case deployment.FieldDeployTime:
		return m.DeployTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeploymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deployment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case deployment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deployment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case deployment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deployment.FieldTenantID:
		return m.OldTenantID(ctx)
	case deployment.FieldAppID:
		return m.OldAppID(ctx)
	case deployment.FieldName:
		return m.OldName(ctx)
	case deployment.FieldSource:
		return m.OldSource(ctx)
	case deployment.FieldDeployTime:
		return m.OldDeployTime(ctx)
	}
	return nil, fmt.Errorf("unknown Deployment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deployment.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case deployment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deployment.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case deployment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deployment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deployment.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case deployment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deployment.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case deployment.FieldDeployTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployTime(v)
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeploymentMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, deployment.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, deployment.FieldUpdatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, deployment.FieldTenantID)
	}
	if m.addapp_id != nil {
		fields = append(fields, deployment.FieldAppID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeploymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deployment.FieldCreatedBy:
		return m.AddedCreatedBy()
	case deployment.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case deployment.FieldTenantID:
		return m.AddedTenantID()
	case deployment.FieldAppID:
		return m.AddedAppID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeploymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deployment.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case deployment.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case deployment.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case deployment.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	}
	return fmt.Errorf("unknown Deployment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeploymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deployment.FieldUpdatedBy) {
		fields = append(fields, deployment.FieldUpdatedBy)
	}
	if m.FieldCleared(deployment.FieldUpdatedAt) {
		fields = append(fields, deployment.FieldUpdatedAt)
	}
	if m.FieldCleared(deployment.FieldName) {
		fields = append(fields, deployment.FieldName)
	}
	if m.FieldCleared(deployment.FieldSource) {
		fields = append(fields, deployment.FieldSource)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeploymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeploymentMutation) ClearField(name string) error {
	switch name {
	case deployment.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case deployment.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case deployment.FieldName:
		m.ClearName()
		return nil
	case deployment.FieldSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown Deployment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeploymentMutation) ResetField(name string) error {
	switch name {
	case deployment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case deployment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deployment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case deployment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deployment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deployment.FieldAppID:
		m.ResetAppID()
		return nil
	case deployment.FieldName:
		m.ResetName()
		return nil
	case deployment.FieldSource:
		m.ResetSource()
		return nil
	case deployment.FieldDeployTime:
		m.ResetDeployTime()
		return nil
	}
	return fmt.Errorf("unknown Deployment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeploymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.proc_defs != nil {
		edges = append(edges, deployment.EdgeProcDefs)
	}
	if m.decision_reqs != nil {
		edges = append(edges, deployment.EdgeDecisionReqs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeploymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deployment.EdgeProcDefs:
		ids := make([]ent.Value, 0, len(m.proc_defs))
		for id := range m.proc_defs {
			ids = append(ids, id)
		}
		return ids
	case deployment.EdgeDecisionReqs:
		ids := make([]ent.Value, 0, len(m.decision_reqs))
		for id := range m.decision_reqs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeploymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproc_defs != nil {
		edges = append(edges, deployment.EdgeProcDefs)
	}
	if m.removeddecision_reqs != nil {
		edges = append(edges, deployment.EdgeDecisionReqs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeploymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deployment.EdgeProcDefs:
		ids := make([]ent.Value, 0, len(m.removedproc_defs))
		for id := range m.removedproc_defs {
			ids = append(ids, id)
		}
		return ids
	case deployment.EdgeDecisionReqs:
		ids := make([]ent.Value, 0, len(m.removeddecision_reqs))
		for id := range m.removeddecision_reqs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeploymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproc_defs {
		edges = append(edges, deployment.EdgeProcDefs)
	}
	if m.cleareddecision_reqs {
		edges = append(edges, deployment.EdgeDecisionReqs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeploymentMutation) EdgeCleared(name string) bool {
	switch name {
	case deployment.EdgeProcDefs:
		return m.clearedproc_defs
	case deployment.EdgeDecisionReqs:
		return m.cleareddecision_reqs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeploymentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Deployment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeploymentMutation) ResetEdge(name string) error {
	switch name {
	case deployment.EdgeProcDefs:
		m.ResetProcDefs()
		return nil
	case deployment.EdgeDecisionReqs:
		m.ResetDecisionReqs()
		return nil
	}
	return fmt.Errorf("unknown Deployment edge %s", name)
}

// IdentityLinkMutation represents an operation that mutates the IdentityLink nodes in the graph.
type IdentityLinkMutation struct {
	config
	op             Op
	typ            string
	id             *int
	tenant_id      *int
	addtenant_id   *int
	proc_def_id    *int
	addproc_def_id *int
	group_id       *int
	addgroup_id    *int
	user_id        *int
	adduser_id     *int
	assigner_id    *int
	addassigner_id *int
	link_type      *identitylink.LinkType
	operation_type *identitylink.OperationType
	comments       *string
	clearedFields  map[string]struct{}
	task           *int
	clearedtask    bool
	done           bool
	oldValue       func(context.Context) (*IdentityLink, error)
	predicates     []predicate.IdentityLink
}

var _ ent.Mutation = (*IdentityLinkMutation)(nil)

// identitylinkOption allows management of the mutation configuration using functional options.
type identitylinkOption func(*IdentityLinkMutation)

// newIdentityLinkMutation creates new mutation for the IdentityLink entity.
func newIdentityLinkMutation(c config, op Op, opts ...identitylinkOption) *IdentityLinkMutation {
	m := &IdentityLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentityLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityLinkID sets the ID field of the mutation.
func withIdentityLinkID(id int) identitylinkOption {
	return func(m *IdentityLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *IdentityLink
		)
		m.oldValue = func(ctx context.Context) (*IdentityLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdentityLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentityLink sets the old IdentityLink of the mutation.
func withIdentityLink(node *IdentityLink) identitylinkOption {
	return func(m *IdentityLinkMutation) {
		m.oldValue = func(context.Context) (*IdentityLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IdentityLink entities.
func (m *IdentityLinkMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentityLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentityLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdentityLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *IdentityLinkMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *IdentityLinkMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *IdentityLinkMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *IdentityLinkMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *IdentityLinkMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetTaskID sets the "task_id" field.
func (m *IdentityLinkMutation) SetTaskID(i int) {
	m.task = &i
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *IdentityLinkMutation) TaskID() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldTaskID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *IdentityLinkMutation) ResetTaskID() {
	m.task = nil
}

// SetProcDefID sets the "proc_def_id" field.
func (m *IdentityLinkMutation) SetProcDefID(i int) {
	m.proc_def_id = &i
	m.addproc_def_id = nil
}

// ProcDefID returns the value of the "proc_def_id" field in the mutation.
func (m *IdentityLinkMutation) ProcDefID() (r int, exists bool) {
	v := m.proc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcDefID returns the old "proc_def_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldProcDefID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcDefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcDefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcDefID: %w", err)
	}
	return oldValue.ProcDefID, nil
}

// AddProcDefID adds i to the "proc_def_id" field.
func (m *IdentityLinkMutation) AddProcDefID(i int) {
	if m.addproc_def_id != nil {
		*m.addproc_def_id += i
	} else {
		m.addproc_def_id = &i
	}
}

// AddedProcDefID returns the value that was added to the "proc_def_id" field in this mutation.
func (m *IdentityLinkMutation) AddedProcDefID() (r int, exists bool) {
	v := m.addproc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcDefID resets all changes to the "proc_def_id" field.
func (m *IdentityLinkMutation) ResetProcDefID() {
	m.proc_def_id = nil
	m.addproc_def_id = nil
}

// SetGroupID sets the "group_id" field.
func (m *IdentityLinkMutation) SetGroupID(i int) {
	m.group_id = &i
	m.addgroup_id = nil
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *IdentityLinkMutation) GroupID() (r int, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldGroupID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// AddGroupID adds i to the "group_id" field.
func (m *IdentityLinkMutation) AddGroupID(i int) {
	if m.addgroup_id != nil {
		*m.addgroup_id += i
	} else {
		m.addgroup_id = &i
	}
}

// AddedGroupID returns the value that was added to the "group_id" field in this mutation.
func (m *IdentityLinkMutation) AddedGroupID() (r int, exists bool) {
	v := m.addgroup_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupID clears the value of the "group_id" field.
func (m *IdentityLinkMutation) ClearGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
	m.clearedFields[identitylink.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *IdentityLinkMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *IdentityLinkMutation) ResetGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
	delete(m.clearedFields, identitylink.FieldGroupID)
}

// SetUserID sets the "user_id" field.
func (m *IdentityLinkMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IdentityLinkMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *IdentityLinkMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *IdentityLinkMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *IdentityLinkMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[identitylink.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *IdentityLinkMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IdentityLinkMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, identitylink.FieldUserID)
}

// SetAssignerID sets the "assigner_id" field.
func (m *IdentityLinkMutation) SetAssignerID(i int) {
	m.assigner_id = &i
	m.addassigner_id = nil
}

// AssignerID returns the value of the "assigner_id" field in the mutation.
func (m *IdentityLinkMutation) AssignerID() (r int, exists bool) {
	v := m.assigner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignerID returns the old "assigner_id" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldAssignerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignerID: %w", err)
	}
	return oldValue.AssignerID, nil
}

// AddAssignerID adds i to the "assigner_id" field.
func (m *IdentityLinkMutation) AddAssignerID(i int) {
	if m.addassigner_id != nil {
		*m.addassigner_id += i
	} else {
		m.addassigner_id = &i
	}
}

// AddedAssignerID returns the value that was added to the "assigner_id" field in this mutation.
func (m *IdentityLinkMutation) AddedAssignerID() (r int, exists bool) {
	v := m.addassigner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignerID clears the value of the "assigner_id" field.
func (m *IdentityLinkMutation) ClearAssignerID() {
	m.assigner_id = nil
	m.addassigner_id = nil
	m.clearedFields[identitylink.FieldAssignerID] = struct{}{}
}

// AssignerIDCleared returns if the "assigner_id" field was cleared in this mutation.
func (m *IdentityLinkMutation) AssignerIDCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldAssignerID]
	return ok
}

// ResetAssignerID resets all changes to the "assigner_id" field.
func (m *IdentityLinkMutation) ResetAssignerID() {
	m.assigner_id = nil
	m.addassigner_id = nil
	delete(m.clearedFields, identitylink.FieldAssignerID)
}

// SetLinkType sets the "link_type" field.
func (m *IdentityLinkMutation) SetLinkType(it identitylink.LinkType) {
	m.link_type = &it
}

// LinkType returns the value of the "link_type" field in the mutation.
func (m *IdentityLinkMutation) LinkType() (r identitylink.LinkType, exists bool) {
	v := m.link_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkType returns the old "link_type" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldLinkType(ctx context.Context) (v identitylink.LinkType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkType: %w", err)
	}
	return oldValue.LinkType, nil
}

// ResetLinkType resets all changes to the "link_type" field.
func (m *IdentityLinkMutation) ResetLinkType() {
	m.link_type = nil
}

// SetOperationType sets the "operation_type" field.
func (m *IdentityLinkMutation) SetOperationType(it identitylink.OperationType) {
	m.operation_type = &it
}

// OperationType returns the value of the "operation_type" field in the mutation.
func (m *IdentityLinkMutation) OperationType() (r identitylink.OperationType, exists bool) {
	v := m.operation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationType returns the old "operation_type" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldOperationType(ctx context.Context) (v identitylink.OperationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationType: %w", err)
	}
	return oldValue.OperationType, nil
}

// ResetOperationType resets all changes to the "operation_type" field.
func (m *IdentityLinkMutation) ResetOperationType() {
	m.operation_type = nil
}

// SetComments sets the "comments" field.
func (m *IdentityLinkMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *IdentityLinkMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the IdentityLink entity.
// If the IdentityLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityLinkMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *IdentityLinkMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[identitylink.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *IdentityLinkMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[identitylink.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *IdentityLinkMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, identitylink.FieldComments)
}

// ClearTask clears the "task" edge to the Task entity.
func (m *IdentityLinkMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *IdentityLinkMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *IdentityLinkMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *IdentityLinkMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the IdentityLinkMutation builder.
func (m *IdentityLinkMutation) Where(ps ...predicate.IdentityLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdentityLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdentityLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IdentityLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdentityLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdentityLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IdentityLink).
func (m *IdentityLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityLinkMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenant_id != nil {
		fields = append(fields, identitylink.FieldTenantID)
	}
	if m.task != nil {
		fields = append(fields, identitylink.FieldTaskID)
	}
	if m.proc_def_id != nil {
		fields = append(fields, identitylink.FieldProcDefID)
	}
	if m.group_id != nil {
		fields = append(fields, identitylink.FieldGroupID)
	}
	if m.user_id != nil {
		fields = append(fields, identitylink.FieldUserID)
	}
	if m.assigner_id != nil {
		fields = append(fields, identitylink.FieldAssignerID)
	}
	if m.link_type != nil {
		fields = append(fields, identitylink.FieldLinkType)
	}
	if m.operation_type != nil {
		fields = append(fields, identitylink.FieldOperationType)
	}
	if m.comments != nil {
		fields = append(fields, identitylink.FieldComments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identitylink.FieldTenantID:
		return m.TenantID()
	case identitylink.FieldTaskID:
		return m.TaskID()
	case identitylink.FieldProcDefID:
		return m.ProcDefID()
	case identitylink.FieldGroupID:
		return m.GroupID()
	case identitylink.FieldUserID:
		return m.UserID()
	case identitylink.FieldAssignerID:
		return m.AssignerID()
	case identitylink.FieldLinkType:
		return m.LinkType()
	case identitylink.FieldOperationType:
		return m.OperationType()
	case identitylink.FieldComments:
		return m.Comments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identitylink.FieldTenantID:
		return m.OldTenantID(ctx)
	case identitylink.FieldTaskID:
		return m.OldTaskID(ctx)
	case identitylink.FieldProcDefID:
		return m.OldProcDefID(ctx)
	case identitylink.FieldGroupID:
		return m.OldGroupID(ctx)
	case identitylink.FieldUserID:
		return m.OldUserID(ctx)
	case identitylink.FieldAssignerID:
		return m.OldAssignerID(ctx)
	case identitylink.FieldLinkType:
		return m.OldLinkType(ctx)
	case identitylink.FieldOperationType:
		return m.OldOperationType(ctx)
	case identitylink.FieldComments:
		return m.OldComments(ctx)
	}
	return nil, fmt.Errorf("unknown IdentityLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identitylink.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case identitylink.FieldTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case identitylink.FieldProcDefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcDefID(v)
		return nil
	case identitylink.FieldGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case identitylink.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case identitylink.FieldAssignerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignerID(v)
		return nil
	case identitylink.FieldLinkType:
		v, ok := value.(identitylink.LinkType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkType(v)
		return nil
	case identitylink.FieldOperationType:
		v, ok := value.(identitylink.OperationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationType(v)
		return nil
	case identitylink.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	}
	return fmt.Errorf("unknown IdentityLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityLinkMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, identitylink.FieldTenantID)
	}
	if m.addproc_def_id != nil {
		fields = append(fields, identitylink.FieldProcDefID)
	}
	if m.addgroup_id != nil {
		fields = append(fields, identitylink.FieldGroupID)
	}
	if m.adduser_id != nil {
		fields = append(fields, identitylink.FieldUserID)
	}
	if m.addassigner_id != nil {
		fields = append(fields, identitylink.FieldAssignerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case identitylink.FieldTenantID:
		return m.AddedTenantID()
	case identitylink.FieldProcDefID:
		return m.AddedProcDefID()
	case identitylink.FieldGroupID:
		return m.AddedGroupID()
	case identitylink.FieldUserID:
		return m.AddedUserID()
	case identitylink.FieldAssignerID:
		return m.AddedAssignerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case identitylink.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case identitylink.FieldProcDefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcDefID(v)
		return nil
	case identitylink.FieldGroupID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupID(v)
		return nil
	case identitylink.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case identitylink.FieldAssignerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignerID(v)
		return nil
	}
	return fmt.Errorf("unknown IdentityLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(identitylink.FieldGroupID) {
		fields = append(fields, identitylink.FieldGroupID)
	}
	if m.FieldCleared(identitylink.FieldUserID) {
		fields = append(fields, identitylink.FieldUserID)
	}
	if m.FieldCleared(identitylink.FieldAssignerID) {
		fields = append(fields, identitylink.FieldAssignerID)
	}
	if m.FieldCleared(identitylink.FieldComments) {
		fields = append(fields, identitylink.FieldComments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityLinkMutation) ClearField(name string) error {
	switch name {
	case identitylink.FieldGroupID:
		m.ClearGroupID()
		return nil
	case identitylink.FieldUserID:
		m.ClearUserID()
		return nil
	case identitylink.FieldAssignerID:
		m.ClearAssignerID()
		return nil
	case identitylink.FieldComments:
		m.ClearComments()
		return nil
	}
	return fmt.Errorf("unknown IdentityLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityLinkMutation) ResetField(name string) error {
	switch name {
	case identitylink.FieldTenantID:
		m.ResetTenantID()
		return nil
	case identitylink.FieldTaskID:
		m.ResetTaskID()
		return nil
	case identitylink.FieldProcDefID:
		m.ResetProcDefID()
		return nil
	case identitylink.FieldGroupID:
		m.ResetGroupID()
		return nil
	case identitylink.FieldUserID:
		m.ResetUserID()
		return nil
	case identitylink.FieldAssignerID:
		m.ResetAssignerID()
		return nil
	case identitylink.FieldLinkType:
		m.ResetLinkType()
		return nil
	case identitylink.FieldOperationType:
		m.ResetOperationType()
		return nil
	case identitylink.FieldComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown IdentityLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task != nil {
		edges = append(edges, identitylink.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identitylink.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask {
		edges = append(edges, identitylink.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case identitylink.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityLinkMutation) ClearEdge(name string) error {
	switch name {
	case identitylink.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown IdentityLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityLinkMutation) ResetEdge(name string) error {
	switch name {
	case identitylink.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown IdentityLink edge %s", name)
}

// OrgAppMutation represents an operation that mutates the OrgApp nodes in the graph.
type OrgAppMutation struct {
	config
	op            Op
	typ           string
	id            *int
	org_id        *int
	addorg_id     *int
	app_id        *int
	addapp_id     *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OrgApp, error)
	predicates    []predicate.OrgApp
}

var _ ent.Mutation = (*OrgAppMutation)(nil)

// orgappOption allows management of the mutation configuration using functional options.
type orgappOption func(*OrgAppMutation)

// newOrgAppMutation creates new mutation for the OrgApp entity.
func newOrgAppMutation(c config, op Op, opts ...orgappOption) *OrgAppMutation {
	m := &OrgAppMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgAppID sets the ID field of the mutation.
func withOrgAppID(id int) orgappOption {
	return func(m *OrgAppMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgApp
		)
		m.oldValue = func(ctx context.Context) (*OrgApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgApp sets the old OrgApp of the mutation.
func withOrgApp(node *OrgApp) orgappOption {
	return func(m *OrgAppMutation) {
		m.oldValue = func(context.Context) (*OrgApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgApp entities.
func (m *OrgAppMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgAppMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgAppMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrgID sets the "org_id" field.
func (m *OrgAppMutation) SetOrgID(i int) {
	m.org_id = &i
	m.addorg_id = nil
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgAppMutation) OrgID() (r int, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// AddOrgID adds i to the "org_id" field.
func (m *OrgAppMutation) AddOrgID(i int) {
	if m.addorg_id != nil {
		*m.addorg_id += i
	} else {
		m.addorg_id = &i
	}
}

// AddedOrgID returns the value that was added to the "org_id" field in this mutation.
func (m *OrgAppMutation) AddedOrgID() (r int, exists bool) {
	v := m.addorg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgAppMutation) ResetOrgID() {
	m.org_id = nil
	m.addorg_id = nil
}

// SetAppID sets the "app_id" field.
func (m *OrgAppMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrgAppMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the OrgApp entity.
// If the OrgApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgAppMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *OrgAppMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *OrgAppMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrgAppMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// Where appends a list predicates to the OrgAppMutation builder.
func (m *OrgAppMutation) Where(ps ...predicate.OrgApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgApp).
func (m *OrgAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgAppMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.org_id != nil {
		fields = append(fields, orgapp.FieldOrgID)
	}
	if m.app_id != nil {
		fields = append(fields, orgapp.FieldAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgapp.FieldOrgID:
		return m.OrgID()
	case orgapp.FieldAppID:
		return m.AppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgapp.FieldOrgID:
		return m.OldOrgID(ctx)
	case orgapp.FieldAppID:
		return m.OldAppID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgapp.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orgapp.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgAppMutation) AddedFields() []string {
	var fields []string
	if m.addorg_id != nil {
		fields = append(fields, orgapp.FieldOrgID)
	}
	if m.addapp_id != nil {
		fields = append(fields, orgapp.FieldAppID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgAppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgapp.FieldOrgID:
		return m.AddedOrgID()
	case orgapp.FieldAppID:
		return m.AddedAppID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgapp.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgID(v)
		return nil
	case orgapp.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgAppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgAppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrgApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgAppMutation) ResetField(name string) error {
	switch name {
	case orgapp.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orgapp.FieldAppID:
		m.ResetAppID()
		return nil
	}
	return fmt.Errorf("unknown OrgApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgAppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgAppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgAppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrgApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgAppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrgApp edge %s", name)
}

// OrgRoleMutation represents an operation that mutates the OrgRole nodes in the graph.
type OrgRoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	org_id               *int
	addorg_id            *int
	kind                 *orgrole.Kind
	name                 *string
	clearedFields        map[string]struct{}
	org_users            map[int]struct{}
	removedorg_users     map[int]struct{}
	clearedorg_users     bool
	org_role_user        map[int]struct{}
	removedorg_role_user map[int]struct{}
	clearedorg_role_user bool
	done                 bool
	oldValue             func(context.Context) (*OrgRole, error)
	predicates           []predicate.OrgRole
}

var _ ent.Mutation = (*OrgRoleMutation)(nil)

// orgroleOption allows management of the mutation configuration using functional options.
type orgroleOption func(*OrgRoleMutation)

// newOrgRoleMutation creates new mutation for the OrgRole entity.
func newOrgRoleMutation(c config, op Op, opts ...orgroleOption) *OrgRoleMutation {
	m := &OrgRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgRoleID sets the ID field of the mutation.
func withOrgRoleID(id int) orgroleOption {
	return func(m *OrgRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgRole
		)
		m.oldValue = func(ctx context.Context) (*OrgRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgRole sets the old OrgRole of the mutation.
func withOrgRole(node *OrgRole) orgroleOption {
	return func(m *OrgRoleMutation) {
		m.oldValue = func(context.Context) (*OrgRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgRole entities.
func (m *OrgRoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrgID sets the "org_id" field.
func (m *OrgRoleMutation) SetOrgID(i int) {
	m.org_id = &i
	m.addorg_id = nil
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgRoleMutation) OrgID() (r int, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// AddOrgID adds i to the "org_id" field.
func (m *OrgRoleMutation) AddOrgID(i int) {
	if m.addorg_id != nil {
		*m.addorg_id += i
	} else {
		m.addorg_id = &i
	}
}

// AddedOrgID returns the value that was added to the "org_id" field in this mutation.
func (m *OrgRoleMutation) AddedOrgID() (r int, exists bool) {
	v := m.addorg_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrgID clears the value of the "org_id" field.
func (m *OrgRoleMutation) ClearOrgID() {
	m.org_id = nil
	m.addorg_id = nil
	m.clearedFields[orgrole.FieldOrgID] = struct{}{}
}

// OrgIDCleared returns if the "org_id" field was cleared in this mutation.
func (m *OrgRoleMutation) OrgIDCleared() bool {
	_, ok := m.clearedFields[orgrole.FieldOrgID]
	return ok
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgRoleMutation) ResetOrgID() {
	m.org_id = nil
	m.addorg_id = nil
	delete(m.clearedFields, orgrole.FieldOrgID)
}

// SetKind sets the "kind" field.
func (m *OrgRoleMutation) SetKind(o orgrole.Kind) {
	m.kind = &o
}

// Kind returns the value of the "kind" field in the mutation.
func (m *OrgRoleMutation) Kind() (r orgrole.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldKind(ctx context.Context) (v orgrole.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *OrgRoleMutation) ResetKind() {
	m.kind = nil
}

// SetName sets the "name" field.
func (m *OrgRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrgRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrgRole entity.
// If the OrgRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrgRoleMutation) ResetName() {
	m.name = nil
}

// AddOrgUserIDs adds the "org_users" edge to the OrgUser entity by ids.
func (m *OrgRoleMutation) AddOrgUserIDs(ids ...int) {
	if m.org_users == nil {
		m.org_users = make(map[int]struct{})
	}
	for i := range ids {
		m.org_users[ids[i]] = struct{}{}
	}
}

// ClearOrgUsers clears the "org_users" edge to the OrgUser entity.
func (m *OrgRoleMutation) ClearOrgUsers() {
	m.clearedorg_users = true
}

// OrgUsersCleared reports if the "org_users" edge to the OrgUser entity was cleared.
func (m *OrgRoleMutation) OrgUsersCleared() bool {
	return m.clearedorg_users
}

// RemoveOrgUserIDs removes the "org_users" edge to the OrgUser entity by IDs.
func (m *OrgRoleMutation) RemoveOrgUserIDs(ids ...int) {
	if m.removedorg_users == nil {
		m.removedorg_users = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_users, ids[i])
		m.removedorg_users[ids[i]] = struct{}{}
	}
}

// RemovedOrgUsers returns the removed IDs of the "org_users" edge to the OrgUser entity.
func (m *OrgRoleMutation) RemovedOrgUsersIDs() (ids []int) {
	for id := range m.removedorg_users {
		ids = append(ids, id)
	}
	return
}

// OrgUsersIDs returns the "org_users" edge IDs in the mutation.
func (m *OrgRoleMutation) OrgUsersIDs() (ids []int) {
	for id := range m.org_users {
		ids = append(ids, id)
	}
	return
}

// ResetOrgUsers resets all changes to the "org_users" edge.
func (m *OrgRoleMutation) ResetOrgUsers() {
	m.org_users = nil
	m.clearedorg_users = false
	m.removedorg_users = nil
}

// AddOrgRoleUserIDs adds the "org_role_user" edge to the OrgRoleUser entity by ids.
func (m *OrgRoleMutation) AddOrgRoleUserIDs(ids ...int) {
	if m.org_role_user == nil {
		m.org_role_user = make(map[int]struct{})
	}
	for i := range ids {
		m.org_role_user[ids[i]] = struct{}{}
	}
}

// ClearOrgRoleUser clears the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgRoleMutation) ClearOrgRoleUser() {
	m.clearedorg_role_user = true
}

// OrgRoleUserCleared reports if the "org_role_user" edge to the OrgRoleUser entity was cleared.
func (m *OrgRoleMutation) OrgRoleUserCleared() bool {
	return m.clearedorg_role_user
}

// RemoveOrgRoleUserIDs removes the "org_role_user" edge to the OrgRoleUser entity by IDs.
func (m *OrgRoleMutation) RemoveOrgRoleUserIDs(ids ...int) {
	if m.removedorg_role_user == nil {
		m.removedorg_role_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_role_user, ids[i])
		m.removedorg_role_user[ids[i]] = struct{}{}
	}
}

// RemovedOrgRoleUser returns the removed IDs of the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgRoleMutation) RemovedOrgRoleUserIDs() (ids []int) {
	for id := range m.removedorg_role_user {
		ids = append(ids, id)
	}
	return
}

// OrgRoleUserIDs returns the "org_role_user" edge IDs in the mutation.
func (m *OrgRoleMutation) OrgRoleUserIDs() (ids []int) {
	for id := range m.org_role_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrgRoleUser resets all changes to the "org_role_user" edge.
func (m *OrgRoleMutation) ResetOrgRoleUser() {
	m.org_role_user = nil
	m.clearedorg_role_user = false
	m.removedorg_role_user = nil
}

// Where appends a list predicates to the OrgRoleMutation builder.
func (m *OrgRoleMutation) Where(ps ...predicate.OrgRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgRole).
func (m *OrgRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgRoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.org_id != nil {
		fields = append(fields, orgrole.FieldOrgID)
	}
	if m.kind != nil {
		fields = append(fields, orgrole.FieldKind)
	}
	if m.name != nil {
		fields = append(fields, orgrole.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgrole.FieldOrgID:
		return m.OrgID()
	case orgrole.FieldKind:
		return m.Kind()
	case orgrole.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgrole.FieldOrgID:
		return m.OldOrgID(ctx)
	case orgrole.FieldKind:
		return m.OldKind(ctx)
	case orgrole.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown OrgRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgrole.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orgrole.FieldKind:
		v, ok := value.(orgrole.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case orgrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgRoleMutation) AddedFields() []string {
	var fields []string
	if m.addorg_id != nil {
		fields = append(fields, orgrole.FieldOrgID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgrole.FieldOrgID:
		return m.AddedOrgID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgrole.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orgrole.FieldOrgID) {
		fields = append(fields, orgrole.FieldOrgID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgRoleMutation) ClearField(name string) error {
	switch name {
	case orgrole.FieldOrgID:
		m.ClearOrgID()
		return nil
	}
	return fmt.Errorf("unknown OrgRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgRoleMutation) ResetField(name string) error {
	switch name {
	case orgrole.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orgrole.FieldKind:
		m.ResetKind()
		return nil
	case orgrole.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown OrgRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.org_users != nil {
		edges = append(edges, orgrole.EdgeOrgUsers)
	}
	if m.org_role_user != nil {
		edges = append(edges, orgrole.EdgeOrgRoleUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgrole.EdgeOrgUsers:
		ids := make([]ent.Value, 0, len(m.org_users))
		for id := range m.org_users {
			ids = append(ids, id)
		}
		return ids
	case orgrole.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.org_role_user))
		for id := range m.org_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorg_users != nil {
		edges = append(edges, orgrole.EdgeOrgUsers)
	}
	if m.removedorg_role_user != nil {
		edges = append(edges, orgrole.EdgeOrgRoleUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orgrole.EdgeOrgUsers:
		ids := make([]ent.Value, 0, len(m.removedorg_users))
		for id := range m.removedorg_users {
			ids = append(ids, id)
		}
		return ids
	case orgrole.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.removedorg_role_user))
		for id := range m.removedorg_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorg_users {
		edges = append(edges, orgrole.EdgeOrgUsers)
	}
	if m.clearedorg_role_user {
		edges = append(edges, orgrole.EdgeOrgRoleUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case orgrole.EdgeOrgUsers:
		return m.clearedorg_users
	case orgrole.EdgeOrgRoleUser:
		return m.clearedorg_role_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgRoleMutation) ResetEdge(name string) error {
	switch name {
	case orgrole.EdgeOrgUsers:
		m.ResetOrgUsers()
		return nil
	case orgrole.EdgeOrgRoleUser:
		m.ResetOrgRoleUser()
		return nil
	}
	return fmt.Errorf("unknown OrgRole edge %s", name)
}

// OrgRoleUserMutation represents an operation that mutates the OrgRoleUser nodes in the graph.
type OrgRoleUserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	user_id         *int
	adduser_id      *int
	org_id          *int
	addorg_id       *int
	clearedFields   map[string]struct{}
	org_role        *int
	clearedorg_role bool
	org_user        *int
	clearedorg_user bool
	done            bool
	oldValue        func(context.Context) (*OrgRoleUser, error)
	predicates      []predicate.OrgRoleUser
}

var _ ent.Mutation = (*OrgRoleUserMutation)(nil)

// orgroleuserOption allows management of the mutation configuration using functional options.
type orgroleuserOption func(*OrgRoleUserMutation)

// newOrgRoleUserMutation creates new mutation for the OrgRoleUser entity.
func newOrgRoleUserMutation(c config, op Op, opts ...orgroleuserOption) *OrgRoleUserMutation {
	m := &OrgRoleUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgRoleUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgRoleUserID sets the ID field of the mutation.
func withOrgRoleUserID(id int) orgroleuserOption {
	return func(m *OrgRoleUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgRoleUser
		)
		m.oldValue = func(ctx context.Context) (*OrgRoleUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgRoleUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgRoleUser sets the old OrgRoleUser of the mutation.
func withOrgRoleUser(node *OrgRoleUser) orgroleuserOption {
	return func(m *OrgRoleUserMutation) {
		m.oldValue = func(context.Context) (*OrgRoleUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgRoleUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgRoleUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgRoleUser entities.
func (m *OrgRoleUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgRoleUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgRoleUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgRoleUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrgRoleID sets the "org_role_id" field.
func (m *OrgRoleUserMutation) SetOrgRoleID(i int) {
	m.org_role = &i
}

// OrgRoleID returns the value of the "org_role_id" field in the mutation.
func (m *OrgRoleUserMutation) OrgRoleID() (r int, exists bool) {
	v := m.org_role
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgRoleID returns the old "org_role_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldOrgRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgRoleID: %w", err)
	}
	return oldValue.OrgRoleID, nil
}

// ResetOrgRoleID resets all changes to the "org_role_id" field.
func (m *OrgRoleUserMutation) ResetOrgRoleID() {
	m.org_role = nil
}

// SetOrgUserID sets the "org_user_id" field.
func (m *OrgRoleUserMutation) SetOrgUserID(i int) {
	m.org_user = &i
}

// OrgUserID returns the value of the "org_user_id" field in the mutation.
func (m *OrgRoleUserMutation) OrgUserID() (r int, exists bool) {
	v := m.org_user
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUserID returns the old "org_user_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldOrgUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUserID: %w", err)
	}
	return oldValue.OrgUserID, nil
}

// ResetOrgUserID resets all changes to the "org_user_id" field.
func (m *OrgRoleUserMutation) ResetOrgUserID() {
	m.org_user = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgRoleUserMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgRoleUserMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrgRoleUserMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrgRoleUserMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgRoleUserMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOrgID sets the "org_id" field.
func (m *OrgRoleUserMutation) SetOrgID(i int) {
	m.org_id = &i
	m.addorg_id = nil
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgRoleUserMutation) OrgID() (r int, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgRoleUser entity.
// If the OrgRoleUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgRoleUserMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// AddOrgID adds i to the "org_id" field.
func (m *OrgRoleUserMutation) AddOrgID(i int) {
	if m.addorg_id != nil {
		*m.addorg_id += i
	} else {
		m.addorg_id = &i
	}
}

// AddedOrgID returns the value that was added to the "org_id" field in this mutation.
func (m *OrgRoleUserMutation) AddedOrgID() (r int, exists bool) {
	v := m.addorg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgRoleUserMutation) ResetOrgID() {
	m.org_id = nil
	m.addorg_id = nil
}

// ClearOrgRole clears the "org_role" edge to the OrgRole entity.
func (m *OrgRoleUserMutation) ClearOrgRole() {
	m.clearedorg_role = true
}

// OrgRoleCleared reports if the "org_role" edge to the OrgRole entity was cleared.
func (m *OrgRoleUserMutation) OrgRoleCleared() bool {
	return m.clearedorg_role
}

// OrgRoleIDs returns the "org_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgRoleID instead. It exists only for internal usage by the builders.
func (m *OrgRoleUserMutation) OrgRoleIDs() (ids []int) {
	if id := m.org_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrgRole resets all changes to the "org_role" edge.
func (m *OrgRoleUserMutation) ResetOrgRole() {
	m.org_role = nil
	m.clearedorg_role = false
}

// ClearOrgUser clears the "org_user" edge to the OrgUser entity.
func (m *OrgRoleUserMutation) ClearOrgUser() {
	m.clearedorg_user = true
}

// OrgUserCleared reports if the "org_user" edge to the OrgUser entity was cleared.
func (m *OrgRoleUserMutation) OrgUserCleared() bool {
	return m.clearedorg_user
}

// OrgUserIDs returns the "org_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrgUserID instead. It exists only for internal usage by the builders.
func (m *OrgRoleUserMutation) OrgUserIDs() (ids []int) {
	if id := m.org_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrgUser resets all changes to the "org_user" edge.
func (m *OrgRoleUserMutation) ResetOrgUser() {
	m.org_user = nil
	m.clearedorg_user = false
}

// Where appends a list predicates to the OrgRoleUserMutation builder.
func (m *OrgRoleUserMutation) Where(ps ...predicate.OrgRoleUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgRoleUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgRoleUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgRoleUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgRoleUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgRoleUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgRoleUser).
func (m *OrgRoleUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgRoleUserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.org_role != nil {
		fields = append(fields, orgroleuser.FieldOrgRoleID)
	}
	if m.org_user != nil {
		fields = append(fields, orgroleuser.FieldOrgUserID)
	}
	if m.user_id != nil {
		fields = append(fields, orgroleuser.FieldUserID)
	}
	if m.org_id != nil {
		fields = append(fields, orgroleuser.FieldOrgID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgRoleUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orgroleuser.FieldOrgRoleID:
		return m.OrgRoleID()
	case orgroleuser.FieldOrgUserID:
		return m.OrgUserID()
	case orgroleuser.FieldUserID:
		return m.UserID()
	case orgroleuser.FieldOrgID:
		return m.OrgID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgRoleUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orgroleuser.FieldOrgRoleID:
		return m.OldOrgRoleID(ctx)
	case orgroleuser.FieldOrgUserID:
		return m.OldOrgUserID(ctx)
	case orgroleuser.FieldUserID:
		return m.OldUserID(ctx)
	case orgroleuser.FieldOrgID:
		return m.OldOrgID(ctx)
	}
	return nil, fmt.Errorf("unknown OrgRoleUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orgroleuser.FieldOrgRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgRoleID(v)
		return nil
	case orgroleuser.FieldOrgUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUserID(v)
		return nil
	case orgroleuser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orgroleuser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgRoleUserMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, orgroleuser.FieldUserID)
	}
	if m.addorg_id != nil {
		fields = append(fields, orgroleuser.FieldOrgID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgRoleUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orgroleuser.FieldUserID:
		return m.AddedUserID()
	case orgroleuser.FieldOrgID:
		return m.AddedOrgID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgRoleUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orgroleuser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case orgroleuser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgRoleUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgRoleUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgRoleUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrgRoleUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgRoleUserMutation) ResetField(name string) error {
	switch name {
	case orgroleuser.FieldOrgRoleID:
		m.ResetOrgRoleID()
		return nil
	case orgroleuser.FieldOrgUserID:
		m.ResetOrgUserID()
		return nil
	case orgroleuser.FieldUserID:
		m.ResetUserID()
		return nil
	case orgroleuser.FieldOrgID:
		m.ResetOrgID()
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgRoleUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.org_role != nil {
		edges = append(edges, orgroleuser.EdgeOrgRole)
	}
	if m.org_user != nil {
		edges = append(edges, orgroleuser.EdgeOrgUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgRoleUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orgroleuser.EdgeOrgRole:
		if id := m.org_role; id != nil {
			return []ent.Value{*id}
		}
	case orgroleuser.EdgeOrgUser:
		if id := m.org_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgRoleUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgRoleUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgRoleUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorg_role {
		edges = append(edges, orgroleuser.EdgeOrgRole)
	}
	if m.clearedorg_user {
		edges = append(edges, orgroleuser.EdgeOrgUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgRoleUserMutation) EdgeCleared(name string) bool {
	switch name {
	case orgroleuser.EdgeOrgRole:
		return m.clearedorg_role
	case orgroleuser.EdgeOrgUser:
		return m.clearedorg_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgRoleUserMutation) ClearEdge(name string) error {
	switch name {
	case orgroleuser.EdgeOrgRole:
		m.ClearOrgRole()
		return nil
	case orgroleuser.EdgeOrgUser:
		m.ClearOrgUser()
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgRoleUserMutation) ResetEdge(name string) error {
	switch name {
	case orgroleuser.EdgeOrgRole:
		m.ResetOrgRole()
		return nil
	case orgroleuser.EdgeOrgUser:
		m.ResetOrgUser()
		return nil
	}
	return fmt.Errorf("unknown OrgRoleUser edge %s", name)
}

// OrgUserMutation represents an operation that mutates the OrgUser nodes in the graph.
type OrgUserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	org_id               *int
	addorg_id            *int
	user_id              *int
	adduser_id           *int
	joined_at            *time.Time
	display_name         *string
	clearedFields        map[string]struct{}
	org_roles            map[int]struct{}
	removedorg_roles     map[int]struct{}
	clearedorg_roles     bool
	org_role_user        map[int]struct{}
	removedorg_role_user map[int]struct{}
	clearedorg_role_user bool
	done                 bool
	oldValue             func(context.Context) (*OrgUser, error)
	predicates           []predicate.OrgUser
}

var _ ent.Mutation = (*OrgUserMutation)(nil)

// orguserOption allows management of the mutation configuration using functional options.
type orguserOption func(*OrgUserMutation)

// newOrgUserMutation creates new mutation for the OrgUser entity.
func newOrgUserMutation(c config, op Op, opts ...orguserOption) *OrgUserMutation {
	m := &OrgUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrgUserID sets the ID field of the mutation.
func withOrgUserID(id int) orguserOption {
	return func(m *OrgUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrgUser
		)
		m.oldValue = func(ctx context.Context) (*OrgUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrgUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgUser sets the old OrgUser of the mutation.
func withOrgUser(node *OrgUser) orguserOption {
	return func(m *OrgUserMutation) {
		m.oldValue = func(context.Context) (*OrgUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrgUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrgUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrgUser entities.
func (m *OrgUserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrgUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrgUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrgUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrgID sets the "org_id" field.
func (m *OrgUserMutation) SetOrgID(i int) {
	m.org_id = &i
	m.addorg_id = nil
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *OrgUserMutation) OrgID() (r int, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// AddOrgID adds i to the "org_id" field.
func (m *OrgUserMutation) AddOrgID(i int) {
	if m.addorg_id != nil {
		*m.addorg_id += i
	} else {
		m.addorg_id = &i
	}
}

// AddedOrgID returns the value that was added to the "org_id" field in this mutation.
func (m *OrgUserMutation) AddedOrgID() (r int, exists bool) {
	v := m.addorg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *OrgUserMutation) ResetOrgID() {
	m.org_id = nil
	m.addorg_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OrgUserMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrgUserMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrgUserMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrgUserMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrgUserMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *OrgUserMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *OrgUserMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *OrgUserMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OrgUserMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OrgUserMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OrgUser entity.
// If the OrgUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrgUserMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OrgUserMutation) ResetDisplayName() {
	m.display_name = nil
}

// AddOrgRoleIDs adds the "org_roles" edge to the OrgRole entity by ids.
func (m *OrgUserMutation) AddOrgRoleIDs(ids ...int) {
	if m.org_roles == nil {
		m.org_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.org_roles[ids[i]] = struct{}{}
	}
}

// ClearOrgRoles clears the "org_roles" edge to the OrgRole entity.
func (m *OrgUserMutation) ClearOrgRoles() {
	m.clearedorg_roles = true
}

// OrgRolesCleared reports if the "org_roles" edge to the OrgRole entity was cleared.
func (m *OrgUserMutation) OrgRolesCleared() bool {
	return m.clearedorg_roles
}

// RemoveOrgRoleIDs removes the "org_roles" edge to the OrgRole entity by IDs.
func (m *OrgUserMutation) RemoveOrgRoleIDs(ids ...int) {
	if m.removedorg_roles == nil {
		m.removedorg_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_roles, ids[i])
		m.removedorg_roles[ids[i]] = struct{}{}
	}
}

// RemovedOrgRoles returns the removed IDs of the "org_roles" edge to the OrgRole entity.
func (m *OrgUserMutation) RemovedOrgRolesIDs() (ids []int) {
	for id := range m.removedorg_roles {
		ids = append(ids, id)
	}
	return
}

// OrgRolesIDs returns the "org_roles" edge IDs in the mutation.
func (m *OrgUserMutation) OrgRolesIDs() (ids []int) {
	for id := range m.org_roles {
		ids = append(ids, id)
	}
	return
}

// ResetOrgRoles resets all changes to the "org_roles" edge.
func (m *OrgUserMutation) ResetOrgRoles() {
	m.org_roles = nil
	m.clearedorg_roles = false
	m.removedorg_roles = nil
}

// AddOrgRoleUserIDs adds the "org_role_user" edge to the OrgRoleUser entity by ids.
func (m *OrgUserMutation) AddOrgRoleUserIDs(ids ...int) {
	if m.org_role_user == nil {
		m.org_role_user = make(map[int]struct{})
	}
	for i := range ids {
		m.org_role_user[ids[i]] = struct{}{}
	}
}

// ClearOrgRoleUser clears the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgUserMutation) ClearOrgRoleUser() {
	m.clearedorg_role_user = true
}

// OrgRoleUserCleared reports if the "org_role_user" edge to the OrgRoleUser entity was cleared.
func (m *OrgUserMutation) OrgRoleUserCleared() bool {
	return m.clearedorg_role_user
}

// RemoveOrgRoleUserIDs removes the "org_role_user" edge to the OrgRoleUser entity by IDs.
func (m *OrgUserMutation) RemoveOrgRoleUserIDs(ids ...int) {
	if m.removedorg_role_user == nil {
		m.removedorg_role_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.org_role_user, ids[i])
		m.removedorg_role_user[ids[i]] = struct{}{}
	}
}

// RemovedOrgRoleUser returns the removed IDs of the "org_role_user" edge to the OrgRoleUser entity.
func (m *OrgUserMutation) RemovedOrgRoleUserIDs() (ids []int) {
	for id := range m.removedorg_role_user {
		ids = append(ids, id)
	}
	return
}

// OrgRoleUserIDs returns the "org_role_user" edge IDs in the mutation.
func (m *OrgUserMutation) OrgRoleUserIDs() (ids []int) {
	for id := range m.org_role_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrgRoleUser resets all changes to the "org_role_user" edge.
func (m *OrgUserMutation) ResetOrgRoleUser() {
	m.org_role_user = nil
	m.clearedorg_role_user = false
	m.removedorg_role_user = nil
}

// Where appends a list predicates to the OrgUserMutation builder.
func (m *OrgUserMutation) Where(ps ...predicate.OrgUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrgUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrgUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrgUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrgUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrgUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrgUser).
func (m *OrgUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrgUserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.org_id != nil {
		fields = append(fields, orguser.FieldOrgID)
	}
	if m.user_id != nil {
		fields = append(fields, orguser.FieldUserID)
	}
	if m.joined_at != nil {
		fields = append(fields, orguser.FieldJoinedAt)
	}
	if m.display_name != nil {
		fields = append(fields, orguser.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrgUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orguser.FieldOrgID:
		return m.OrgID()
	case orguser.FieldUserID:
		return m.UserID()
	case orguser.FieldJoinedAt:
		return m.JoinedAt()
	case orguser.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrgUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orguser.FieldOrgID:
		return m.OldOrgID(ctx)
	case orguser.FieldUserID:
		return m.OldUserID(ctx)
	case orguser.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case orguser.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown OrgUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orguser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case orguser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orguser.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case orguser.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrgUserMutation) AddedFields() []string {
	var fields []string
	if m.addorg_id != nil {
		fields = append(fields, orguser.FieldOrgID)
	}
	if m.adduser_id != nil {
		fields = append(fields, orguser.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrgUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orguser.FieldOrgID:
		return m.AddedOrgID()
	case orguser.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrgUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orguser.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgID(v)
		return nil
	case orguser.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown OrgUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrgUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrgUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrgUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrgUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrgUserMutation) ResetField(name string) error {
	switch name {
	case orguser.FieldOrgID:
		m.ResetOrgID()
		return nil
	case orguser.FieldUserID:
		m.ResetUserID()
		return nil
	case orguser.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case orguser.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown OrgUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrgUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.org_roles != nil {
		edges = append(edges, orguser.EdgeOrgRoles)
	}
	if m.org_role_user != nil {
		edges = append(edges, orguser.EdgeOrgRoleUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrgUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orguser.EdgeOrgRoles:
		ids := make([]ent.Value, 0, len(m.org_roles))
		for id := range m.org_roles {
			ids = append(ids, id)
		}
		return ids
	case orguser.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.org_role_user))
		for id := range m.org_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrgUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorg_roles != nil {
		edges = append(edges, orguser.EdgeOrgRoles)
	}
	if m.removedorg_role_user != nil {
		edges = append(edges, orguser.EdgeOrgRoleUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrgUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orguser.EdgeOrgRoles:
		ids := make([]ent.Value, 0, len(m.removedorg_roles))
		for id := range m.removedorg_roles {
			ids = append(ids, id)
		}
		return ids
	case orguser.EdgeOrgRoleUser:
		ids := make([]ent.Value, 0, len(m.removedorg_role_user))
		for id := range m.removedorg_role_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrgUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorg_roles {
		edges = append(edges, orguser.EdgeOrgRoles)
	}
	if m.clearedorg_role_user {
		edges = append(edges, orguser.EdgeOrgRoleUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrgUserMutation) EdgeCleared(name string) bool {
	switch name {
	case orguser.EdgeOrgRoles:
		return m.clearedorg_roles
	case orguser.EdgeOrgRoleUser:
		return m.clearedorg_role_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrgUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrgUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrgUserMutation) ResetEdge(name string) error {
	switch name {
	case orguser.EdgeOrgRoles:
		m.ResetOrgRoles()
		return nil
	case orguser.EdgeOrgRoleUser:
		m.ResetOrgRoleUser()
		return nil
	}
	return fmt.Errorf("unknown OrgUser edge %s", name)
}

// ProcDefMutation represents an operation that mutates the ProcDef nodes in the graph.
type ProcDefMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_by            *int
	addcreated_by         *int
	created_at            *time.Time
	updated_by            *int
	addupdated_by         *int
	updated_at            *time.Time
	tenant_id             *int
	addtenant_id          *int
	app_id                *int
	addapp_id             *int
	category              *string
	name                  *string
	key                   *string
	version               *int32
	addversion            *int32
	revision              *int32
	addrevision           *int32
	version_tag           *string
	resource_key          *string
	resource_id           *int
	addresource_id        *int
	status                *typex.SimpleStatus
	clearedFields         map[string]struct{}
	deployment            *int
	cleareddeployment     bool
	proc_instances        map[int]struct{}
	removedproc_instances map[int]struct{}
	clearedproc_instances bool
	done                  bool
	oldValue              func(context.Context) (*ProcDef, error)
	predicates            []predicate.ProcDef
}

var _ ent.Mutation = (*ProcDefMutation)(nil)

// procdefOption allows management of the mutation configuration using functional options.
type procdefOption func(*ProcDefMutation)

// newProcDefMutation creates new mutation for the ProcDef entity.
func newProcDefMutation(c config, op Op, opts ...procdefOption) *ProcDefMutation {
	m := &ProcDefMutation{
		config:        c,
		op:            op,
		typ:           TypeProcDef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcDefID sets the ID field of the mutation.
func withProcDefID(id int) procdefOption {
	return func(m *ProcDefMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcDef
		)
		m.oldValue = func(ctx context.Context) (*ProcDef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcDef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcDef sets the old ProcDef of the mutation.
func withProcDef(node *ProcDef) procdefOption {
	return func(m *ProcDefMutation) {
		m.oldValue = func(context.Context) (*ProcDef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcDefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcDefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProcDef entities.
func (m *ProcDefMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcDefMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcDefMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcDef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcDefMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcDefMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProcDefMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProcDefMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcDefMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcDefMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcDefMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcDefMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProcDefMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProcDefMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProcDefMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProcDefMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProcDefMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[procdef.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProcDefMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[procdef.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProcDefMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, procdef.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcDefMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcDefMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProcDefMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[procdef.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProcDefMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[procdef.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcDefMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, procdef.FieldUpdatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcDefMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcDefMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcDefMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcDefMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcDefMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetDeploymentID sets the "deployment_id" field.
func (m *ProcDefMutation) SetDeploymentID(i int) {
	m.deployment = &i
}

// DeploymentID returns the value of the "deployment_id" field in the mutation.
func (m *ProcDefMutation) DeploymentID() (r int, exists bool) {
	v := m.deployment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentID returns the old "deployment_id" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldDeploymentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentID: %w", err)
	}
	return oldValue.DeploymentID, nil
}

// ResetDeploymentID resets all changes to the "deployment_id" field.
func (m *ProcDefMutation) ResetDeploymentID() {
	m.deployment = nil
}

// SetAppID sets the "app_id" field.
func (m *ProcDefMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ProcDefMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *ProcDefMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *ProcDefMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ProcDefMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetCategory sets the "category" field.
func (m *ProcDefMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProcDefMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProcDefMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[procdef.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProcDefMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[procdef.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProcDefMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, procdef.FieldCategory)
}

// SetName sets the "name" field.
func (m *ProcDefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProcDefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProcDefMutation) ClearName() {
	m.name = nil
	m.clearedFields[procdef.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProcDefMutation) NameCleared() bool {
	_, ok := m.clearedFields[procdef.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProcDefMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, procdef.FieldName)
}

// SetKey sets the "key" field.
func (m *ProcDefMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ProcDefMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ProcDefMutation) ResetKey() {
	m.key = nil
}

// SetVersion sets the "version" field.
func (m *ProcDefMutation) SetVersion(i int32) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ProcDefMutation) Version() (r int32, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ProcDefMutation) AddVersion(i int32) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ProcDefMutation) AddedVersion() (r int32, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ClearVersion clears the value of the "version" field.
func (m *ProcDefMutation) ClearVersion() {
	m.version = nil
	m.addversion = nil
	m.clearedFields[procdef.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ProcDefMutation) VersionCleared() bool {
	_, ok := m.clearedFields[procdef.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ProcDefMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
	delete(m.clearedFields, procdef.FieldVersion)
}

// SetRevision sets the "revision" field.
func (m *ProcDefMutation) SetRevision(i int32) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *ProcDefMutation) Revision() (r int32, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldRevision(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *ProcDefMutation) AddRevision(i int32) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *ProcDefMutation) AddedRevision() (r int32, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevision clears the value of the "revision" field.
func (m *ProcDefMutation) ClearRevision() {
	m.revision = nil
	m.addrevision = nil
	m.clearedFields[procdef.FieldRevision] = struct{}{}
}

// RevisionCleared returns if the "revision" field was cleared in this mutation.
func (m *ProcDefMutation) RevisionCleared() bool {
	_, ok := m.clearedFields[procdef.FieldRevision]
	return ok
}

// ResetRevision resets all changes to the "revision" field.
func (m *ProcDefMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
	delete(m.clearedFields, procdef.FieldRevision)
}

// SetVersionTag sets the "version_tag" field.
func (m *ProcDefMutation) SetVersionTag(s string) {
	m.version_tag = &s
}

// VersionTag returns the value of the "version_tag" field in the mutation.
func (m *ProcDefMutation) VersionTag() (r string, exists bool) {
	v := m.version_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionTag returns the old "version_tag" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldVersionTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionTag: %w", err)
	}
	return oldValue.VersionTag, nil
}

// ClearVersionTag clears the value of the "version_tag" field.
func (m *ProcDefMutation) ClearVersionTag() {
	m.version_tag = nil
	m.clearedFields[procdef.FieldVersionTag] = struct{}{}
}

// VersionTagCleared returns if the "version_tag" field was cleared in this mutation.
func (m *ProcDefMutation) VersionTagCleared() bool {
	_, ok := m.clearedFields[procdef.FieldVersionTag]
	return ok
}

// ResetVersionTag resets all changes to the "version_tag" field.
func (m *ProcDefMutation) ResetVersionTag() {
	m.version_tag = nil
	delete(m.clearedFields, procdef.FieldVersionTag)
}

// SetResourceKey sets the "resource_key" field.
func (m *ProcDefMutation) SetResourceKey(s string) {
	m.resource_key = &s
}

// ResourceKey returns the value of the "resource_key" field in the mutation.
func (m *ProcDefMutation) ResourceKey() (r string, exists bool) {
	v := m.resource_key
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceKey returns the old "resource_key" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldResourceKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceKey: %w", err)
	}
	return oldValue.ResourceKey, nil
}

// ClearResourceKey clears the value of the "resource_key" field.
func (m *ProcDefMutation) ClearResourceKey() {
	m.resource_key = nil
	m.clearedFields[procdef.FieldResourceKey] = struct{}{}
}

// ResourceKeyCleared returns if the "resource_key" field was cleared in this mutation.
func (m *ProcDefMutation) ResourceKeyCleared() bool {
	_, ok := m.clearedFields[procdef.FieldResourceKey]
	return ok
}

// ResetResourceKey resets all changes to the "resource_key" field.
func (m *ProcDefMutation) ResetResourceKey() {
	m.resource_key = nil
	delete(m.clearedFields, procdef.FieldResourceKey)
}

// SetResourceID sets the "resource_id" field.
func (m *ProcDefMutation) SetResourceID(i int) {
	m.resource_id = &i
	m.addresource_id = nil
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *ProcDefMutation) ResourceID() (r int, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldResourceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// AddResourceID adds i to the "resource_id" field.
func (m *ProcDefMutation) AddResourceID(i int) {
	if m.addresource_id != nil {
		*m.addresource_id += i
	} else {
		m.addresource_id = &i
	}
}

// AddedResourceID returns the value that was added to the "resource_id" field in this mutation.
func (m *ProcDefMutation) AddedResourceID() (r int, exists bool) {
	v := m.addresource_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *ProcDefMutation) ClearResourceID() {
	m.resource_id = nil
	m.addresource_id = nil
	m.clearedFields[procdef.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *ProcDefMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[procdef.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *ProcDefMutation) ResetResourceID() {
	m.resource_id = nil
	m.addresource_id = nil
	delete(m.clearedFields, procdef.FieldResourceID)
}

// SetStatus sets the "status" field.
func (m *ProcDefMutation) SetStatus(ts typex.SimpleStatus) {
	m.status = &ts
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcDefMutation) Status() (r typex.SimpleStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcDef entity.
// If the ProcDef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcDefMutation) OldStatus(ctx context.Context) (v typex.SimpleStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcDefMutation) ResetStatus() {
	m.status = nil
}

// ClearDeployment clears the "deployment" edge to the Deployment entity.
func (m *ProcDefMutation) ClearDeployment() {
	m.cleareddeployment = true
}

// DeploymentCleared reports if the "deployment" edge to the Deployment entity was cleared.
func (m *ProcDefMutation) DeploymentCleared() bool {
	return m.cleareddeployment
}

// DeploymentIDs returns the "deployment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeploymentID instead. It exists only for internal usage by the builders.
func (m *ProcDefMutation) DeploymentIDs() (ids []int) {
	if id := m.deployment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeployment resets all changes to the "deployment" edge.
func (m *ProcDefMutation) ResetDeployment() {
	m.deployment = nil
	m.cleareddeployment = false
}

// AddProcInstanceIDs adds the "proc_instances" edge to the ProcInst entity by ids.
func (m *ProcDefMutation) AddProcInstanceIDs(ids ...int) {
	if m.proc_instances == nil {
		m.proc_instances = make(map[int]struct{})
	}
	for i := range ids {
		m.proc_instances[ids[i]] = struct{}{}
	}
}

// ClearProcInstances clears the "proc_instances" edge to the ProcInst entity.
func (m *ProcDefMutation) ClearProcInstances() {
	m.clearedproc_instances = true
}

// ProcInstancesCleared reports if the "proc_instances" edge to the ProcInst entity was cleared.
func (m *ProcDefMutation) ProcInstancesCleared() bool {
	return m.clearedproc_instances
}

// RemoveProcInstanceIDs removes the "proc_instances" edge to the ProcInst entity by IDs.
func (m *ProcDefMutation) RemoveProcInstanceIDs(ids ...int) {
	if m.removedproc_instances == nil {
		m.removedproc_instances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.proc_instances, ids[i])
		m.removedproc_instances[ids[i]] = struct{}{}
	}
}

// RemovedProcInstances returns the removed IDs of the "proc_instances" edge to the ProcInst entity.
func (m *ProcDefMutation) RemovedProcInstancesIDs() (ids []int) {
	for id := range m.removedproc_instances {
		ids = append(ids, id)
	}
	return
}

// ProcInstancesIDs returns the "proc_instances" edge IDs in the mutation.
func (m *ProcDefMutation) ProcInstancesIDs() (ids []int) {
	for id := range m.proc_instances {
		ids = append(ids, id)
	}
	return
}

// ResetProcInstances resets all changes to the "proc_instances" edge.
func (m *ProcDefMutation) ResetProcInstances() {
	m.proc_instances = nil
	m.clearedproc_instances = false
	m.removedproc_instances = nil
}

// Where appends a list predicates to the ProcDefMutation builder.
func (m *ProcDefMutation) Where(ps ...predicate.ProcDef) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcDefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcDefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcDef, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcDefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcDefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcDef).
func (m *ProcDefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcDefMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_by != nil {
		fields = append(fields, procdef.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, procdef.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, procdef.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, procdef.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, procdef.FieldTenantID)
	}
	if m.deployment != nil {
		fields = append(fields, procdef.FieldDeploymentID)
	}
	if m.app_id != nil {
		fields = append(fields, procdef.FieldAppID)
	}
	if m.category != nil {
		fields = append(fields, procdef.FieldCategory)
	}
	if m.name != nil {
		fields = append(fields, procdef.FieldName)
	}
	if m.key != nil {
		fields = append(fields, procdef.FieldKey)
	}
	if m.version != nil {
		fields = append(fields, procdef.FieldVersion)
	}
	if m.revision != nil {
		fields = append(fields, procdef.FieldRevision)
	}
	if m.version_tag != nil {
		fields = append(fields, procdef.FieldVersionTag)
	}
	if m.resource_key != nil {
		fields = append(fields, procdef.FieldResourceKey)
	}
	if m.resource_id != nil {
		fields = append(fields, procdef.FieldResourceID)
	}
	if m.status != nil {
		fields = append(fields, procdef.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcDefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case procdef.FieldCreatedBy:
		return m.CreatedBy()
	case procdef.FieldCreatedAt:
		return m.CreatedAt()
	case procdef.FieldUpdatedBy:
		return m.UpdatedBy()
	case procdef.FieldUpdatedAt:
		return m.UpdatedAt()
	case procdef.FieldTenantID:
		return m.TenantID()
	case procdef.FieldDeploymentID:
		return m.DeploymentID()
	case procdef.FieldAppID:
		return m.AppID()
	case procdef.FieldCategory:
		return m.Category()
	case procdef.FieldName:
		return m.Name()
	case procdef.FieldKey:
		return m.Key()
	case procdef.FieldVersion:
		return m.Version()
	case procdef.FieldRevision:
		return m.Revision()
	case procdef.FieldVersionTag:
		return m.VersionTag()
	case procdef.FieldResourceKey:
		return m.ResourceKey()
	case procdef.FieldResourceID:
		return m.ResourceID()
	case procdef.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcDefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case procdef.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case procdef.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case procdef.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case procdef.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case procdef.FieldTenantID:
		return m.OldTenantID(ctx)
	case procdef.FieldDeploymentID:
		return m.OldDeploymentID(ctx)
	case procdef.FieldAppID:
		return m.OldAppID(ctx)
	case procdef.FieldCategory:
		return m.OldCategory(ctx)
	case procdef.FieldName:
		return m.OldName(ctx)
	case procdef.FieldKey:
		return m.OldKey(ctx)
	case procdef.FieldVersion:
		return m.OldVersion(ctx)
	case procdef.FieldRevision:
		return m.OldRevision(ctx)
	case procdef.FieldVersionTag:
		return m.OldVersionTag(ctx)
	case procdef.FieldResourceKey:
		return m.OldResourceKey(ctx)
	case procdef.FieldResourceID:
		return m.OldResourceID(ctx)
	case procdef.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProcDef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcDefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case procdef.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case procdef.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case procdef.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case procdef.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case procdef.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case procdef.FieldDeploymentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentID(v)
		return nil
	case procdef.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case procdef.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case procdef.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case procdef.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case procdef.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case procdef.FieldRevision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case procdef.FieldVersionTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionTag(v)
		return nil
	case procdef.FieldResourceKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceKey(v)
		return nil
	case procdef.FieldResourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case procdef.FieldStatus:
		v, ok := value.(typex.SimpleStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProcDef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcDefMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, procdef.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, procdef.FieldUpdatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, procdef.FieldTenantID)
	}
	if m.addapp_id != nil {
		fields = append(fields, procdef.FieldAppID)
	}
	if m.addversion != nil {
		fields = append(fields, procdef.FieldVersion)
	}
	if m.addrevision != nil {
		fields = append(fields, procdef.FieldRevision)
	}
	if m.addresource_id != nil {
		fields = append(fields, procdef.FieldResourceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcDefMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case procdef.FieldCreatedBy:
		return m.AddedCreatedBy()
	case procdef.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case procdef.FieldTenantID:
		return m.AddedTenantID()
	case procdef.FieldAppID:
		return m.AddedAppID()
	case procdef.FieldVersion:
		return m.AddedVersion()
	case procdef.FieldRevision:
		return m.AddedRevision()
	case procdef.FieldResourceID:
		return m.AddedResourceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcDefMutation) AddField(name string, value ent.Value) error {
	switch name {
	case procdef.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case procdef.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case procdef.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case procdef.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case procdef.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case procdef.FieldRevision:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	case procdef.FieldResourceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResourceID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcDef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcDefMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(procdef.FieldUpdatedBy) {
		fields = append(fields, procdef.FieldUpdatedBy)
	}
	if m.FieldCleared(procdef.FieldUpdatedAt) {
		fields = append(fields, procdef.FieldUpdatedAt)
	}
	if m.FieldCleared(procdef.FieldCategory) {
		fields = append(fields, procdef.FieldCategory)
	}
	if m.FieldCleared(procdef.FieldName) {
		fields = append(fields, procdef.FieldName)
	}
	if m.FieldCleared(procdef.FieldVersion) {
		fields = append(fields, procdef.FieldVersion)
	}
	if m.FieldCleared(procdef.FieldRevision) {
		fields = append(fields, procdef.FieldRevision)
	}
	if m.FieldCleared(procdef.FieldVersionTag) {
		fields = append(fields, procdef.FieldVersionTag)
	}
	if m.FieldCleared(procdef.FieldResourceKey) {
		fields = append(fields, procdef.FieldResourceKey)
	}
	if m.FieldCleared(procdef.FieldResourceID) {
		fields = append(fields, procdef.FieldResourceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcDefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcDefMutation) ClearField(name string) error {
	switch name {
	case procdef.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case procdef.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case procdef.FieldCategory:
		m.ClearCategory()
		return nil
	case procdef.FieldName:
		m.ClearName()
		return nil
	case procdef.FieldVersion:
		m.ClearVersion()
		return nil
	case procdef.FieldRevision:
		m.ClearRevision()
		return nil
	case procdef.FieldVersionTag:
		m.ClearVersionTag()
		return nil
	case procdef.FieldResourceKey:
		m.ClearResourceKey()
		return nil
	case procdef.FieldResourceID:
		m.ClearResourceID()
		return nil
	}
	return fmt.Errorf("unknown ProcDef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcDefMutation) ResetField(name string) error {
	switch name {
	case procdef.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case procdef.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case procdef.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case procdef.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case procdef.FieldTenantID:
		m.ResetTenantID()
		return nil
	case procdef.FieldDeploymentID:
		m.ResetDeploymentID()
		return nil
	case procdef.FieldAppID:
		m.ResetAppID()
		return nil
	case procdef.FieldCategory:
		m.ResetCategory()
		return nil
	case procdef.FieldName:
		m.ResetName()
		return nil
	case procdef.FieldKey:
		m.ResetKey()
		return nil
	case procdef.FieldVersion:
		m.ResetVersion()
		return nil
	case procdef.FieldRevision:
		m.ResetRevision()
		return nil
	case procdef.FieldVersionTag:
		m.ResetVersionTag()
		return nil
	case procdef.FieldResourceKey:
		m.ResetResourceKey()
		return nil
	case procdef.FieldResourceID:
		m.ResetResourceID()
		return nil
	case procdef.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProcDef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcDefMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.deployment != nil {
		edges = append(edges, procdef.EdgeDeployment)
	}
	if m.proc_instances != nil {
		edges = append(edges, procdef.EdgeProcInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcDefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case procdef.EdgeDeployment:
		if id := m.deployment; id != nil {
			return []ent.Value{*id}
		}
	case procdef.EdgeProcInstances:
		ids := make([]ent.Value, 0, len(m.proc_instances))
		for id := range m.proc_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcDefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproc_instances != nil {
		edges = append(edges, procdef.EdgeProcInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcDefMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case procdef.EdgeProcInstances:
		ids := make([]ent.Value, 0, len(m.removedproc_instances))
		for id := range m.removedproc_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcDefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddeployment {
		edges = append(edges, procdef.EdgeDeployment)
	}
	if m.clearedproc_instances {
		edges = append(edges, procdef.EdgeProcInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcDefMutation) EdgeCleared(name string) bool {
	switch name {
	case procdef.EdgeDeployment:
		return m.cleareddeployment
	case procdef.EdgeProcInstances:
		return m.clearedproc_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcDefMutation) ClearEdge(name string) error {
	switch name {
	case procdef.EdgeDeployment:
		m.ClearDeployment()
		return nil
	}
	return fmt.Errorf("unknown ProcDef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcDefMutation) ResetEdge(name string) error {
	switch name {
	case procdef.EdgeDeployment:
		m.ResetDeployment()
		return nil
	case procdef.EdgeProcInstances:
		m.ResetProcInstances()
		return nil
	}
	return fmt.Errorf("unknown ProcDef edge %s", name)
}

// ProcInstMutation represents an operation that mutates the ProcInst nodes in the graph.
type ProcInstMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_by            *int
	addcreated_by         *int
	created_at            *time.Time
	updated_by            *int
	addupdated_by         *int
	updated_at            *time.Time
	tenant_id             *int
	addtenant_id          *int
	app_id                *int
	addapp_id             *int
	business_key          *string
	start_time            *time.Time
	end_time              *time.Time
	duration              *int
	addduration           *int
	start_user_id         *int
	addstart_user_id      *int
	supper_instance_id    *int
	addsupper_instance_id *int
	root_instance_id      *int
	addroot_instance_id   *int
	deleted_time          *time.Time
	deleted_reason        *string
	status                *procinst.Status
	clearedFields         map[string]struct{}
	proc_def              *int
	clearedproc_def       bool
	tasks                 map[int]struct{}
	removedtasks          map[int]struct{}
	clearedtasks          bool
	done                  bool
	oldValue              func(context.Context) (*ProcInst, error)
	predicates            []predicate.ProcInst
}

var _ ent.Mutation = (*ProcInstMutation)(nil)

// procinstOption allows management of the mutation configuration using functional options.
type procinstOption func(*ProcInstMutation)

// newProcInstMutation creates new mutation for the ProcInst entity.
func newProcInstMutation(c config, op Op, opts ...procinstOption) *ProcInstMutation {
	m := &ProcInstMutation{
		config:        c,
		op:            op,
		typ:           TypeProcInst,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcInstID sets the ID field of the mutation.
func withProcInstID(id int) procinstOption {
	return func(m *ProcInstMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcInst
		)
		m.oldValue = func(ctx context.Context) (*ProcInst, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcInst.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcInst sets the old ProcInst of the mutation.
func withProcInst(node *ProcInst) procinstOption {
	return func(m *ProcInstMutation) {
		m.oldValue = func(context.Context) (*ProcInst, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcInstMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcInstMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProcInst entities.
func (m *ProcInstMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcInstMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcInstMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcInst.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcInstMutation) SetCreatedBy(i int) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcInstMutation) CreatedBy() (r int, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *ProcInstMutation) AddCreatedBy(i int) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProcInstMutation) AddedCreatedBy() (r int, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcInstMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcInstMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcInstMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcInstMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProcInstMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProcInstMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *ProcInstMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProcInstMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProcInstMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[procinst.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProcInstMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[procinst.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProcInstMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, procinst.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcInstMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcInstMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProcInstMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[procinst.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProcInstMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[procinst.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcInstMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, procinst.FieldUpdatedAt)
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcInstMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcInstMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *ProcInstMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *ProcInstMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcInstMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetProcDefID sets the "proc_def_id" field.
func (m *ProcInstMutation) SetProcDefID(i int) {
	m.proc_def = &i
}

// ProcDefID returns the value of the "proc_def_id" field in the mutation.
func (m *ProcInstMutation) ProcDefID() (r int, exists bool) {
	v := m.proc_def
	if v == nil {
		return
	}
	return *v, true
}

// OldProcDefID returns the old "proc_def_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldProcDefID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcDefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcDefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcDefID: %w", err)
	}
	return oldValue.ProcDefID, nil
}

// ResetProcDefID resets all changes to the "proc_def_id" field.
func (m *ProcInstMutation) ResetProcDefID() {
	m.proc_def = nil
}

// SetAppID sets the "app_id" field.
func (m *ProcInstMutation) SetAppID(i int) {
	m.app_id = &i
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *ProcInstMutation) AppID() (r int, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldAppID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds i to the "app_id" field.
func (m *ProcInstMutation) AddAppID(i int) {
	if m.addapp_id != nil {
		*m.addapp_id += i
	} else {
		m.addapp_id = &i
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *ProcInstMutation) AddedAppID() (r int, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *ProcInstMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetBusinessKey sets the "business_key" field.
func (m *ProcInstMutation) SetBusinessKey(s string) {
	m.business_key = &s
}

// BusinessKey returns the value of the "business_key" field in the mutation.
func (m *ProcInstMutation) BusinessKey() (r string, exists bool) {
	v := m.business_key
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessKey returns the old "business_key" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldBusinessKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessKey: %w", err)
	}
	return oldValue.BusinessKey, nil
}

// ResetBusinessKey resets all changes to the "business_key" field.
func (m *ProcInstMutation) ResetBusinessKey() {
	m.business_key = nil
}

// SetStartTime sets the "start_time" field.
func (m *ProcInstMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ProcInstMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ProcInstMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ProcInstMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ProcInstMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ProcInstMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[procinst.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ProcInstMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[procinst.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ProcInstMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, procinst.FieldEndTime)
}

// SetDuration sets the "duration" field.
func (m *ProcInstMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ProcInstMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ProcInstMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ProcInstMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ProcInstMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[procinst.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ProcInstMutation) DurationCleared() bool {
	_, ok := m.clearedFields[procinst.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ProcInstMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, procinst.FieldDuration)
}

// SetStartUserID sets the "start_user_id" field.
func (m *ProcInstMutation) SetStartUserID(i int) {
	m.start_user_id = &i
	m.addstart_user_id = nil
}

// StartUserID returns the value of the "start_user_id" field in the mutation.
func (m *ProcInstMutation) StartUserID() (r int, exists bool) {
	v := m.start_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStartUserID returns the old "start_user_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldStartUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartUserID: %w", err)
	}
	return oldValue.StartUserID, nil
}

// AddStartUserID adds i to the "start_user_id" field.
func (m *ProcInstMutation) AddStartUserID(i int) {
	if m.addstart_user_id != nil {
		*m.addstart_user_id += i
	} else {
		m.addstart_user_id = &i
	}
}

// AddedStartUserID returns the value that was added to the "start_user_id" field in this mutation.
func (m *ProcInstMutation) AddedStartUserID() (r int, exists bool) {
	v := m.addstart_user_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartUserID resets all changes to the "start_user_id" field.
func (m *ProcInstMutation) ResetStartUserID() {
	m.start_user_id = nil
	m.addstart_user_id = nil
}

// SetSupperInstanceID sets the "supper_instance_id" field.
func (m *ProcInstMutation) SetSupperInstanceID(i int) {
	m.supper_instance_id = &i
	m.addsupper_instance_id = nil
}

// SupperInstanceID returns the value of the "supper_instance_id" field in the mutation.
func (m *ProcInstMutation) SupperInstanceID() (r int, exists bool) {
	v := m.supper_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSupperInstanceID returns the old "supper_instance_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldSupperInstanceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupperInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupperInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupperInstanceID: %w", err)
	}
	return oldValue.SupperInstanceID, nil
}

// AddSupperInstanceID adds i to the "supper_instance_id" field.
func (m *ProcInstMutation) AddSupperInstanceID(i int) {
	if m.addsupper_instance_id != nil {
		*m.addsupper_instance_id += i
	} else {
		m.addsupper_instance_id = &i
	}
}

// AddedSupperInstanceID returns the value that was added to the "supper_instance_id" field in this mutation.
func (m *ProcInstMutation) AddedSupperInstanceID() (r int, exists bool) {
	v := m.addsupper_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSupperInstanceID clears the value of the "supper_instance_id" field.
func (m *ProcInstMutation) ClearSupperInstanceID() {
	m.supper_instance_id = nil
	m.addsupper_instance_id = nil
	m.clearedFields[procinst.FieldSupperInstanceID] = struct{}{}
}

// SupperInstanceIDCleared returns if the "supper_instance_id" field was cleared in this mutation.
func (m *ProcInstMutation) SupperInstanceIDCleared() bool {
	_, ok := m.clearedFields[procinst.FieldSupperInstanceID]
	return ok
}

// ResetSupperInstanceID resets all changes to the "supper_instance_id" field.
func (m *ProcInstMutation) ResetSupperInstanceID() {
	m.supper_instance_id = nil
	m.addsupper_instance_id = nil
	delete(m.clearedFields, procinst.FieldSupperInstanceID)
}

// SetRootInstanceID sets the "root_instance_id" field.
func (m *ProcInstMutation) SetRootInstanceID(i int) {
	m.root_instance_id = &i
	m.addroot_instance_id = nil
}

// RootInstanceID returns the value of the "root_instance_id" field in the mutation.
func (m *ProcInstMutation) RootInstanceID() (r int, exists bool) {
	v := m.root_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootInstanceID returns the old "root_instance_id" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldRootInstanceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootInstanceID: %w", err)
	}
	return oldValue.RootInstanceID, nil
}

// AddRootInstanceID adds i to the "root_instance_id" field.
func (m *ProcInstMutation) AddRootInstanceID(i int) {
	if m.addroot_instance_id != nil {
		*m.addroot_instance_id += i
	} else {
		m.addroot_instance_id = &i
	}
}

// AddedRootInstanceID returns the value that was added to the "root_instance_id" field in this mutation.
func (m *ProcInstMutation) AddedRootInstanceID() (r int, exists bool) {
	v := m.addroot_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRootInstanceID clears the value of the "root_instance_id" field.
func (m *ProcInstMutation) ClearRootInstanceID() {
	m.root_instance_id = nil
	m.addroot_instance_id = nil
	m.clearedFields[procinst.FieldRootInstanceID] = struct{}{}
}

// RootInstanceIDCleared returns if the "root_instance_id" field was cleared in this mutation.
func (m *ProcInstMutation) RootInstanceIDCleared() bool {
	_, ok := m.clearedFields[procinst.FieldRootInstanceID]
	return ok
}

// ResetRootInstanceID resets all changes to the "root_instance_id" field.
func (m *ProcInstMutation) ResetRootInstanceID() {
	m.root_instance_id = nil
	m.addroot_instance_id = nil
	delete(m.clearedFields, procinst.FieldRootInstanceID)
}

// SetDeletedTime sets the "deleted_time" field.
func (m *ProcInstMutation) SetDeletedTime(t time.Time) {
	m.deleted_time = &t
}

// DeletedTime returns the value of the "deleted_time" field in the mutation.
func (m *ProcInstMutation) DeletedTime() (r time.Time, exists bool) {
	v := m.deleted_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTime returns the old "deleted_time" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldDeletedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTime: %w", err)
	}
	return oldValue.DeletedTime, nil
}

// ClearDeletedTime clears the value of the "deleted_time" field.
func (m *ProcInstMutation) ClearDeletedTime() {
	m.deleted_time = nil
	m.clearedFields[procinst.FieldDeletedTime] = struct{}{}
}

// DeletedTimeCleared returns if the "deleted_time" field was cleared in this mutation.
func (m *ProcInstMutation) DeletedTimeCleared() bool {
	_, ok := m.clearedFields[procinst.FieldDeletedTime]
	return ok
}

// ResetDeletedTime resets all changes to the "deleted_time" field.
func (m *ProcInstMutation) ResetDeletedTime() {
	m.deleted_time = nil
	delete(m.clearedFields, procinst.FieldDeletedTime)
}

// SetDeletedReason sets the "deleted_reason" field.
func (m *ProcInstMutation) SetDeletedReason(s string) {
	m.deleted_reason = &s
}

// DeletedReason returns the value of the "deleted_reason" field in the mutation.
func (m *ProcInstMutation) DeletedReason() (r string, exists bool) {
	v := m.deleted_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedReason returns the old "deleted_reason" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldDeletedReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedReason: %w", err)
	}
	return oldValue.DeletedReason, nil
}

// ClearDeletedReason clears the value of the "deleted_reason" field.
func (m *ProcInstMutation) ClearDeletedReason() {
	m.deleted_reason = nil
	m.clearedFields[procinst.FieldDeletedReason] = struct{}{}
}

// DeletedReasonCleared returns if the "deleted_reason" field was cleared in this mutation.
func (m *ProcInstMutation) DeletedReasonCleared() bool {
	_, ok := m.clearedFields[procinst.FieldDeletedReason]
	return ok
}

// ResetDeletedReason resets all changes to the "deleted_reason" field.
func (m *ProcInstMutation) ResetDeletedReason() {
	m.deleted_reason = nil
	delete(m.clearedFields, procinst.FieldDeletedReason)
}

// SetStatus sets the "status" field.
func (m *ProcInstMutation) SetStatus(pr procinst.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcInstMutation) Status() (r procinst.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcInst entity.
// If the ProcInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcInstMutation) OldStatus(ctx context.Context) (v procinst.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcInstMutation) ResetStatus() {
	m.status = nil
}

// ClearProcDef clears the "proc_def" edge to the ProcDef entity.
func (m *ProcInstMutation) ClearProcDef() {
	m.clearedproc_def = true
}

// ProcDefCleared reports if the "proc_def" edge to the ProcDef entity was cleared.
func (m *ProcInstMutation) ProcDefCleared() bool {
	return m.clearedproc_def
}

// ProcDefIDs returns the "proc_def" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProcDefID instead. It exists only for internal usage by the builders.
func (m *ProcInstMutation) ProcDefIDs() (ids []int) {
	if id := m.proc_def; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProcDef resets all changes to the "proc_def" edge.
func (m *ProcInstMutation) ResetProcDef() {
	m.proc_def = nil
	m.clearedproc_def = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ProcInstMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ProcInstMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ProcInstMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ProcInstMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ProcInstMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProcInstMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProcInstMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the ProcInstMutation builder.
func (m *ProcInstMutation) Where(ps ...predicate.ProcInst) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProcInstMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProcInstMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProcInst, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProcInstMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProcInstMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProcInst).
func (m *ProcInstMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcInstMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_by != nil {
		fields = append(fields, procinst.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, procinst.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, procinst.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, procinst.FieldUpdatedAt)
	}
	if m.tenant_id != nil {
		fields = append(fields, procinst.FieldTenantID)
	}
	if m.proc_def != nil {
		fields = append(fields, procinst.FieldProcDefID)
	}
	if m.app_id != nil {
		fields = append(fields, procinst.FieldAppID)
	}
	if m.business_key != nil {
		fields = append(fields, procinst.FieldBusinessKey)
	}
	if m.start_time != nil {
		fields = append(fields, procinst.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, procinst.FieldEndTime)
	}
	if m.duration != nil {
		fields = append(fields, procinst.FieldDuration)
	}
	if m.start_user_id != nil {
		fields = append(fields, procinst.FieldStartUserID)
	}
	if m.supper_instance_id != nil {
		fields = append(fields, procinst.FieldSupperInstanceID)
	}
	if m.root_instance_id != nil {
		fields = append(fields, procinst.FieldRootInstanceID)
	}
	if m.deleted_time != nil {
		fields = append(fields, procinst.FieldDeletedTime)
	}
	if m.deleted_reason != nil {
		fields = append(fields, procinst.FieldDeletedReason)
	}
	if m.status != nil {
		fields = append(fields, procinst.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcInstMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case procinst.FieldCreatedBy:
		return m.CreatedBy()
	case procinst.FieldCreatedAt:
		return m.CreatedAt()
	case procinst.FieldUpdatedBy:
		return m.UpdatedBy()
	case procinst.FieldUpdatedAt:
		return m.UpdatedAt()
	case procinst.FieldTenantID:
		return m.TenantID()
	case procinst.FieldProcDefID:
		return m.ProcDefID()
	case procinst.FieldAppID:
		return m.AppID()
	case procinst.FieldBusinessKey:
		return m.BusinessKey()
	case procinst.FieldStartTime:
		return m.StartTime()
	case procinst.FieldEndTime:
		return m.EndTime()
	case procinst.FieldDuration:
		return m.Duration()
	case procinst.FieldStartUserID:
		return m.StartUserID()
	case procinst.FieldSupperInstanceID:
		return m.SupperInstanceID()
	case procinst.FieldRootInstanceID:
		return m.RootInstanceID()
	case procinst.FieldDeletedTime:
		return m.DeletedTime()
	case procinst.FieldDeletedReason:
		return m.DeletedReason()
	case procinst.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcInstMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case procinst.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case procinst.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case procinst.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case procinst.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case procinst.FieldTenantID:
		return m.OldTenantID(ctx)
	case procinst.FieldProcDefID:
		return m.OldProcDefID(ctx)
	case procinst.FieldAppID:
		return m.OldAppID(ctx)
	case procinst.FieldBusinessKey:
		return m.OldBusinessKey(ctx)
	case procinst.FieldStartTime:
		return m.OldStartTime(ctx)
	case procinst.FieldEndTime:
		return m.OldEndTime(ctx)
	case procinst.FieldDuration:
		return m.OldDuration(ctx)
	case procinst.FieldStartUserID:
		return m.OldStartUserID(ctx)
	case procinst.FieldSupperInstanceID:
		return m.OldSupperInstanceID(ctx)
	case procinst.FieldRootInstanceID:
		return m.OldRootInstanceID(ctx)
	case procinst.FieldDeletedTime:
		return m.OldDeletedTime(ctx)
	case procinst.FieldDeletedReason:
		return m.OldDeletedReason(ctx)
	case procinst.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ProcInst field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcInstMutation) SetField(name string, value ent.Value) error {
	switch name {
	case procinst.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case procinst.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case procinst.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case procinst.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case procinst.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case procinst.FieldProcDefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcDefID(v)
		return nil
	case procinst.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case procinst.FieldBusinessKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessKey(v)
		return nil
	case procinst.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case procinst.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case procinst.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case procinst.FieldStartUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartUserID(v)
		return nil
	case procinst.FieldSupperInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupperInstanceID(v)
		return nil
	case procinst.FieldRootInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootInstanceID(v)
		return nil
	case procinst.FieldDeletedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTime(v)
		return nil
	case procinst.FieldDeletedReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedReason(v)
		return nil
	case procinst.FieldStatus:
		v, ok := value.(procinst.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ProcInst field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcInstMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, procinst.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, procinst.FieldUpdatedBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, procinst.FieldTenantID)
	}
	if m.addapp_id != nil {
		fields = append(fields, procinst.FieldAppID)
	}
	if m.addduration != nil {
		fields = append(fields, procinst.FieldDuration)
	}
	if m.addstart_user_id != nil {
		fields = append(fields, procinst.FieldStartUserID)
	}
	if m.addsupper_instance_id != nil {
		fields = append(fields, procinst.FieldSupperInstanceID)
	}
	if m.addroot_instance_id != nil {
		fields = append(fields, procinst.FieldRootInstanceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcInstMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case procinst.FieldCreatedBy:
		return m.AddedCreatedBy()
	case procinst.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case procinst.FieldTenantID:
		return m.AddedTenantID()
	case procinst.FieldAppID:
		return m.AddedAppID()
	case procinst.FieldDuration:
		return m.AddedDuration()
	case procinst.FieldStartUserID:
		return m.AddedStartUserID()
	case procinst.FieldSupperInstanceID:
		return m.AddedSupperInstanceID()
	case procinst.FieldRootInstanceID:
		return m.AddedRootInstanceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcInstMutation) AddField(name string, value ent.Value) error {
	switch name {
	case procinst.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case procinst.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case procinst.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case procinst.FieldAppID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	case procinst.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case procinst.FieldStartUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartUserID(v)
		return nil
	case procinst.FieldSupperInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupperInstanceID(v)
		return nil
	case procinst.FieldRootInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRootInstanceID(v)
		return nil
	}
	return fmt.Errorf("unknown ProcInst numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcInstMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(procinst.FieldUpdatedBy) {
		fields = append(fields, procinst.FieldUpdatedBy)
	}
	if m.FieldCleared(procinst.FieldUpdatedAt) {
		fields = append(fields, procinst.FieldUpdatedAt)
	}
	if m.FieldCleared(procinst.FieldEndTime) {
		fields = append(fields, procinst.FieldEndTime)
	}
	if m.FieldCleared(procinst.FieldDuration) {
		fields = append(fields, procinst.FieldDuration)
	}
	if m.FieldCleared(procinst.FieldSupperInstanceID) {
		fields = append(fields, procinst.FieldSupperInstanceID)
	}
	if m.FieldCleared(procinst.FieldRootInstanceID) {
		fields = append(fields, procinst.FieldRootInstanceID)
	}
	if m.FieldCleared(procinst.FieldDeletedTime) {
		fields = append(fields, procinst.FieldDeletedTime)
	}
	if m.FieldCleared(procinst.FieldDeletedReason) {
		fields = append(fields, procinst.FieldDeletedReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcInstMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcInstMutation) ClearField(name string) error {
	switch name {
	case procinst.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case procinst.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case procinst.FieldEndTime:
		m.ClearEndTime()
		return nil
	case procinst.FieldDuration:
		m.ClearDuration()
		return nil
	case procinst.FieldSupperInstanceID:
		m.ClearSupperInstanceID()
		return nil
	case procinst.FieldRootInstanceID:
		m.ClearRootInstanceID()
		return nil
	case procinst.FieldDeletedTime:
		m.ClearDeletedTime()
		return nil
	case procinst.FieldDeletedReason:
		m.ClearDeletedReason()
		return nil
	}
	return fmt.Errorf("unknown ProcInst nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcInstMutation) ResetField(name string) error {
	switch name {
	case procinst.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case procinst.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case procinst.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case procinst.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case procinst.FieldTenantID:
		m.ResetTenantID()
		return nil
	case procinst.FieldProcDefID:
		m.ResetProcDefID()
		return nil
	case procinst.FieldAppID:
		m.ResetAppID()
		return nil
	case procinst.FieldBusinessKey:
		m.ResetBusinessKey()
		return nil
	case procinst.FieldStartTime:
		m.ResetStartTime()
		return nil
	case procinst.FieldEndTime:
		m.ResetEndTime()
		return nil
	case procinst.FieldDuration:
		m.ResetDuration()
		return nil
	case procinst.FieldStartUserID:
		m.ResetStartUserID()
		return nil
	case procinst.FieldSupperInstanceID:
		m.ResetSupperInstanceID()
		return nil
	case procinst.FieldRootInstanceID:
		m.ResetRootInstanceID()
		return nil
	case procinst.FieldDeletedTime:
		m.ResetDeletedTime()
		return nil
	case procinst.FieldDeletedReason:
		m.ResetDeletedReason()
		return nil
	case procinst.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ProcInst field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcInstMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.proc_def != nil {
		edges = append(edges, procinst.EdgeProcDef)
	}
	if m.tasks != nil {
		edges = append(edges, procinst.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcInstMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case procinst.EdgeProcDef:
		if id := m.proc_def; id != nil {
			return []ent.Value{*id}
		}
	case procinst.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcInstMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtasks != nil {
		edges = append(edges, procinst.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcInstMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case procinst.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcInstMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproc_def {
		edges = append(edges, procinst.EdgeProcDef)
	}
	if m.clearedtasks {
		edges = append(edges, procinst.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcInstMutation) EdgeCleared(name string) bool {
	switch name {
	case procinst.EdgeProcDef:
		return m.clearedproc_def
	case procinst.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcInstMutation) ClearEdge(name string) error {
	switch name {
	case procinst.EdgeProcDef:
		m.ClearProcDef()
		return nil
	}
	return fmt.Errorf("unknown ProcInst unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcInstMutation) ResetEdge(name string) error {
	switch name {
	case procinst.EdgeProcDef:
		m.ResetProcDef()
		return nil
	case procinst.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown ProcInst edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	tenant_id              *int
	addtenant_id           *int
	proc_def_id            *int
	addproc_def_id         *int
	execution_id           *string
	run_id                 *string
	task_def_key           *string
	parent_id              *int
	addparent_id           *int
	comments               *string
	assignee               *string
	member_count           *int32
	addmember_count        *int32
	unfinished_count       *int32
	addunfinished_count    *int32
	agree_count            *int32
	addagree_count         *int32
	kind                   *task.Kind
	sequential             *bool
	created_at             *time.Time
	updated_at             *time.Time
	status                 *task.Status
	clearedFields          map[string]struct{}
	proc_inst              *int
	clearedproc_inst       bool
	task_identities        map[int]struct{}
	removedtask_identities map[int]struct{}
	clearedtask_identities bool
	done                   bool
	oldValue               func(context.Context) (*Task, error)
	predicates             []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *TaskMutation) SetTenantID(i int) {
	m.tenant_id = &i
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TaskMutation) TenantID() (r int, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTenantID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds i to the "tenant_id" field.
func (m *TaskMutation) AddTenantID(i int) {
	if m.addtenant_id != nil {
		*m.addtenant_id += i
	} else {
		m.addtenant_id = &i
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *TaskMutation) AddedTenantID() (r int, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TaskMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
}

// SetProcInstID sets the "proc_inst_id" field.
func (m *TaskMutation) SetProcInstID(i int) {
	m.proc_inst = &i
}

// ProcInstID returns the value of the "proc_inst_id" field in the mutation.
func (m *TaskMutation) ProcInstID() (r int, exists bool) {
	v := m.proc_inst
	if v == nil {
		return
	}
	return *v, true
}

// OldProcInstID returns the old "proc_inst_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldProcInstID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcInstID: %w", err)
	}
	return oldValue.ProcInstID, nil
}

// ResetProcInstID resets all changes to the "proc_inst_id" field.
func (m *TaskMutation) ResetProcInstID() {
	m.proc_inst = nil
}

// SetProcDefID sets the "proc_def_id" field.
func (m *TaskMutation) SetProcDefID(i int) {
	m.proc_def_id = &i
	m.addproc_def_id = nil
}

// ProcDefID returns the value of the "proc_def_id" field in the mutation.
func (m *TaskMutation) ProcDefID() (r int, exists bool) {
	v := m.proc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProcDefID returns the old "proc_def_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldProcDefID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcDefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcDefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcDefID: %w", err)
	}
	return oldValue.ProcDefID, nil
}

// AddProcDefID adds i to the "proc_def_id" field.
func (m *TaskMutation) AddProcDefID(i int) {
	if m.addproc_def_id != nil {
		*m.addproc_def_id += i
	} else {
		m.addproc_def_id = &i
	}
}

// AddedProcDefID returns the value that was added to the "proc_def_id" field in this mutation.
func (m *TaskMutation) AddedProcDefID() (r int, exists bool) {
	v := m.addproc_def_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcDefID resets all changes to the "proc_def_id" field.
func (m *TaskMutation) ResetProcDefID() {
	m.proc_def_id = nil
	m.addproc_def_id = nil
}

// SetExecutionID sets the "execution_id" field.
func (m *TaskMutation) SetExecutionID(s string) {
	m.execution_id = &s
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *TaskMutation) ExecutionID() (r string, exists bool) {
	v := m.execution_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldExecutionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *TaskMutation) ResetExecutionID() {
	m.execution_id = nil
}

// SetRunID sets the "run_id" field.
func (m *TaskMutation) SetRunID(s string) {
	m.run_id = &s
}

// RunID returns the value of the "run_id" field in the mutation.
func (m *TaskMutation) RunID() (r string, exists bool) {
	v := m.run_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRunID returns the old "run_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRunID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunID: %w", err)
	}
	return oldValue.RunID, nil
}

// ClearRunID clears the value of the "run_id" field.
func (m *TaskMutation) ClearRunID() {
	m.run_id = nil
	m.clearedFields[task.FieldRunID] = struct{}{}
}

// RunIDCleared returns if the "run_id" field was cleared in this mutation.
func (m *TaskMutation) RunIDCleared() bool {
	_, ok := m.clearedFields[task.FieldRunID]
	return ok
}

// ResetRunID resets all changes to the "run_id" field.
func (m *TaskMutation) ResetRunID() {
	m.run_id = nil
	delete(m.clearedFields, task.FieldRunID)
}

// SetTaskDefKey sets the "task_def_key" field.
func (m *TaskMutation) SetTaskDefKey(s string) {
	m.task_def_key = &s
}

// TaskDefKey returns the value of the "task_def_key" field in the mutation.
func (m *TaskMutation) TaskDefKey() (r string, exists bool) {
	v := m.task_def_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskDefKey returns the old "task_def_key" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskDefKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskDefKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskDefKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskDefKey: %w", err)
	}
	return oldValue.TaskDefKey, nil
}

// ResetTaskDefKey resets all changes to the "task_def_key" field.
func (m *TaskMutation) ResetTaskDefKey() {
	m.task_def_key = nil
}

// SetParentID sets the "parent_id" field.
func (m *TaskMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *TaskMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *TaskMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *TaskMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *TaskMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[task.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *TaskMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[task.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *TaskMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, task.FieldParentID)
}

// SetComments sets the "comments" field.
func (m *TaskMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *TaskMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *TaskMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[task.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *TaskMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[task.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *TaskMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, task.FieldComments)
}

// SetAssignee sets the "assignee" field.
func (m *TaskMutation) SetAssignee(s string) {
	m.assignee = &s
}

// Assignee returns the value of the "assignee" field in the mutation.
func (m *TaskMutation) Assignee() (r string, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignee returns the old "assignee" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssignee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignee: %w", err)
	}
	return oldValue.Assignee, nil
}

// ClearAssignee clears the value of the "assignee" field.
func (m *TaskMutation) ClearAssignee() {
	m.assignee = nil
	m.clearedFields[task.FieldAssignee] = struct{}{}
}

// AssigneeCleared returns if the "assignee" field was cleared in this mutation.
func (m *TaskMutation) AssigneeCleared() bool {
	_, ok := m.clearedFields[task.FieldAssignee]
	return ok
}

// ResetAssignee resets all changes to the "assignee" field.
func (m *TaskMutation) ResetAssignee() {
	m.assignee = nil
	delete(m.clearedFields, task.FieldAssignee)
}

// SetMemberCount sets the "member_count" field.
func (m *TaskMutation) SetMemberCount(i int32) {
	m.member_count = &i
	m.addmember_count = nil
}

// MemberCount returns the value of the "member_count" field in the mutation.
func (m *TaskMutation) MemberCount() (r int32, exists bool) {
	v := m.member_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberCount returns the old "member_count" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldMemberCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberCount: %w", err)
	}
	return oldValue.MemberCount, nil
}

// AddMemberCount adds i to the "member_count" field.
func (m *TaskMutation) AddMemberCount(i int32) {
	if m.addmember_count != nil {
		*m.addmember_count += i
	} else {
		m.addmember_count = &i
	}
}

// AddedMemberCount returns the value that was added to the "member_count" field in this mutation.
func (m *TaskMutation) AddedMemberCount() (r int32, exists bool) {
	v := m.addmember_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemberCount resets all changes to the "member_count" field.
func (m *TaskMutation) ResetMemberCount() {
	m.member_count = nil
	m.addmember_count = nil
}

// SetUnfinishedCount sets the "unfinished_count" field.
func (m *TaskMutation) SetUnfinishedCount(i int32) {
	m.unfinished_count = &i
	m.addunfinished_count = nil
}

// UnfinishedCount returns the value of the "unfinished_count" field in the mutation.
func (m *TaskMutation) UnfinishedCount() (r int32, exists bool) {
	v := m.unfinished_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUnfinishedCount returns the old "unfinished_count" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUnfinishedCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnfinishedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnfinishedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnfinishedCount: %w", err)
	}
	return oldValue.UnfinishedCount, nil
}

// AddUnfinishedCount adds i to the "unfinished_count" field.
func (m *TaskMutation) AddUnfinishedCount(i int32) {
	if m.addunfinished_count != nil {
		*m.addunfinished_count += i
	} else {
		m.addunfinished_count = &i
	}
}

// AddedUnfinishedCount returns the value that was added to the "unfinished_count" field in this mutation.
func (m *TaskMutation) AddedUnfinishedCount() (r int32, exists bool) {
	v := m.addunfinished_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnfinishedCount resets all changes to the "unfinished_count" field.
func (m *TaskMutation) ResetUnfinishedCount() {
	m.unfinished_count = nil
	m.addunfinished_count = nil
}

// SetAgreeCount sets the "agree_count" field.
func (m *TaskMutation) SetAgreeCount(i int32) {
	m.agree_count = &i
	m.addagree_count = nil
}

// AgreeCount returns the value of the "agree_count" field in the mutation.
func (m *TaskMutation) AgreeCount() (r int32, exists bool) {
	v := m.agree_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreeCount returns the old "agree_count" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAgreeCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreeCount: %w", err)
	}
	return oldValue.AgreeCount, nil
}

// AddAgreeCount adds i to the "agree_count" field.
func (m *TaskMutation) AddAgreeCount(i int32) {
	if m.addagree_count != nil {
		*m.addagree_count += i
	} else {
		m.addagree_count = &i
	}
}

// AddedAgreeCount returns the value that was added to the "agree_count" field in this mutation.
func (m *TaskMutation) AddedAgreeCount() (r int32, exists bool) {
	v := m.addagree_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgreeCount resets all changes to the "agree_count" field.
func (m *TaskMutation) ResetAgreeCount() {
	m.agree_count = nil
	m.addagree_count = nil
}

// SetKind sets the "kind" field.
func (m *TaskMutation) SetKind(t task.Kind) {
	m.kind = &t
}

// Kind returns the value of the "kind" field in the mutation.
func (m *TaskMutation) Kind() (r task.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldKind(ctx context.Context) (v task.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *TaskMutation) ResetKind() {
	m.kind = nil
}

// SetSequential sets the "sequential" field.
func (m *TaskMutation) SetSequential(b bool) {
	m.sequential = &b
}

// Sequential returns the value of the "sequential" field in the mutation.
func (m *TaskMutation) Sequential() (r bool, exists bool) {
	v := m.sequential
	if v == nil {
		return
	}
	return *v, true
}

// OldSequential returns the old "sequential" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSequential(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequential is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequential requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequential: %w", err)
	}
	return oldValue.Sequential, nil
}

// ResetSequential resets all changes to the "sequential" field.
func (m *TaskMutation) ResetSequential() {
	m.sequential = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(t task.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r task.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v task.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// ClearProcInst clears the "proc_inst" edge to the ProcInst entity.
func (m *TaskMutation) ClearProcInst() {
	m.clearedproc_inst = true
}

// ProcInstCleared reports if the "proc_inst" edge to the ProcInst entity was cleared.
func (m *TaskMutation) ProcInstCleared() bool {
	return m.clearedproc_inst
}

// ProcInstIDs returns the "proc_inst" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProcInstID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ProcInstIDs() (ids []int) {
	if id := m.proc_inst; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProcInst resets all changes to the "proc_inst" edge.
func (m *TaskMutation) ResetProcInst() {
	m.proc_inst = nil
	m.clearedproc_inst = false
}

// AddTaskIdentityIDs adds the "task_identities" edge to the IdentityLink entity by ids.
func (m *TaskMutation) AddTaskIdentityIDs(ids ...int) {
	if m.task_identities == nil {
		m.task_identities = make(map[int]struct{})
	}
	for i := range ids {
		m.task_identities[ids[i]] = struct{}{}
	}
}

// ClearTaskIdentities clears the "task_identities" edge to the IdentityLink entity.
func (m *TaskMutation) ClearTaskIdentities() {
	m.clearedtask_identities = true
}

// TaskIdentitiesCleared reports if the "task_identities" edge to the IdentityLink entity was cleared.
func (m *TaskMutation) TaskIdentitiesCleared() bool {
	return m.clearedtask_identities
}

// RemoveTaskIdentityIDs removes the "task_identities" edge to the IdentityLink entity by IDs.
func (m *TaskMutation) RemoveTaskIdentityIDs(ids ...int) {
	if m.removedtask_identities == nil {
		m.removedtask_identities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_identities, ids[i])
		m.removedtask_identities[ids[i]] = struct{}{}
	}
}

// RemovedTaskIdentities returns the removed IDs of the "task_identities" edge to the IdentityLink entity.
func (m *TaskMutation) RemovedTaskIdentitiesIDs() (ids []int) {
	for id := range m.removedtask_identities {
		ids = append(ids, id)
	}
	return
}

// TaskIdentitiesIDs returns the "task_identities" edge IDs in the mutation.
func (m *TaskMutation) TaskIdentitiesIDs() (ids []int) {
	for id := range m.task_identities {
		ids = append(ids, id)
	}
	return
}

// ResetTaskIdentities resets all changes to the "task_identities" edge.
func (m *TaskMutation) ResetTaskIdentities() {
	m.task_identities = nil
	m.clearedtask_identities = false
	m.removedtask_identities = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.tenant_id != nil {
		fields = append(fields, task.FieldTenantID)
	}
	if m.proc_inst != nil {
		fields = append(fields, task.FieldProcInstID)
	}
	if m.proc_def_id != nil {
		fields = append(fields, task.FieldProcDefID)
	}
	if m.execution_id != nil {
		fields = append(fields, task.FieldExecutionID)
	}
	if m.run_id != nil {
		fields = append(fields, task.FieldRunID)
	}
	if m.task_def_key != nil {
		fields = append(fields, task.FieldTaskDefKey)
	}
	if m.parent_id != nil {
		fields = append(fields, task.FieldParentID)
	}
	if m.comments != nil {
		fields = append(fields, task.FieldComments)
	}
	if m.assignee != nil {
		fields = append(fields, task.FieldAssignee)
	}
	if m.member_count != nil {
		fields = append(fields, task.FieldMemberCount)
	}
	if m.unfinished_count != nil {
		fields = append(fields, task.FieldUnfinishedCount)
	}
	if m.agree_count != nil {
		fields = append(fields, task.FieldAgreeCount)
	}
	if m.kind != nil {
		fields = append(fields, task.FieldKind)
	}
	if m.sequential != nil {
		fields = append(fields, task.FieldSequential)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTenantID:
		return m.TenantID()
	case task.FieldProcInstID:
		return m.ProcInstID()
	case task.FieldProcDefID:
		return m.ProcDefID()
	case task.FieldExecutionID:
		return m.ExecutionID()
	case task.FieldRunID:
		return m.RunID()
	case task.FieldTaskDefKey:
		return m.TaskDefKey()
	case task.FieldParentID:
		return m.ParentID()
	case task.FieldComments:
		return m.Comments()
	case task.FieldAssignee:
		return m.Assignee()
	case task.FieldMemberCount:
		return m.MemberCount()
	case task.FieldUnfinishedCount:
		return m.UnfinishedCount()
	case task.FieldAgreeCount:
		return m.AgreeCount()
	case task.FieldKind:
		return m.Kind()
	case task.FieldSequential:
		return m.Sequential()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldTenantID:
		return m.OldTenantID(ctx)
	case task.FieldProcInstID:
		return m.OldProcInstID(ctx)
	case task.FieldProcDefID:
		return m.OldProcDefID(ctx)
	case task.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case task.FieldRunID:
		return m.OldRunID(ctx)
	case task.FieldTaskDefKey:
		return m.OldTaskDefKey(ctx)
	case task.FieldParentID:
		return m.OldParentID(ctx)
	case task.FieldComments:
		return m.OldComments(ctx)
	case task.FieldAssignee:
		return m.OldAssignee(ctx)
	case task.FieldMemberCount:
		return m.OldMemberCount(ctx)
	case task.FieldUnfinishedCount:
		return m.OldUnfinishedCount(ctx)
	case task.FieldAgreeCount:
		return m.OldAgreeCount(ctx)
	case task.FieldKind:
		return m.OldKind(ctx)
	case task.FieldSequential:
		return m.OldSequential(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case task.FieldProcInstID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcInstID(v)
		return nil
	case task.FieldProcDefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcDefID(v)
		return nil
	case task.FieldExecutionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case task.FieldRunID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunID(v)
		return nil
	case task.FieldTaskDefKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskDefKey(v)
		return nil
	case task.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case task.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case task.FieldAssignee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignee(v)
		return nil
	case task.FieldMemberCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberCount(v)
		return nil
	case task.FieldUnfinishedCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnfinishedCount(v)
		return nil
	case task.FieldAgreeCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreeCount(v)
		return nil
	case task.FieldKind:
		v, ok := value.(task.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case task.FieldSequential:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequential(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(task.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, task.FieldTenantID)
	}
	if m.addproc_def_id != nil {
		fields = append(fields, task.FieldProcDefID)
	}
	if m.addparent_id != nil {
		fields = append(fields, task.FieldParentID)
	}
	if m.addmember_count != nil {
		fields = append(fields, task.FieldMemberCount)
	}
	if m.addunfinished_count != nil {
		fields = append(fields, task.FieldUnfinishedCount)
	}
	if m.addagree_count != nil {
		fields = append(fields, task.FieldAgreeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTenantID:
		return m.AddedTenantID()
	case task.FieldProcDefID:
		return m.AddedProcDefID()
	case task.FieldParentID:
		return m.AddedParentID()
	case task.FieldMemberCount:
		return m.AddedMemberCount()
	case task.FieldUnfinishedCount:
		return m.AddedUnfinishedCount()
	case task.FieldAgreeCount:
		return m.AddedAgreeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldTenantID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case task.FieldProcDefID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcDefID(v)
		return nil
	case task.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case task.FieldMemberCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemberCount(v)
		return nil
	case task.FieldUnfinishedCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnfinishedCount(v)
		return nil
	case task.FieldAgreeCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgreeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldRunID) {
		fields = append(fields, task.FieldRunID)
	}
	if m.FieldCleared(task.FieldParentID) {
		fields = append(fields, task.FieldParentID)
	}
	if m.FieldCleared(task.FieldComments) {
		fields = append(fields, task.FieldComments)
	}
	if m.FieldCleared(task.FieldAssignee) {
		fields = append(fields, task.FieldAssignee)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldRunID:
		m.ClearRunID()
		return nil
	case task.FieldParentID:
		m.ClearParentID()
		return nil
	case task.FieldComments:
		m.ClearComments()
		return nil
	case task.FieldAssignee:
		m.ClearAssignee()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldTenantID:
		m.ResetTenantID()
		return nil
	case task.FieldProcInstID:
		m.ResetProcInstID()
		return nil
	case task.FieldProcDefID:
		m.ResetProcDefID()
		return nil
	case task.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case task.FieldRunID:
		m.ResetRunID()
		return nil
	case task.FieldTaskDefKey:
		m.ResetTaskDefKey()
		return nil
	case task.FieldParentID:
		m.ResetParentID()
		return nil
	case task.FieldComments:
		m.ResetComments()
		return nil
	case task.FieldAssignee:
		m.ResetAssignee()
		return nil
	case task.FieldMemberCount:
		m.ResetMemberCount()
		return nil
	case task.FieldUnfinishedCount:
		m.ResetUnfinishedCount()
		return nil
	case task.FieldAgreeCount:
		m.ResetAgreeCount()
		return nil
	case task.FieldKind:
		m.ResetKind()
		return nil
	case task.FieldSequential:
		m.ResetSequential()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.proc_inst != nil {
		edges = append(edges, task.EdgeProcInst)
	}
	if m.task_identities != nil {
		edges = append(edges, task.EdgeTaskIdentities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeProcInst:
		if id := m.proc_inst; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeTaskIdentities:
		ids := make([]ent.Value, 0, len(m.task_identities))
		for id := range m.task_identities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtask_identities != nil {
		edges = append(edges, task.EdgeTaskIdentities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeTaskIdentities:
		ids := make([]ent.Value, 0, len(m.removedtask_identities))
		for id := range m.removedtask_identities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproc_inst {
		edges = append(edges, task.EdgeProcInst)
	}
	if m.clearedtask_identities {
		edges = append(edges, task.EdgeTaskIdentities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeProcInst:
		return m.clearedproc_inst
	case task.EdgeTaskIdentities:
		return m.clearedtask_identities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeProcInst:
		m.ClearProcInst()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeProcInst:
		m.ResetProcInst()
		return nil
	case task.EdgeTaskIdentities:
		m.ResetTaskIdentities()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}
